<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>操作系统引论 Q&amp;A</title>
    <url>/2022/07/07/OS1/</url>
    <content><![CDATA[<h3 id="1-设计现代-OS-的主要目标是什么"><a href="#1-设计现代-OS-的主要目标是什么" class="headerlink" title="1. 设计现代 OS 的主要目标是什么"></a>1. 设计现代 OS 的主要目标是什么</h3><p>方便性，有效性，可扩展性，开放性</p>
<h3 id="2-OS-的作用可表现在哪几个方面"><a href="#2-OS-的作用可表现在哪几个方面" class="headerlink" title="2. OS 的作用可表现在哪几个方面"></a>2. OS 的作用可表现在哪几个方面</h3><ul>
<li>硬件系统和用户之间的接口</li>
<li>计算机系统资源的管理者（CPU、存储器、IO、文件）</li>
<li>实现了对计算资源的抽象</li>
</ul>
<h3 id="3-为什么说操作系统实现了对计算机资源的抽象"><a href="#3-为什么说操作系统实现了对计算机资源的抽象" class="headerlink" title="3. 为什么说操作系统实现了对计算机资源的抽象"></a>3. 为什么说操作系统实现了对计算机资源的抽象</h3><ol>
<li>IO设备管理软件实现了对计算机硬件操作的第一个层次的抽象；</li>
<li>文件管理软件实现了对硬件资源操作的第二个层次的抽象；</li>
<li>依此类推，如果在文件管理软件上再覆盖一层面向用户的窗口软件，则用户便可再窗口环境下方便地使用计算机，从而形成一台功能更强的虚拟机；</li>
<li>OS 是铺设再计算机硬件上的多层软件的集合，它们不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型；</li>
</ol>
<h3 id="4-试说明推动多道批处理系统形成和发展的主要动力是什么"><a href="#4-试说明推动多道批处理系统形成和发展的主要动力是什么" class="headerlink" title="4.试说明推动多道批处理系统形成和发展的主要动力是什么"></a>4.试说明推动多道批处理系统形成和发展的主要动力是什么</h3><ol>
<li>不断提高资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求</li>
<li>提高系统吞吐量</li>
</ol>
<h3 id="5-何谓脱机I-x2F-O和联机I-x2F-O"><a href="#5-何谓脱机I-x2F-O和联机I-x2F-O" class="headerlink" title="5. 何谓脱机I&#x2F;O和联机I&#x2F;O?"></a>5. 何谓脱机I&#x2F;O和联机I&#x2F;O?</h3><p>脱机IO：事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带上的数据输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存</p>
<p>联机IO：在主机的直接控制下进行输入&#x2F;输出的方式，称为联机输入&#x2F;输出（On-Line I&#x2F;O）方式</p>
<h3 id="6-试说明推动分时系统形成和发展的主要动力是什么。"><a href="#6-试说明推动分时系统形成和发展的主要动力是什么。" class="headerlink" title="6. 试说明推动分时系统形成和发展的主要动力是什么。"></a>6. 试说明推动分时系统形成和发展的主要动力是什么。</h3><ol>
<li>满足用户的需要，主要表现在CPU的分时使用缩短了作业的使用周期；</li>
<li>人机交互能力使用户能直接的控制自己的作业；</li>
<li>主机的共享使多个用户能同时使用同一台计算机，独立处理自己的作业</li>
</ol>
<h3 id="7-实现分时系统的关键问题是什么？应如何解决？"><a href="#7-实现分时系统的关键问题是什么？应如何解决？" class="headerlink" title="7. 实现分时系统的关键问题是什么？应如何解决？"></a>7. 实现分时系统的关键问题是什么？应如何解决？</h3><p>分时系统的关键问题是使用户能与自己的作业进行交互，或者说，它追求的主要目标是系统能及时响应用户的终端命令。为此，作业提交时应直接进入内存，并且系统中必须采用按时间片轮转运行的分时技术。</p>
<h3 id="8-为什么要引入实时操作系统？"><a href="#8-为什么要引入实时操作系统？" class="headerlink" title="8. 为什么要引入实时操作系统？"></a>8. 为什么要引入实时操作系统？</h3><p>实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理,并控制所有实时任务协调一致地运行。 弓|入实时OS是为了满足应用的需求，更好地满足实时控制领域和实时信息处理领域的需要。</p>
<h3 id="9-什么是硬实时任务和软实时任务？试举例说明。"><a href="#9-什么是硬实时任务和软实时任务？试举例说明。" class="headerlink" title="9. 什么是硬实时任务和软实时任务？试举例说明。"></a>9. 什么是硬实时任务和软实时任务？试举例说明。</h3><ul>
<li><p>硬实时任务（Hard Real-time Task）:系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果。 如：工业和武器控制系统中</p>
</li>
<li><p>软实时任务（Soft Real-time Task）:偶尔错过了任务的截止时间，对系统产生的影响也不会太大。 如：信息查询和多媒体系统中</p>
</li>
</ul>
<h3 id="10-试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。"><a href="#10-试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。" class="headerlink" title="10. 试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。"></a>10. 试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。</h3><ol>
<li>及时性:实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的:等待时间来确定;而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微妙。 </li>
<li>交互性:实时信息处理系统具有交互性，但人与系统的交互仅限于访问系统中某些特定的专用服务程序。不像分时系统那样能向终端用户提供数据和资源共享等服务。 </li>
<li>可靠性:分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。</li>
</ol>
<h3 id="11-OS有哪几大特征？其最基本的特征是什么？"><a href="#11-OS有哪几大特征？其最基本的特征是什么？" class="headerlink" title="11. OS有哪几大特征？其最基本的特征是什么？"></a>11. OS有哪几大特征？其最基本的特征是什么？</h3><p>四大特征：并发，异步，共享，虚拟;</p>
<p>基本特征：并发，共享;</p>
<h3 id="12-在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？"><a href="#12-在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？" class="headerlink" title="12. 在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？"></a>12. 在多道程序技术的OS环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？</h3><p>一般情况下的资源共享只是说明某种资源能被大家使用，只要经过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。而OS环境下的资源共享是指系统中的资源可供内存中多个并发执行的进程共同使用，这里在宏观上既限定了时间，也限定了地点，其管理要复杂的多，因为系统中的资源远少于多道程序需求的总和，会形成对共享资源的争夺。 对独占资源应该采取互斥共享方式。</p>
<h3 id="13-什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。"><a href="#13-什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。" class="headerlink" title="13. 什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。"></a>13. 什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。</h3><p>时分复用技术是将不同的信号相互交织在不同的时间段内， 沿着同一个信道传输；在接收端再用某种方法， 将各个时间段内的信号提取出来还原成原始信号的通信技术。 这种技术可以在同一个信道上传输多路信号。 时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间， 又转去为其他用户服务使设备得到最充分的利用。</p>
<h3 id="14-是什么原因使操作系统具有异步性特征？"><a href="#14-是什么原因使操作系统具有异步性特征？" class="headerlink" title="14. 是什么原因使操作系统具有异步性特征？"></a>14. 是什么原因使操作系统具有异步性特征？</h3><p>在多道程序环境下允许多个进程并发执行， 但由于资源等因素的限制， 进程的执行通常并非一气呵成， 而是以走走停停的方式运行。内存中的每个进程在何时执行， 何时暂停，以怎样的速度向前推进， 每道程序总共需要多少时间才能完成， 都是不可预知的， 因此导致作业完成的先后次序与进入内存的次序并不完全一致。 或者说， 进程是以异步方式运行的。但在有关进程控制及同步机制等的支持下， 只要运行环境相同， 作业经多次运行， 都会获得完全相同的结果， 因而进程以异步的方式执行是系统所允许的。</p>
<h3 id="15-处理机管理有哪些主要功能？其主要任务是什么？"><a href="#15-处理机管理有哪些主要功能？其主要任务是什么？" class="headerlink" title="15. 处理机管理有哪些主要功能？其主要任务是什么？"></a>15. 处理机管理有哪些主要功能？其主要任务是什么？</h3><p>进程控制 进程同步 进程通信 进程调度</p>
<h3 id="16-内存管理有哪些主要功能？其主要任务是什么？"><a href="#16-内存管理有哪些主要功能？其主要任务是什么？" class="headerlink" title="16. 内存管理有哪些主要功能？其主要任务是什么？"></a>16. 内存管理有哪些主要功能？其主要任务是什么？</h3><p>主要功能：内存分配、内存保护、地址映射、内存扩充</p>
<p>主要任务：为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存</p>
<h3 id="17-内存管理有哪些主要功能？其主要任务是什么？"><a href="#17-内存管理有哪些主要功能？其主要任务是什么？" class="headerlink" title="17. 内存管理有哪些主要功能？其主要任务是什么？"></a>17. 内存管理有哪些主要功能？其主要任务是什么？</h3><p>设备管理的主要任务是完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理，设备分配，设备处理和虚拟设备等</p>
<h3 id="18-文件管理有哪些主要功能？其主要任务是什么？"><a href="#18-文件管理有哪些主要功能？其主要任务是什么？" class="headerlink" title="18. 文件管理有哪些主要功能？其主要任务是什么？"></a>18. 文件管理有哪些主要功能？其主要任务是什么？</h3><p>主要功能：文件存储空间管理、目录管理、文件的读&#x2F;写管理和保护</p>
<p>主要任务：对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性</p>
<h3 id="19-试说明推动传统OS演变为现代OS的主要因素是什么？"><a href="#19-试说明推动传统OS演变为现代OS的主要因素是什么？" class="headerlink" title="19. 试说明推动传统OS演变为现代OS的主要因素是什么？"></a>19. 试说明推动传统OS演变为现代OS的主要因素是什么？</h3><ol>
<li>不断提高计算机资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求</li>
</ol>
<h3 id="20-微内核操作系统具有哪些优点？它为何能有这些优点？"><a href="#20-微内核操作系统具有哪些优点？它为何能有这些优点？" class="headerlink" title="20. 微内核操作系统具有哪些优点？它为何能有这些优点？"></a>20. 微内核操作系统具有哪些优点？它为何能有这些优点？</h3><ol>
<li><p>提高了系统的可扩展性</p>
</li>
<li><p>增强了系统的可靠性</p>
</li>
<li><p>可移植性强</p>
</li>
<li><p>提供了对分布式系统的支持</p>
</li>
<li><p>融入了面向对象技术</p>
</li>
</ol>
<p>原因：微内核os结构是建立在模块化，层次化结构基础上的，并且采用了客户&#x2F;服务器模式和面对对象的程序设计技术。</p>
<h3 id="21-什么是微内核os"><a href="#21-什么是微内核os" class="headerlink" title="21. 什么是微内核os"></a>21. 什么是微内核os</h3><p>微内核操作系统就是将操作系统划分为两大部分，微内核和多个服务器。在操作系统内核中只留下一些最基本的功能。而将其他服务尽可能的从内核中分离出去。用若干个运行的用户态下的服务器进程来实现形成客户服务器模式。</p>
<p>微内核操作系统有四个特点，一是足够小的内核，二是基于客户服务器模式，三是应用机制和策略分离原理，四是采用面向对象技术。</p>
<h3 id="22-现代操作系统较之传统操作系统又增加了哪些功能和特征？"><a href="#22-现代操作系统较之传统操作系统又增加了哪些功能和特征？" class="headerlink" title="22. 现代操作系统较之传统操作系统又增加了哪些功能和特征？"></a>22. 现代操作系统较之传统操作系统又增加了哪些功能和特征？</h3><ol>
<li>进程(线程)管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理</li>
</ol>
<h3 id="23-在微内核OS中，为什么要采用客户-x2F-服务器模式？"><a href="#23-在微内核OS中，为什么要采用客户-x2F-服务器模式？" class="headerlink" title="23. 在微内核OS中，为什么要采用客户&#x2F;服务器模式？"></a>23. 在微内核OS中，为什么要采用客户&#x2F;服务器模式？</h3><p>C&#x2F;S模式具有独特的优点: </p>
<ol>
<li>数据的分布处理和存储。</li>
<li>便于集中管理。</li>
<li>灵活性和可扩充性。 </li>
<li>易于改编应用软件。</li>
</ol>
<h3 id="24-在基于微内核结构的OS中，应用了哪些新技术？"><a href="#24-在基于微内核结构的OS中，应用了哪些新技术？" class="headerlink" title="24. 在基于微内核结构的OS中，应用了哪些新技术？"></a>24. 在基于微内核结构的OS中，应用了哪些新技术？</h3><p>面向对象的程序设汁技术。</p>
<h3 id="25-何谓微内核技术？在微内核中通常提供了哪些功能？"><a href="#25-何谓微内核技术？在微内核中通常提供了哪些功能？" class="headerlink" title="25. 何谓微内核技术？在微内核中通常提供了哪些功能？"></a>25. 何谓微内核技术？在微内核中通常提供了哪些功能？</h3><p>把操作系统中更多的成分和功能放到更高的层次(即用户模式)中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。在微内核中通常提供了进程(线程)管理、低级存储器管理、中断和陷入处理等功能。</p>
<h3 id="26-批处理系统、分时系统和实时系统各有什么特点？"><a href="#26-批处理系统、分时系统和实时系统各有什么特点？" class="headerlink" title="26. 批处理系统、分时系统和实时系统各有什么特点？"></a>26. 批处理系统、分时系统和实时系统各有什么特点？</h3><ol>
<li><p>批处理系统的用户脱机使用计算机， 作业是成批处理的，系统内多道程序并发执行，交互能力差。</p>
</li>
<li><p>分时系统多个用户可以同时使用计算机，是具有强交互性和及时性。采用的技术是引入时间片，多个用户请求分时共享系统资源。</p>
</li>
<li><p>实时系统的特点是具有高可靠性和高及时性。采用多级容错技术保证高可靠性，基于任务的截止时间或优先级来分配CPU。</p>
</li>
</ol>
<h3 id="27-处理机为什么要区分核心态和用户态两种操作方式？什么情况下进行两种方式的转换？"><a href="#27-处理机为什么要区分核心态和用户态两种操作方式？什么情况下进行两种方式的转换？" class="headerlink" title="27. 处理机为什么要区分核心态和用户态两种操作方式？什么情况下进行两种方式的转换？"></a>27. 处理机为什么要区分核心态和用户态两种操作方式？什么情况下进行两种方式的转换？</h3><p>在CPU中运行的操作系统程序和用户程序对应的机器指令集是不同的。操作系统程序使用所有指令，但用户程序只能使用部分指令。从 资源 管理和程序控制执行的角度出发，将指令系统分为两大部分：特权指令和非特权指令。在程序执行时候，根据执行程序对资源和机器指令的使用权限，把机器设置为两个状态：核心态和用户态。</p>
<p>也就是说，当系统处于核心态时，就可以使用所有指令、资源，并具备改变CPU状态的能力；而当CPU在用户态时，只能使用非特权指令。</p>
<p>如果CPU执行用户程序时（用户态），出现了中断，系统将自行转到中断处理程序，CPU就由用户态转到核心态，中断处理结束后，返回继续执行用户程序，此时，CPU又由核心态转到用户态中。</p>
<h3 id="28-为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？"><a href="#28-为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？" class="headerlink" title="28. 为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？"></a>28. 为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？</h3><p>多道程序并发执行是指有的程序正在CPU上执行，而另一些程序正在I&#x2F;O设备上进 行传输，即通过CPU操作与外设传输在时间上的重叠必须有中断和通道技术支持，其原因如下：</p>
<ol>
<li><p>通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立于CPU运行，因而做到了输入&#x2F;输出操作与CPU并行工作。但早期CPU与通道的联络方法是由CPU向通 道发出询问指令来了解通道工作是否完成的。若未完成，则主机就循环询问直到通道工作结 束为止。因此，这种询问方式是无法真正做到CPU与I&#x2F;O设备并行工作的。</p>
</li>
<li><p>在硬件上引入了中断技术。所谓中断，就是在输入&#x2F;输出结束时，或硬件发生某种故 障时，由相应的硬件（即中断机构）向CPU发出信号，这时CPU立即停下工作而转向处理中断请求，待处理完中断后再继续原来的工作。</p>
</li>
</ol>
<p>因此，通道技术和中断技术结合起来就可以实现CPU与I&#x2F;O设备并行工作，即CPU启 动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入&#x2F;输出操作；当通道工作结束时，再通过中断机构向CPU发出中断请求，CPU则暂停正在执行的操作，对出巧的 中断进行处理，处理完后再继续原来的工作。这样，就真正做到了 CPU与I&#x2F;O设备并行工作。此时，多道程序的概念才变为现实。</p>
]]></content>
  </entry>
  <entry>
    <title>进程描述与控制 Q&amp;A</title>
    <url>/2022/08/06/OS2/</url>
    <content><![CDATA[<h3 id="1-什么是前趋图？为什么要引入前趋图？"><a href="#1-什么是前趋图？为什么要引入前趋图？" class="headerlink" title="1. 什么是前趋图？为什么要引入前趋图？"></a>1. 什么是前趋图？为什么要引入前趋图？</h3><p>前驱图是一个有向无环图，用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，节点间的有向边则表示两个结点之间存在的偏序或前驱关系。</p>
<p>原因：为了更好地描述进程地顺序和并发执行情况。</p>
<h3 id="3-为什么程序并发执行会产生间断性特征？"><a href="#3-为什么程序并发执行会产生间断性特征？" class="headerlink" title="3. 为什么程序并发执行会产生间断性特征？"></a>3. 为什么程序并发执行会产生间断性特征？</h3><p>程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。</p>
<p>（不可再现性。程序在并发执行时由于不知道哪个程序会被优先执行导致处理结果可能出现不一致。）</p>
<h3 id="4-程序并发执行时为什么会失去封闭性和可再现性？"><a href="#4-程序并发执行时为什么会失去封闭性和可再现性？" class="headerlink" title="4. 程序并发执行时为什么会失去封闭性和可再现性？"></a>4. 程序并发执行时为什么会失去封闭性和可再现性？</h3><p>封闭性指的是程序一但开始执行，其计算结果就取决于程序本身，不受外界因素影响。可再现性是指当程序重复执行多次时，必将得到相同结果。</p>
<p>因为程序并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态是由多个程序来改变，致使程序的运行失去了封闭性。而程序一旦失去了封闭性也会导致其再失去可再现性。</p>
<h3 id="5-在操作系统中为什么要引入进程的概念？它会产生什么样的影响？"><a href="#5-在操作系统中为什么要引入进程的概念？它会产生什么样的影响？" class="headerlink" title="5. 在操作系统中为什么要引入进程的概念？它会产生什么样的影响？"></a>5. 在操作系统中为什么要引入进程的概念？它会产生什么样的影响？</h3><p>为了使程序可以并发执行，并且可以对并发执行的程序加以描述和控制。</p>
<p>失去封闭性，具有间断性，运行结果不可再现</p>
<h3 id="6-试从动态性、并发性和独立性上比较进程和程序。"><a href="#6-试从动态性、并发性和独立性上比较进程和程序。" class="headerlink" title="6. 试从动态性、并发性和独立性上比较进程和程序。"></a>6. 试从动态性、并发性和独立性上比较进程和程序。</h3><p>动态性是进程最基本的特性，可表现为由创建而产生、由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡，因此进程有一定的生命周期。而程序只是一组有序指令的集合，是静态实体。</p>
<p>并发性是进程的重要特征，同时也是OS的重要特征。引入进程的目的正是为了使程序能和已建立进程的程序并发执行。而程序本身是不能并发执行的。</p>
<p>独立性是指进程实体是一个独立运行的基本单位，同时也是系统中独立获取资源和独立调度的基本单位。而对于未建立任何进程的程序，都不能作为一个独立的单位来运行。</p>
<h3 id="7-试说明PCB的作用具体表现在哪几个方面，为什么说-PCB-是进程存在的唯一标志？"><a href="#7-试说明PCB的作用具体表现在哪几个方面，为什么说-PCB-是进程存在的唯一标志？" class="headerlink" title="7. 试说明PCB的作用具体表现在哪几个方面，为什么说 PCB 是进程存在的唯一标志？"></a>7. 试说明PCB的作用具体表现在哪几个方面，为什么说 PCB 是进程存在的唯一标志？</h3><p><strong>PCB（进程控制块）:</strong></p>
<p>系统中用来存放进程管理和控制信息的数据结构称为进程控制块（Process Control Block）。</p>
<p><strong>PCB的作用：</strong></p>
<p>进程控制块用来保存每个进程和资源的相关信息，包括进程标识、空间、运行状态、资源等相关信息。以便操作系统控制和管理进程和资源。因而它的作用是使一个在多道程序环境下不能独立运行的程序（含数据），称为一个能独立运行的基本单位，一个能和其他进程并发执行的进程。创建进程，实质上是创建进程的PCB；而撤销进程，实质上是撤销进程的PCB。</p>
<p>在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据；进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB;当进程由于某种原因而暂停执行时，又需将其断点的处理机环境保存在PCB中。可见，在进程的整个生命周期中，系统总是通过PCB对进程进行控制的，亦即系统是根据 进程的PCB感知该进程的存在的，所以，PCB是进程存在的唯一标志。</p>
<h3 id="8-PCB提供了进程管理和进程调度所需要的哪些信息？"><a href="#8-PCB提供了进程管理和进程调度所需要的哪些信息？" class="headerlink" title="8. PCB提供了进程管理和进程调度所需要的哪些信息？"></a>8. PCB提供了进程管理和进程调度所需要的哪些信息？</h3><p>进程管理：程序和数据的地址，进程同步和通信机制，资源清单，链接指针。</p>
<p>进程调度：进程状态，进程优先级，进程调度所需其他信息，事件。</p>
<h3 id="9-进程控制块的组织方式有哪几种？"><a href="#9-进程控制块的组织方式有哪几种？" class="headerlink" title="9. 进程控制块的组织方式有哪几种？"></a>9. 进程控制块的组织方式有哪几种？</h3><ol>
<li><p>线性：无论PCB什么状态都将其连续地存放在内存</p>
</li>
<li><p>链接：同一个状态下的PCB串起来链接成一个队列</p>
</li>
<li><p>索引：状态指针 -&gt; 状态索引表-&gt; （表中每一行单指向）一个PCB</p>
</li>
</ol>
<h3 id="10-何谓操作系统内核？内核的主要功能是什么？"><a href="#10-何谓操作系统内核？内核的主要功能是什么？" class="headerlink" title="10. 何谓操作系统内核？内核的主要功能是什么？"></a>10. 何谓操作系统内核？内核的主要功能是什么？</h3><p>通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧密程度较高的软件层次中，将他们常驻内存，即内核。</p>
<p>中断处理、时钟管理、原语操作。</p>
<h3 id="11-为什么要引入挂起状态？该状态有哪些性质？"><a href="#11-为什么要引入挂起状态？该状态有哪些性质？" class="headerlink" title="11. 为什么要引入挂起状态？该状态有哪些性质？"></a>11. 为什么要引入挂起状态？该状态有哪些性质？</h3><p>挂起的过程中，PCB被复制到指定内存区域考察进程运行情况（主要目的是为了检查与修改或是暂停程序）。在下一章中挂起的目的主要是在内存不足时，将内存中的进程调回外存中等待。<br>与阻塞不同，挂起是主动的，现行状态由活动改为静止。需要注意的是，若进程处于执行状态挂起时，会进入静止就绪，再次激活会进入活动就绪状态而不是回到执行态。</p>
<h3 id="12-试说明进程在三个基本状态之间转换的典型原因"><a href="#12-试说明进程在三个基本状态之间转换的典型原因" class="headerlink" title="12. 试说明进程在三个基本状态之间转换的典型原因"></a>12. 试说明进程在三个基本状态之间转换的典型原因</h3><ol>
<li><p>就绪状态 -&gt; 执行状态：进程分配到CPU资源（进程调度）</p>
</li>
<li><p>执行状态 -&gt; 就绪状态：时间片用完、有更高优先级进程抢占。</p>
</li>
<li><p>执行状态 -&gt; 阻塞状态：I&#x2F;O请求、等待某事件、申请某种资源。</p>
</li>
<li><p>阻塞状态 -&gt; 就绪状态：I&#x2F;O完成、某时间发生、申请到某种资源。</p>
</li>
</ol>
<h3 id="13-在进程切换时，所要保存的处理机状态信息有哪些。"><a href="#13-在进程切换时，所要保存的处理机状态信息有哪些。" class="headerlink" title="13. 在进程切换时，所要保存的处理机状态信息有哪些。"></a>13. 在进程切换时，所要保存的处理机状态信息有哪些。</h3><ol>
<li><p>进程当前暂存信息</p>
</li>
<li><p>下一指令地址信息</p>
</li>
<li><p>进程状态信息</p>
</li>
<li><p>过程和系统调用参数及调用地址信息</p>
</li>
</ol>
<h3 id="14-试说明引起进程创建的主要事件。"><a href="#14-试说明引起进程创建的主要事件。" class="headerlink" title="14. 试说明引起进程创建的主要事件。"></a>14. 试说明引起进程创建的主要事件。</h3><ol>
<li><p>用户登录：系统为用户创建一个进程，并插入就绪队列</p>
</li>
<li><p>作业调度</p>
</li>
<li><p>提供服务：系统为用户请求创建一个进程</p>
</li>
<li><p>应用请求：用户程序自己创建进程</p>
</li>
</ol>
<h3 id="15-试说明引起进程撤销的主要事件"><a href="#15-试说明引起进程撤销的主要事件" class="headerlink" title="15. 试说明引起进程撤销的主要事件"></a>15. 试说明引起进程撤销的主要事件</h3><ol>
<li><p>进程完成指派工作，正常终止。</p>
</li>
<li><p>由于出现错误，异常终止。</p>
</li>
<li><p>父（或者祖先）进程的要求被终止。</p>
</li>
</ol>
<h3 id="16-在创建一个进程时所要完成的主要工作是什么？"><a href="#16-在创建一个进程时所要完成的主要工作是什么？" class="headerlink" title="16. 在创建一个进程时所要完成的主要工作是什么？"></a>16. 在创建一个进程时所要完成的主要工作是什么？</h3><ol>
<li><p>申请空白PCB（进程控制块）</p>
</li>
<li><p>为新进程分派资源</p>
</li>
<li><p>初始化PCB</p>
</li>
<li><p>将新进程插入就绪队列</p>
</li>
</ol>
<h3 id="17-在撤消一个进程时所要完成的主要工作是什么？"><a href="#17-在撤消一个进程时所要完成的主要工作是什么？" class="headerlink" title="17. 在撤消一个进程时所要完成的主要工作是什么？"></a>17. 在撤消一个进程时所要完成的主要工作是什么？</h3><ol>
<li><p>根据被终止的进程标识符，从PCB集中检索出进程，读出该进程状态</p>
</li>
<li><p>若被终止进程处于执行状态，立即中止该进程的执行，置调度标志为真，指示该进程被终止后重新调度</p>
</li>
<li><p>若该进程还有子进程，应将所有子孙进程终止</p>
</li>
<li><p>将被中止进程的全部资源，归还给父进程&#x2F;系统</p>
</li>
<li><p>将被终止进程PCB,从所在队列或列表中移出</p>
</li>
</ol>
<h3 id="18-试说明引起进程阻塞或被唤醒的主要事件是什么？"><a href="#18-试说明引起进程阻塞或被唤醒的主要事件是什么？" class="headerlink" title="18. 试说明引起进程阻塞或被唤醒的主要事件是什么？"></a>18. 试说明引起进程阻塞或被唤醒的主要事件是什么？</h3><ol>
<li><p>向系统请求共享资源失败</p>
</li>
<li><p>等待某种操作的完成</p>
</li>
<li><p>新数据尚未到达</p>
</li>
<li><p>等待新任务的到达</p>
</li>
</ol>
<h3 id="19-为什么要在OS中引入线程？"><a href="#19-为什么要在OS中引入线程？" class="headerlink" title="19. 为什么要在OS中引入线程？"></a>19. 为什么要在OS中引入线程？</h3><p>由于进程是资源的拥有者，所以在创建、撤销、切换操作中需要较大的时空开销，限制了并发程度的进一步提高。为减少进程切换的开销，把进程作为资源分配单位和调度单位这两个属性分开处理，即进程还是作为资源分配的基本单位，但是不作为调度的基本单位（很少调度或切换），把调度执行与切换的责任交给“线程”。这样做的好处不但可以提高系统的并发度，还能适应新的对称多处理机（SMP）环境的运行，充分发挥其性能。</p>
<h3 id="20-试说明线程有哪些属性？"><a href="#20-试说明线程有哪些属性？" class="headerlink" title="20. 试说明线程有哪些属性？"></a>20. 试说明线程有哪些属性？</h3><p>1.轻型实体</p>
<p>线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源，比如，在每个线程中都应具有一个用于控制线程运行的线程控制块TCB，用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p>
<ol start="2">
<li>独立调度和分派的基本单位</li>
</ol>
<p>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小。</p>
<ol start="3">
<li>可并发执行</li>
</ol>
<p>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行。</p>
<ol start="4">
<li>共享进程资源</li>
</ol>
<p>在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。</p>
<h3 id="21-试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。"><a href="#21-试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。" class="headerlink" title="21. 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。"></a>21. 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。</h3><ol>
<li>调度性</li>
</ol>
<p>在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，在引入线程的OS中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位；</p>
<ol start="2">
<li>并发性</li>
</ol>
<p>在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使OS具有更好的并发性； </p>
<ol start="3">
<li>拥有资源</li>
</ol>
<p>无论是传统的操作系统，还是引入了线程的操作系统，进程始终是拥有资源的一个基本单位，而线程除了拥有一点在运行时必不可少的资源外，本身基本不拥有系统资源，但它可以访问其隶属进程的资源；<br>4. 开销</p>
<p>由于创建或撤销进程时，系统都要为之分配和回收资源，如内存空间等，进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，操作系统在创建、撤消和切换进程时所付出的开销将显著地大于线程。</p>
<h3 id="22-线程控制块-TCB-中包含了哪些内容？"><a href="#22-线程控制块-TCB-中包含了哪些内容？" class="headerlink" title="22. 线程控制块 TCB 中包含了哪些内容？"></a>22. 线程控制块 TCB 中包含了哪些内容？</h3><p><strong>第一种描述</strong></p>
<ol>
<li><p>进程状态：可以是new、ready、running、waiting或halted等</p>
</li>
<li><p>程序计数器：接着要运行的指令地址</p>
</li>
<li><p>CPU寄存器：如累加器、索引寄存器（IndexRegister）、堆栈指针以及一般用途寄存器、状况代码等，主要用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类因计算机架构有所差异</p>
</li>
<li><p>CPU排班法：优先级、排班队列等指针以及其他参数</p>
</li>
<li><p>存储器管理：如分页表（PageTable）等</p>
</li>
<li><p>会计信息：如CPU与实际时间之使用数量、时限、帐号、工作或进程号码</p>
</li>
<li><p>输入输出状态：配置进程使用I&#x2F;O设备，如磁带机</p>
</li>
</ol>
<p><strong>第二种描述</strong></p>
<ol>
<li><p>进程标识符（内部，外部）</p>
</li>
<li><p>处理机的信息：通用寄存器，指令计数器，PSW，用户的栈指针</p>
</li>
<li><p>进程调度信息：进程状态，进程的优先级，进程调度所需的其它信息，事件</p>
</li>
<li><p>进程控制信息：程序的数据的地址，资源清单，进程同步和通信机制，链接指针</p>
</li>
</ol>
<h3 id="23-何谓用户级线程和内核支持线程？"><a href="#23-何谓用户级线程和内核支持线程？" class="headerlink" title="23. 何谓用户级线程和内核支持线程？"></a>23. 何谓用户级线程和内核支持线程？</h3><ol>
<li>用户级线程</li>
</ol>
<p>仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、线程间的同步与通信等功能， 都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。</p>
<p>有关线程管理的所有工作都由应用程序完成，内核意识不到多线程的存在。用户级线程仅存在于用户空间中，此类线程的创建、撤销、线程之间的同步与通信功能，都无法利用系统调用来实现。应用程序需要通过使用线程库来控制线程。 通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生创建一个在相同进程中运行的新线程。由于线程在进程内切换的规则远比进程调度和切换的规则简单，不需要进行用户态&#x2F;核心态切换，所以切换速度快。</p>
<p>因为用户级线程驻留在用户空间，且管理和控制它们的线程也在用户空间，每个线程并不具有自身的线程上下文，所以它们对于操作系统是不可见的，这也就是它无法被调度到处理器内核的原因。</p>
<p>设置了用户级线程的OS，其调度仍是以进程为单位的</p>
<ol start="2">
<li>内核支持线程：</li>
</ol>
<p>在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、撤销和切换等都是依靠内核，在内核空间中实现的。在内核空间里还 为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。</p>
<p>内核线程建立和销毁都是在内核的支持下运行，由操作系统负责管理，通过系统调用完成的。</p>
<p>线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</p>
<p>内核线程驻留在内核空间，它们是内核对象。操作系统调度器管理、调度并分派这些线程。运行时库为每个用户级线程请求一个内核级线程，将用户进程映射或绑定到上面。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射。</p>
<p>内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。</p>
<p>操作系统的内存管理和调度子系统必须要考虑到数量巨大的用户级线程。您必须了解每个进程允许的线程的最大数目是多少。操作系统为每个线程创建上下文。进程的每个线程在资源可用时都可以被指派到处理器内核，这些线程可以在全系统内进行资源的竞争。</p>
<h3 id="24-试说明用户级线程的实现方法。"><a href="#24-试说明用户级线程的实现方法。" class="headerlink" title="24. 试说明用户级线程的实现方法。"></a>24. 试说明用户级线程的实现方法。</h3><p>用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统是用于管理和控制线程的函数的集合。内核控制线程或轻型进程 LWP 可通过系统调用获得内核提供服务，利用 LWP 进程作为中间系统。</p>
<h3 id="25-试说明内核线程的实现方法。"><a href="#25-试说明内核线程的实现方法。" class="headerlink" title="25. 试说明内核线程的实现方法。"></a>25. 试说明内核线程的实现方法。</h3><p>系统在创建新进程时，分配一个任务数据区 PTDA ，其中包括若干个线程控制块TCB 空间。创建一个线程分配一个TCB ，有关信息写入TCB ，为之分配必要的资源。当 PTDA 中的TCB 用完，而进程又有新线程时，只要所创建的线程数目未超过系统允许值，系统可在为之分配新的TCB ；在撤销一个线程时，也应回收线程的所有资源和 TCB 。</p>
<h3 id="26-多线程模型有哪几种类型？多对一模型有何优缺点？"><a href="#26-多线程模型有哪几种类型？多对一模型有何优缺点？" class="headerlink" title="26. 多线程模型有哪几种类型？多对一模型有何优缺点？"></a>26. 多线程模型有哪几种类型？多对一模型有何优缺点？</h3><p>多对一模型、一对一模型和多对多模型。</p>
<p>多对一模型的主要缺点在于，如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；此外，在任一时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。</p>
<h3 id="27-进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。"><a href="#27-进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。" class="headerlink" title="27. 进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。"></a>27. 进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。</h3><p><strong>进程的定义</strong></p>
<p>从不同的角度进程可以有不同的定义，比较典型的定义有：</p>
<ol>
<li><p>进程是程序的一次执行过程。</p>
</li>
<li><p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>
</li>
<li><p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
</li>
</ol>
<p>进程的定义说明了两点：</p>
<ol>
<li><p>进程与程序有关，进程包含程序。程序是进程的核心内容，没有程序就没有进程。</p>
</li>
<li><p>进程不仅仅是程序，还包含程序在执行过程中使用的全部资源。没有资源，程序就无法执行，因此进程是程序执行的载体。</p>
</li>
</ol>
<p>运行一个程序时，操作系统首先要创建一个进程，为进程分配内存等资源，然后加入进程队列中执行(先就绪再执行)。对单个进程的某个时刻而言，一个进程只能执行一个程序，但对整个系统中的进程集合及进程的生命周期而言，进程与程序之间可以形成一对一，多对一，一对多，多对多的关系。</p>
<ul>
<li><p>执行一条命令或运行一个应用程序时：一对一</p>
</li>
<li><p>进程在执行过程中可以加在执行不同的程序：一对多</p>
</li>
<li><p>以不同的参数或数据多次执行同一个程序：多对一</p>
</li>
<li><p>并发地执行不同的应用程序：多对多</p>
</li>
</ul>
<h3 id="28-父进程创建子进程和主程序调用子程序有何不同？"><a href="#28-父进程创建子进程和主程序调用子程序有何不同？" class="headerlink" title="28. 父进程创建子进程和主程序调用子程序有何不同？"></a>28. 父进程创建子进程和主程序调用子程序有何不同？</h3><p>父进程创建子进程后，父进程与子进程同时执行(并发)</p>
<p>主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序开始执行。</p>
<p>我们可以这么理解：父进程运行的程序，创建了子进程，此时父进程和进程并发执行，是两个进程；主程序调用子程序后，主程序暂停，子程序开始执行，它们还是一个进程。</p>
<h3 id="29-为什么进程之间的通信必须借助操作系统内核功能？"><a href="#29-为什么进程之间的通信必须借助操作系统内核功能？" class="headerlink" title="29. 为什么进程之间的通信必须借助操作系统内核功能？"></a>29. 为什么进程之间的通信必须借助操作系统内核功能？</h3><p>每个进程有自己独立地地址空间。在操作系统和硬件的地址保护机制下，进程无法访问其他进程的地址空间，所以必须借助于操作系统的系统调用函数实现进程之间的通信。</p>
<p><strong>进程通信的主要方式</strong></p>
<ol>
<li><p>共享内存区。通过系统调用创建共享内存区。多个进程可以（通过系统调用）连接同一个共享内存区，通过访问共享内存区实现进程之间的数据交换。使用共享内存区时需要利用信息量解决同步互斥问题。</p>
</li>
<li><p>消息传递。通过发送&#x2F;接收消息（两个系统调用）来实现进程之间的通信。当进程发送时，系统将消息从用户缓冲区复制到内核中的消息缓冲区，然后将消息缓冲区挂入消息队列。进程发送的消息保持在消息队列中，直到被另一进程接收。当进程接收消息时，系统从消息队列中解挂消息缓冲区，将消息从内核的消息缓冲区中恢复到用户缓冲区，然后释放消息缓冲区。</p>
</li>
<li><p>管道系统。管道是先进先出的信息流，允许多个进程向管道写入数据，允许多个进程从管道读出数据。在读&#x2F;写过程中，操作系统保证数据的写入顺序和顺序是一致的。（即发送数据和受到的数据在组织上是一致的，如：发送asd，收到asd，不会收到乱序的das等）进程通过读&#x2F;写管道文件或者管道设备实现彼此的通信。</p>
</li>
<li><p>共享文件。利用操作系统提供的文件共享功能实现进程之间的通信。这个时候，也需要信号量来解决文件共享操作中的同步和互斥问题。</p>
</li>
</ol>
<h3 id="30-多任务处理和多线程的区别"><a href="#30-多任务处理和多线程的区别" class="headerlink" title="30. 多任务处理和多线程的区别"></a>30. 多任务处理和多线程的区别</h3><p><strong>多任务处理</strong></p>
<p>早在发明计算机时，用户一次只能提交工作或任务。 但后来随着高速处理器的出现，一个人可以提交多个任务。因此操作系统能够接受更多每个用户的一项任务的能力被称为多任务处理。CPU 通过在它们之间切换来同时执行多个作业。可以从同一用户或不同用户接受各种工作。 有两种类型的多任务系统：</p>
<ul>
<li><p>单用户多任务</p>
</li>
<li><p>多用户多任务处理</p>
</li>
</ul>
<p><strong>多线程</strong></p>
<p>多线程是一种概念编程范式，其中一个进程被划分为多个称为线程的子进程。每个线程都是独立的，并且具有自己的执行路径，并启用了线程间通信。</p>
<p>线程是执行程序时遵循的路径。每个线程都有自己的程序计数器、堆栈和寄存器。线程是一个轻量级进程。</p>
<p>（多线程的解释还是看上文吧）</p>
<h3 id="31-若系统中没有运行进程，是否一定没有就绪进程？"><a href="#31-若系统中没有运行进程，是否一定没有就绪进程？" class="headerlink" title="31. 若系统中没有运行进程，是否一定没有就绪进程？"></a>31. 若系统中没有运行进程，是否一定没有就绪进程？</h3><p>是。因为若系统中没有运行进程，那么系统很快会选择一个就绪进程运行。只有就绪队列中无进程时，CPU 才可以处于空闲状态。</p>
<h3 id="32-若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？"><a href="#32-若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？" class="headerlink" title="32. 若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？"></a>32. 若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？</h3><p>不一定。因为系统中的所有进程可能都处于等待态，可能处于死锁状态，也有可能因为等待的事件未发生而进入循环等待态。（来自王道答案，我觉得这个回答很烂）</p>
<p>调整一下描述：</p>
<p>因为系统中的所有进程可能都处于等待态，可能处于死锁，也有可能因为等待的事件未发生而进入循环等待。</p>
<h3 id="34-采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程"><a href="#34-采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程" class="headerlink" title="34. 采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程?"></a>34. 采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程?</h3><p>不一定。因为高优先级的进程有可能正处于等待队列中，进程调度会从就绪队列中选择一个进程占用cpu，这个被选中的进程可能优先级较低。</p>
<h3 id="35-为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。"><a href="#35-为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。" class="headerlink" title="35. 为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。"></a>35. 为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。</h3><p>PCB</p>
<h3 id="36-为支持进程的状态变迁，系统至少应该供哪些进程控制原语？"><a href="#36-为支持进程的状态变迁，系统至少应该供哪些进程控制原语？" class="headerlink" title="36. 为支持进程的状态变迁，系统至少应该供哪些进程控制原语？"></a>36. 为支持进程的状态变迁，系统至少应该供哪些进程控制原语？</h3><p>创建进程原语，阻塞进程原语，换行进程原语，终止进程原语。</p>
<h3 id="37-执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。"><a href="#37-执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。" class="headerlink" title="37. 执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。"></a>37. 执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。</h3><ol>
<li>进程创建原语</li>
</ol>
<p>从PCB集合中申请一个空白的PCB，将调用者参数（如进程外部标识符，初始CPU状态，进程优先数，初始内存及申请资源清单）添入该PCB，设置记账数据。置新进程为“就绪”态。</p>
<ol start="2">
<li>终止进程原语</li>
</ol>
<p>用于终止完成的进程，回收其所占资源。包括消去其资源描述块，消去进程的PCB。</p>
<ol start="3">
<li>阻塞原语</li>
</ol>
<p>将进程从运行态变为阻塞态。进程被插入等待事件的队列，同时修改PCB中相应的表项，如进程状态和等待队列指针。</p>
<ol start="4">
<li>唤醒原语</li>
</ol>
<p>将进程从阻塞态变为就绪态。进程从阻塞队列移出，插入就绪队列，等待调度，同时修改PCB中相应的表项，如进程状态。</p>
]]></content>
  </entry>
  <entry>
    <title>处理机调度 Q&amp;A</title>
    <url>/2022/08/06/OS3/</url>
    <content><![CDATA[<h3 id="1-高级调度与低级调度的主要任务是什么-为什么要引入中级调度"><a href="#1-高级调度与低级调度的主要任务是什么-为什么要引入中级调度" class="headerlink" title="1. 高级调度与低级调度的主要任务是什么?为什么要引入中级调度?"></a>1. 高级调度与低级调度的主要任务是什么?为什么要引入中级调度?</h3><ol>
<li><p>高级调度又称为作业调度。它是批处理系统中使用的一种调度。其主要任务是按照某种算法从外存的后备队列上选择一个或多个作业调入内存，并为其创建进程、分配必要的资源，然后再将所创建的进程控制块插入就绪队列中。</p>
</li>
<li><p>低级调度又称进程调度。它是距离硬件最近的一级调度。其主要任务是按照某种算法从就绪队列上选择一个（或多个）进程，使其获得CPU。</p>
</li>
<li><p>引入中级调度的目的是为了<strong>提高内存利用率</strong>和<strong>系统吞吐量</strong>。其功能是，让那些暂时不能运行的进程不再占用宝贵的内存资源，而是调其到外存上等候。此时的进程状态为挂起状态。当这些进程重新具备运行条件且内存空闲时，由中级调度选择一部分挂起状态的进程调入内存并将其状态变为就绪状态。</p>
</li>
</ol>
<h3 id="2-处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？"><a href="#2-处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？" class="headerlink" title="2. 处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？"></a>2. 处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？</h3><p>处理机调度算法的共同目标：资源利用率，公平性，平衡性，策略强制执行</p>
<p>批处理系统的共同目标：平均周转时间短，系统吞吐量高，处理机利用率高</p>
<h3 id="3-何谓作业、作业步和作业流？"><a href="#3-何谓作业、作业步和作业流？" class="headerlink" title="3. 何谓作业、作业步和作业流？"></a>3. 何谓作业、作业步和作业流？</h3><p>作业包含通常的程序和数据，还配有作业说明书。系统根据该说明书对程序的运行进行控制。批处理系统中是以作业为基本单位从外存调入内存。</p>
<p>作业步是指每个作业运行期间都必须经过若干个相对独立相互关联的顺序加工的步骤。</p>
<p>作业流是指若干个作业进入系统后依次存放在外存上形成的输入作业流；在操作系统的控制下，逐个作业进程处理，于是形成了处理作业流。</p>
<h3 id="4-在什么情况下需要使用作业控制块-JCB，其中包含了哪些内容？"><a href="#4-在什么情况下需要使用作业控制块-JCB，其中包含了哪些内容？" class="headerlink" title="4. 在什么情况下需要使用作业控制块 JCB，其中包含了哪些内容？"></a>4. 在什么情况下需要使用作业控制块 JCB，其中包含了哪些内容？</h3><p>为了调度和管理作业，批处理系统中，为每个作业配置了一个JCB，它是作业存在的标志。</p>
<p>JCB包含的内容：作业标识，用户名称，用户账号，作业类型，作业状态，调度信息，资源需求，资源使用情况等。</p>
<h3 id="5-在作业调度中应如何确定接纳多少个作业和接纳哪些作业？"><a href="#5-在作业调度中应如何确定接纳多少个作业和接纳哪些作业？" class="headerlink" title="5. 在作业调度中应如何确定接纳多少个作业和接纳哪些作业？"></a>5. 在作业调度中应如何确定接纳多少个作业和接纳哪些作业？</h3><p>作业调度每次接纳进入内存的作业数，取决于多道程序度。应将哪些作业从外存调入内存，取决于采用的调度算法。 最简单的是先来服务调度算法， 较常用的是短作业优先调度算法和基于作业优先级的调度算法。</p>
<h3 id="6-为什么要引入高响应比优先调度算法？它有何优点？"><a href="#6-为什么要引入高响应比优先调度算法？它有何优点？" class="headerlink" title="6. 为什么要引入高响应比优先调度算法？它有何优点？"></a>6. 为什么要引入高响应比优先调度算法？它有何优点？</h3><p>因为“先来先服务”算法忽略了程序运行时间，“短作业”优先调度又忽略了程序又忽略了程序的等待时间。</p>
<p>高响应比优先算法将这两个因素结合，同时使用“等待时间”和“运行时间”计算程序优先级，让优先级高的程序先运行。</p>
<p>响应比 &#x3D;（ 等待时间+要求服务时间）&#x2F; 要求服务时间</p>
<h3 id="7-试说明低级调度的主要功能"><a href="#7-试说明低级调度的主要功能" class="headerlink" title="7. 试说明低级调度的主要功能"></a>7. 试说明低级调度的主要功能</h3><ol>
<li><p>保存处理机现场信息</p>
</li>
<li><p>按某种算法选取进程</p>
</li>
<li><p>把处理机分配给进程</p>
</li>
</ol>
<h3 id="8-在抢占调度方式中，抢占的原则是什么？"><a href="#8-在抢占调度方式中，抢占的原则是什么？" class="headerlink" title="8. 在抢占调度方式中，抢占的原则是什么？"></a>8. 在抢占调度方式中，抢占的原则是什么？</h3><p>为了防止一个长进程长时间占用处理机，以确保处理机能为所有进程尽可能的提供公平的服务，抢占的原则是：</p>
<ol>
<li>优先权原则：允许优先级高的进程抢优先级低进程的</li>
<li>短进程优先：新到的短时间进程，可以抢占当前长进程的处理机。</li>
<li>时间片原则：按照时间片来分配时间来，时间结束就要停止该进程的执行，重新等待时间片分配</li>
</ol>
<h3 id="9-在选择调度方式和调度算法时，应遵循的准则是什么？"><a href="#9-在选择调度方式和调度算法时，应遵循的准则是什么？" class="headerlink" title="9. 在选择调度方式和调度算法时，应遵循的准则是什么？"></a>9. 在选择调度方式和调度算法时，应遵循的准则是什么？</h3><ol>
<li><p>面向用户准则：对于用户的紧迫性作业，系统能够及时地处理，不至于运行延误；批处理系统追求作业的周转时间短；分时系统追求作业的响应时间快；实时系统中作业的截止时间要有保证。</p>
</li>
<li><p>面向系统准则：系统的吞吐量要高，处理机的利用率要高，各类系统资源能够得到平衡利用。</p>
</li>
</ol>
<h3 id="10-在批处理系统、分时系统和实时系统中，各采用哪几个进程（作业）调度算法？"><a href="#10-在批处理系统、分时系统和实时系统中，各采用哪几个进程（作业）调度算法？" class="headerlink" title="10. 在批处理系统、分时系统和实时系统中，各采用哪几个进程（作业）调度算法？"></a>10. 在批处理系统、分时系统和实时系统中，各采用哪几个进程（作业）调度算法？</h3><ol>
<li><p>批处理系统中的作业调度算法有：先来先服务算法（FCFS）、短作业优先算法（SJF）、优先级调度算法（HPF）和高响应比优先算法（RF）。批处理系统的进程调度算法有：先进先出算法（FIFO）、短进程优先算法（SPF）、优先级调度算法（HPF）和高响应比优先算法（RF）。</p>
</li>
<li><p>分时系统中只设有进程调度（不设作业调度），其进程调度算法只有轮转法（RR）一种。</p>
</li>
<li><p>实时系统中只设有进程（不设作业调度），其进程调度算法调度有：轮转法、优先级调度算法。前者适用于时间要求不严格的实时系统；后者用于时间要求严格的实时系统。后者又可细分为：非抢占式优先级调度、抢占式优先级调度、基于时钟中断的抢占式优先级调度。注意，一个纯粹的实时系统是针对特定应用领域设计的专用系统。作业提交的数量不会超过系统规定的多道程序的道数，因而可全部进入内存。若将实时系统与批处理系统结合的话，就可以让作业量超过多道程序道数，使优先级低的作业呆在外存的后备队列上。</p>
</li>
</ol>
<h3 id="11-何谓静态和动态优先级？确定静态优先级的依据是什么？"><a href="#11-何谓静态和动态优先级？确定静态优先级的依据是什么？" class="headerlink" title="11. 何谓静态和动态优先级？确定静态优先级的依据是什么？"></a>11. 何谓静态和动态优先级？确定静态优先级的依据是什么？</h3><p>静态优先级：在创建进程时确定的，且程序的整个运行期间不变。</p>
<p>动态优先级：在程序运行期间可根据进程推进或随其等待时间的增加而改变。</p>
<h3 id="12-试比较FCFS和SJF两种进程调度算法"><a href="#12-试比较FCFS和SJF两种进程调度算法" class="headerlink" title="12. 试比较FCFS和SJF两种进程调度算法"></a>12. 试比较FCFS和SJF两种进程调度算法</h3><p><strong>FCFS（First-come first-served）先来先服务调度算法</strong></p>
<ul>
<li><p>核心思想：FCFS算法是指进程调度时是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行的一种调度算法。 </p>
</li>
<li><p>作用对象：既可用于作业调度，又可以用于进程调度。</p>
</li>
<li><p>缺点：不利于短作业</p>
</li>
</ul>
<p><strong>SJF（Short Job First）短作业优先调度算法</strong></p>
<ul>
<li><p>核心思想：SJF算法是指以作业的长短来计算优先级，作业越短，其优先级越高，越优先将他们调入内存运行。</p>
</li>
<li><p>作用对象：该算法同FCFS算法一样，既可用于作业调度，又可以用于进程调度。</p>
</li>
<li><p>缺点：必须预知作业的运行时间; 对长作业非常不利; 人机无法交互; 无法及时处理紧迫的作业;</p>
</li>
</ul>
<p><strong>FCFS算法和SJF算法的比较</strong></p>
<ul>
<li>相同点<br>性质相同：都是作为一种调度算法</li>
</ul>
<p>作用对象相同：都可以用于作业调度和进程调度</p>
<p>-不同点</p>
<p>算法思想不同,FCFS算法是指进程调度时是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行的一种调度算法;SJF算法是指以作业的长短来计算优先级，作业越短，其优先级越高，越优先将他们调入内存运行。</p>
<ul>
<li>优缺点相对</li>
</ul>
<p>FCFS有利于长作业，不利于短作业</p>
<p>SJF有利于短作业，不利于长作业</p>
<h3 id="13-在时间片轮转法中，应如何确定时间片的大小？"><a href="#13-在时间片轮转法中，应如何确定时间片的大小？" class="headerlink" title="13. 在时间片轮转法中，应如何确定时间片的大小？"></a>13. 在时间片轮转法中，应如何确定时间片的大小？</h3><p>时间片应略大于一次典型的交互需要的时间。一般应考虑三个因素：系统对相应时间的要求、就绪队列中进程的数目和系统的处理能力。</p>
<h3 id="14-通过一个例子来说明通常的优先级调度算法不能适用于实时系统？"><a href="#14-通过一个例子来说明通常的优先级调度算法不能适用于实时系统？" class="headerlink" title="14. 通过一个例子来说明通常的优先级调度算法不能适用于实时系统？"></a>14. 通过一个例子来说明通常的优先级调度算法不能适用于实时系统？</h3><p>实时系统的调度算法很多，主要是基于任务的开始截止时间和任务紧急&#x2F;松弛程度的任务优先级调度算法，通常的优先级调度算法不能满足实时系统的调度实时性要求而不适用。</p>
<h3 id="15-为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？"><a href="#15-为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？" class="headerlink" title="15. 为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？"></a>15. 为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？</h3><p>终端型用户：由于终端型用户提交的作业多属于交互型作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意</p>
<p>短批处理作业用户：对于这类作业，如果可在第一队列中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。</p>
<p>长批处理作业用户：对于长作业，它将依次在第1，2，……，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</p>
<h3 id="16-为什么说传统的几种调度算法都不能算是公平调度算法？"><a href="#16-为什么说传统的几种调度算法都不能算是公平调度算法？" class="headerlink" title="16. 为什么说传统的几种调度算法都不能算是公平调度算法？"></a>16. 为什么说传统的几种调度算法都不能算是公平调度算法？</h3><p>以上介绍的几种调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。</p>
<h3 id="17-保证调度算法是如何做到调度的公平性的？"><a href="#17-保证调度算法是如何做到调度的公平性的？" class="headerlink" title="17. 保证调度算法是如何做到调度的公平性的？"></a>17. 保证调度算法是如何做到调度的公平性的？</h3><p>保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。</p>
<p>一种比较容易实现的性能保证是处理机分配的公平性。如果在系统中有n个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间1&#x2F;n。</p>
<h3 id="18-公平分享调度算法又是如何做到调度的公平性的？"><a href="#18-公平分享调度算法又是如何做到调度的公平性的？" class="headerlink" title="18. 公平分享调度算法又是如何做到调度的公平性的？"></a>18. 公平分享调度算法又是如何做到调度的公平性的？</h3><p>在公平分享调度算法中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。</p>
<h3 id="19-为什么在实时系统中，要求系统（尤其是-CPU）具有较强的处理能力？"><a href="#19-为什么在实时系统中，要求系统（尤其是-CPU）具有较强的处理能力？" class="headerlink" title="19. 为什么在实时系统中，要求系统（尤其是 CPU）具有较强的处理能力？"></a>19. 为什么在实时系统中，要求系统（尤其是 CPU）具有较强的处理能力？</h3><p>在实时系统中，最重要的就是对时间的概念，如果处理机的处理能力不够强，则有可能因处理机忙不过来，导致某些实时任务不能拿得到及时处理，这在实时系统中，这是重大事故，会造成难以估量的后果。</p>
<p>在实时系统中，不但包括周期任务、偶发任务、非周期任务，还包括非实时任务。实时任务要求要满足时限，而非实时任务要求要使其响应时间尽可能的短。</p>
<p>多种类型任务的混合，使系统的可调度性分析更加困难。实际上有些实时系统CPU处理能力并不强，比如一些嵌入式实时系统，这就要求系统尽量少做一些并发计算任务，留出足够冗余处理实时任务。</p>
<h3 id="20-按调度方式可将实时调度算法分为哪几种？"><a href="#20-按调度方式可将实时调度算法分为哪几种？" class="headerlink" title="20. 按调度方式可将实时调度算法分为哪几种？"></a>20. 按调度方式可将实时调度算法分为哪几种？</h3><p>抢占调度算法和非抢占调度算法</p>
<h3 id="21-什么是最早截止时间优先调度算法（Earliest-Deadline-First，EDF），请举例说明之。"><a href="#21-什么是最早截止时间优先调度算法（Earliest-Deadline-First，EDF），请举例说明之。" class="headerlink" title="21. 什么是最早截止时间优先调度算法（Earliest Deadline First，EDF），请举例说明之。"></a>21. 什么是最早截止时间优先调度算法（Earliest Deadline First，EDF），请举例说明之。</h3><p>EDF算法是指根据任务的截止时间来确定任务的优先级的算法，任务截止时间越早，其优先级愈高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。既可用于抢占式调度方式中，也可以用于非抢占式调度方式中。</p>
<h3 id="22-什么是最低松弛度优先调度算法（Least-Laxity-First，LLF），请举例说明之。"><a href="#22-什么是最低松弛度优先调度算法（Least-Laxity-First，LLF），请举例说明之。" class="headerlink" title="22. 什么是最低松弛度优先调度算法（Least Laxity First，LLF），请举例说明之。"></a>22. 什么是最低松弛度优先调度算法（Least Laxity First，LLF），请举例说明之。</h3><p>LLF算法是指根据任务的紧急（或松弛）程度来确定任务的优先级的算法，任务紧急程度愈高，其优先级就愈高。主要用于可抢占式调度方式中。</p>
<p>任务的松弛度 &#x3D; 必须完成时间 - 其本身的运行时间 - 当前时间</p>
<p>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100ms之前调度执行，该任务的紧急程度（松弛程度）为100ms。</p>
<p>又如，另一任务在400ms时必须完成，它本身需要运行150ms，则其松弛程度为250ms。</p>
<ul>
<li><p>最早截止时间优先调度算法：任务要求的截止时间越早，其优先级就越高。</p>
</li>
<li><p>最低松弛度优先调度算法：任务的紧急程度越高，其优先级就越高。</p>
</li>
</ul>
<h3 id="23-何谓“优先级倒置”现象，可采取什么方法来解决？"><a href="#23-何谓“优先级倒置”现象，可采取什么方法来解决？" class="headerlink" title="23. 何谓“优先级倒置”现象，可采取什么方法来解决？"></a>23. 何谓“优先级倒置”现象，可采取什么方法来解决？</h3><p>当前0S广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。</p>
<h3 id="24-试分别说明可重用资源和可消耗资源的性质。"><a href="#24-试分别说明可重用资源和可消耗资源的性质。" class="headerlink" title="24. 试分别说明可重用资源和可消耗资源的性质。"></a>24. 试分别说明可重用资源和可消耗资源的性质。</h3><p>可重用性资源：每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。进程在使用可重用性资源时，须按照这样的顺序：请求资源、使用资源、释放资源。系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它。</p>
<p>可消耗性资源：每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0。进程在运行过程中，可以不断创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中。</p>
]]></content>
  </entry>
  <entry>
    <title>关于“取指-执行”小记</title>
    <url>/2022/08/12/OS4/</url>
    <content><![CDATA[<p>计算机是一个不断进行“取指-执行”的自动化设备，内存的使用也离不开这个“取指-执行”的基本过程。现在有一条指令 <code>mov %eax,[300]</code>，如何“取指-执行”这条指令呢？我们将自己想象成一台计算机认真梳理整个过程：</p>
<ol>
<li><p>这条指令需要放在内存中;</p>
</li>
<li><p>用 PC 指针指向这条指令;</p>
</li>
<li><p>将这条指令取到 CPU 的IR寄存器中;</p>
</li>
<li><p>解释这条指令发现要从300这个内存单元中取出一个32位二进制数赋给EAX寄存器;</p>
</li>
<li><p>在地址总线上发出地址300，从数据总线上将内存地址300处存放的内容传回并赋给寄存器EAX;</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>2020牛客寒假算法基础集训营1</title>
    <url>/2020/02/04/2020/2020niukewintercontest1/</url>
    <content><![CDATA[<p>题目链接:<a href="https://ac.nowcoder.com/acm/contest/3002#question">https://ac.nowcoder.com/acm/contest/3002#question</a></p>
<p>深夜水一篇题解,今天(应该是昨天了)打了一场,575&#x2F;2780,如果早点起床估计rank还会再高些…出题人应该是老ll粉了.</p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>应该算是一道计算几何题,之前没有写过这种题型,是我最后ac的一道题目.大致上就是分类讨论,计算每一类三角形出现个数,大致分为3类:</p>
<ol>
<li>底边为2高为1,在最外侧.</li>
<li>底边为2高为1,在中间,也就是除了最边上的那些列&#x2F;行.</li>
<li>底为1高为2,注意区分与1,2类重复的那些三角形.</li>
</ol>
<p>还有要注意的地方就是计算<strong>底的值</strong>和<strong>对应的高的个数</strong>和<strong>对应组数</strong>的时候,如果出现小于等于零的数据,就要置零了.</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>const int MOD &#x3D;  1e9 + 7;</p>
<p>long long int n, m;</p>
<p>int main()<br>{<br>    scanf(“%lld %lld”, &amp;n, &amp;m);<br>    long long int part &#x3D; 0;<br>    long long int left &#x3D; n - 2;<br>    if ( left &gt; 0 )<br>    {<br>        part +&#x3D; (left * n * 2 ) % MOD;<br>        if ( m - 2 &gt; 0 ) part +&#x3D; ( ( left * 2 * n  % MOD) * (m - 2) ) % MOD;<br>    }<br>    long long int up &#x3D; m - 2;<br>    if ( up &gt; 0 )<br>    {<br>        part +&#x3D; ( up * m * 2 ) % MOD;<br>        if ( n - 2 &gt; 0 ) part +&#x3D; ( ( up * 2 * m  % MOD) * ( n - 2) ) % MOD;<br>    }<br>    if ( m - 1 &gt; 0 &amp;&amp; n - 2 &gt; 0 &amp;&amp; m - 2 &gt; 0 ) part +&#x3D; ( ( m - 1 ) * ( n - 2 ) % MOD) * ( m - 2 ) * 2 % MOD;<br>    if ( n - 1 &gt; 0 &amp;&amp; m - 2 &gt; 0 &amp;&amp; n - 2 &gt; 0 ) part +&#x3D; ( ( n - 1 ) * ( m - 2 ) % MOD) * ( n - 2 ) * 2 % MOD;<br>    printf(“%lld\n”,part % MOD);<br>    return 0;<br>}</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>很水的一道题…直接上代码</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int n, x, a,b;</p>
<p>int main()<br>{<br>    scanf(“%d %d %d %d”,&amp;n, &amp;x, &amp;a, &amp;b);<br>    int perfect &#x3D; n * a;<br>    int great &#x3D; n * b;<br>    double per1 &#x3D; x, per2 &#x3D; 100 - x;<br>    double ans;<br>    ans &#x3D; per1 * 0.01 * perfect + per2 * 0.01 * great;<br>    printf(“%.2lf”, ans);</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>也是一道水题,数组记录一下然后找没出现的数据就好了.</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int n;<br>map&lt; int, int &gt; m;<br>int cnt[100010];</p>
<p>int main()<br>{<br>    scanf(“%d”,&amp;n);<br>    int num, i;<br>    for (  i &#x3D; 1; i &lt;&#x3D; n - 1; i ++ )<br>    {<br>        scanf(“%d”,&amp;num);<br>        cnt[num] &#x3D; 1;<br>    }<br>    for (  i &#x3D; 1; i &lt;&#x3D; n; i ++ )<br>    {<br>        if ( cnt[i] &#x3D;&#x3D; 0 )<br>        {<br>            printf(“%d\n”,i);<br>            break;<br>        }<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>一道数论题,计算数据的因子个数,然后进行迭代,注意优化一下计算因子个数的算法,第一次直接暴力求素数超时了,以及数据较大要开long long.</p>
<p>计算因子个数的算法: <a href="https://scheng52123.com/index.php/2020/02/05/countfactors/">https://scheng52123.com/index.php/2020/02/05/countfactors/</a></p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>long long int n;</p>
<p>long long int _num( long long int n)<br>{<br>    long long int count &#x3D; 2;<br>    for(long long int i &#x3D; 2; i &lt;&#x3D; sqrt(n); i++)<br>    {<br>        if( n % i &#x3D;&#x3D; 0 )<br>        {<br>            if( i &#x3D;&#x3D; sqrt(n) &amp;&amp; n&#x2F;i&#x3D;&#x3D;i)<br>            {<br>                count++;<br>            }<br>            else count +&#x3D; 2;<br>        }<br>    }<br>    return count;<br>}</p>
<p>int main()<br>{<br>    scanf(“%lld”, &amp;n);<br>    long long int cnt &#x3D; 0;<br>    long long int num &#x3D; _num(n);<br>    cnt ++;<br>    while ( num !&#x3D; 2 )<br>    {<br>        num &#x3D; _num(num);<br>        cnt ++;<br>    }<br>    printf(“%lld\n”,cnt);<br>    return 0;<br>}</p>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>稍微卡了一下,用了双向队列和滑动窗口思想.(看了学长的代码后发现直接O(n^2)暴力也可以…,然后队列应用还有更加巧妙的方法,后续更新).</p>
<p>将数据放到一个滑动窗口里,用一个数组的双向队列记录每种字母的每一个出现的位置.当单个字母的数量达到k时,记录一下答案的值,然后对应字母的队列弹出最前元素,对应字母的记录值自减一次,相当于滑动窗口前端弹出一个值.时间复杂度为O(n).</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>map&lt; char, int &gt; m;<br>int n, k;</p>
<p>string ss;</p>
<p>struct dequeue<br>{<br>    deque<int> q;</p>
<p>} que[30];</p>
<p>int main()<br>{<br>    scanf(“%d %d”,&amp;n, &amp;k);<br>    cin &gt;&gt; ss;<br>    int len, ans;<br>    ans &#x3D; 200010;<br>    for ( int i &#x3D; 0; i &lt; n; i ++  )<br>    {<br>        m[ss[i]] ++;<br>        (que[ss[i]-97].q).push_back(i);<br>        if ( m[ss[i]] &#x3D;&#x3D; k )<br>        {<br>            len &#x3D; i - ( que[ss[i]-97].q ).front() + 1;<br>            ans &#x3D; min( ans, len );<br>            m[ss[i]] –;<br>            ( que[ss[i]-97].q ).pop_front();<br>        }<br>    }<br>    if ( ans &#x3D;&#x3D; 200010 ) printf(“-1\n”);<br>    else printf(“%d\n”,ans);<br>    return 0;<br>}</p>
<p>比赛之后重新写了一个,实际上是可以不用双向队列的,可能是太久没用过队列,导致一些操作忘记了,思路是一样的,代码精简了些.</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int n, k;<br>string ss;</p>
<p>queue<int> q[30];<br>int cnt[30];</p>
<p>int main()<br>{<br>    scanf(“%d %d”,&amp;n, &amp;k);<br>    cin &gt;&gt; ss;<br>    int len, ans;<br>    ans &#x3D; 200010;<br>    for ( int i &#x3D; 0; i &lt; n; i ++  )<br>    {<br>        cnt[ss[i]-97] ++;<br>        q[ss[i]-97].push(i);<br>        if ( cnt[ss[i]-97] &#x3D;&#x3D; k )<br>        {<br>            len &#x3D; i - q[ss[i]-97].front() + 1;<br>            ans &#x3D; min( ans, len );<br>            cnt[ss[i]-97] –;<br>            q[ss[i]-97].pop();<br>        }<br>    }<br>    if ( ans &#x3D;&#x3D; 200010 ) printf(“-1\n”);<br>    else printf(“%d\n”,ans);<br>    return 0;<br>}</p>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>这题给我的感觉就像是codeforce上的那种思维题,也是类似G题用一个滑动窗口的思想.</p>
<p>记录当前窗口长度,0的个数和1的个数.当cnt0和cnt1只要有一个大于k了就说明窗口前端需要弹出一个元素了.整个过程中满足要求的窗口的最大长度就是答案.</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int n, k;<br>string ss;</p>
<p>int main()<br>{<br>    scanf(“%d %d”, &amp;n, &amp;k);<br>    cin &gt;&gt; ss;<br>    int left, right;<br>    int cnt0, cnt1, sum;<br>    left &#x3D; right &#x3D; 0;<br>    cnt0 &#x3D; cnt1 &#x3D; sum &#x3D; 0;<br>    int ans &#x3D; 1, len;<br>    while ( right &lt;&#x3D; n - 1 )<br>    {<br>        if ( ss[right] &#x3D;&#x3D; ‘0’ ) cnt0 ++;<br>        else cnt1 ++;<br>        sum ++;<br>        if ( cnt0 &lt;&#x3D; k || cnt1 &lt;&#x3D; k )<br>        {<br>            len &#x3D; sum;<br>            ans &#x3D; max(len, ans);<br>        }<br>        else<br>        {<br>            if ( ss[left] &#x3D;&#x3D; ‘0’ ) cnt0 –;<br>            else cnt1 –;<br>            left ++;<br>            sum –;<br>            len &#x3D; sum;<br>            ans &#x3D; max(len, ans);<br>        }<br>        right ++;<br>    }<br>    printf(“%d\n”, ans);<br>    return 0;<br>}</p>
<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>当时被题目全是niconi的题面整懵了,比赛的时候考虑过dp写法,但是因为太久没练dp导致我不敢写.看了题解之后发现是一个很裸的dp</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>&#x2F;&#x2F;string str.substr(nStart)<br>&#x2F;&#x2F;默认 从str字符串nStart位置开始截取到str结束为止</p>
<p>&#x2F;&#x2F;string str.substr(nStart, nLength)<br>&#x2F;&#x2F; 从str字符串nStart位置开始截取nLength个字符！<br>&#x2F;&#x2F;如果nLength&gt;剩余的字符则截取到str结束为止</p>
<p>long long int dp[330000];<br>long long int n, a, b, c;<br>string ss;</p>
<p>int main()<br>{<br>    scanf(“%lld %lld %lld %lld”, &amp;n, &amp;a, &amp;b, &amp;c);<br>    cin &gt;&gt; ss;<br>    &#x2F;&#x2F;long long int ans &#x3D; 0;<br>    for ( int i &#x3D; 3; i &lt; n; i ++ )<br>    {<br>        dp[i] &#x3D; dp[i - 1];<br>        long long int temp;<br>        if ( ss.substr(i - 3, 4) &#x3D;&#x3D; “nico” )<br>        {<br>            if ( i &#x3D;&#x3D; 3 ) temp &#x3D; dp[i - 3];<br>            else temp &#x3D; dp[i - 4];<br>            dp[i] &#x3D; max( dp[i], temp + a);<br>        }<br>        if ( i &gt;&#x3D; 5 &amp;&amp; ss.substr( i - 5, 6 ) &#x3D;&#x3D; “niconi”  )<br>        {<br>            if ( i &#x3D;&#x3D; 5 ) temp &#x3D; dp[i - 5];<br>            else temp &#x3D; dp[i - 6];<br>            dp[i] &#x3D; max( dp[i], temp + b );<br>        }<br>        if ( i &gt;&#x3D; 9 &amp;&amp; ss.substr( i - 9, 10 ) &#x3D;&#x3D; “niconiconi” )<br>        {<br>            if ( i &#x3D;&#x3D; 9 ) temp &#x3D; dp[i - 9];<br>            else temp &#x3D; dp[i - 10];<br>            dp[i] &#x3D; max( dp[i], temp + c );<br>        }<br>    }<br>    printf(“%lld\n”,dp[n - 1]);</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>2020浙江省程序设计竞赛小记</title>
    <url>/2020/10/19/2020/2020zjcpc/</url>
    <content><![CDATA[<p>这次浙江省省赛还是比较幸运的,刚好在铜牌线上面几个名次,没有打铁,比赛结束的时候一直以为一定是打铁了…中间掉线了一次,我是用自己手机的热点给电脑网络的,然后刚好打到一半的时候,电信因为我手机欠费把我电话给停机了,造成了几分钟的混乱…所以说下次比赛前应该先把话费充好.</p>
<p>比赛前准备是随机开ADE这三题,我最开始是在读A的,陈浩发现E题的标题是&lt;&lt; Easy DP Problem&gt;&gt;,由于我前段时间写的DP比较多,于是我们交换了题目,也就开始了我接下来五个小时的噩梦…各自读了一会儿题目后发现A题已经有人过了,于是判定A是此次的签到题(其实它不是),戴总就去写A了. 起初我判断E应该是一个通过滚动数组优化的普通DP问题,于是开始尝试将二维压缩成一维,这里花费了一些时间.然后过去了大概三四十分钟,我们还是一题没出的状态,看了一眼榜单,似乎后面的K才是签到题,于是我和陈浩就开始读K了.陈浩读的快一些,并且很快想出了解法于是他就先去把K给过了,此时时间大概是51min.A题是一个模拟题,戴总交了一发后发现TL了,主要是每一个年份的差值运算上嵌套了一个循环,导致时间复杂度太大,后来讨论出一种初始化打表并且使用前缀和计算的方法优化时间复杂度,并不是非常顺利地过了A题.后来我对E题也有了新的想法,它是类似NOIP提高组初赛中的一种题型,根据给出的代码来推断这个代码的究竟是使用了什么算法,再根据这个算法的性质直接写出给的测试数据的答案(在得知具体是什么算法后写出答案是显然的).的确E它不是一个DP题目,而是根据DP去推出一个计算公式,于是我开始推导公式了.此时榜单上通过人数最多的是B题和E题,于是更加坚定了我是可以写出E题的信心.然后陈浩和戴总去写B题了.中间过去了大约一个小时,我们在这两个题目上并没有进展.看了一眼榜单发现I题的人数挺多的,于是陈浩和戴总去做I题了.在3h~4h这个时间段里我写出了一个E题的暴力算法,保证答案正确的情况下用来测试后续需要提交代码的正确性,并且推出E题的一个较弱的公式:$\sum{i^2} + sum(m+l-1)-sum(min(m,k)+l-1)$,交了一发发现答案错误,于是开始Debug.陈浩和戴总在I题上也有一些进展,戴总在写了几段代码后发现题目实际上是一个图论的题目,作为图论选手的她顺利地将这道题过掉了.此时是三小时过半了,我和陈浩讨论出了正确的公式是$\sum{i^2} + \sum_{i}^{k} max ({b})$也就是说对b数组中最大的k个值进行求和而不是先前的前缀和求法,后来得知这种对动态区间k个最值进行求和的方法是需要使用<strong>可持久化线段树</strong>这种数据结构的.在接下来的所有时间我们都在寻找一种方式来得到这个最值,但是没有结果,一直到比赛结束我们也才写了3题.</p>
<p>后来听说有学长在最后十分钟开始写c题并且顺利过掉的,中间还有一些思维加数学的题目,尝试一下还是有可能冲进4题的.主要是由于我对自己的DP能力太过自信,死磕E题,没有去读其他的题目才导致这次省赛只出了3题,如果在封榜后我去读一下其他题目,这次省赛的结果可能都会比现在要好…然后暴露的一些问题:1.需要经常看榜单寻找当前能做的题目,尽量去读每一道题目可能就藏了一道适合你的;2.加强数据结构的学习,此次的B和E都是依靠数据结构才能通过的题目,在高级数据结构上的不足导致出不了这两题;3.加强练习,多写题总是没错的.</p>
<p>官方难度K A C I F G E H B D L J,感觉这次的榜完全被带歪了. 2020ZJCPC铜，太感动了。感谢队友，感谢学校和学院和志愿者，感谢主办方.</p>
]]></content>
      <categories>
        <category>disorder</category>
      </categories>
  </entry>
  <entry>
    <title>读&lt;&lt;人类简史&gt;&gt;</title>
    <url>/2020/05/03/2020/abriefhistoryofmankind/</url>
    <content><![CDATA[<p><img src="/images/u=2688818784,1533190349&fm=15&gp=0.jpg"></p>
<p>一本拓宽认知的书．主要讲述的是整个人类社会的发展，涉及的不同专业内容有很多．作者的一些观点与众不同，颠覆了我对一些问题的传统看法．很多人对这本书的评价是作者的一些推论在逻辑上有不合理不严谨的地方，我觉得瑕不掩瑜，这里也不再举例．事实上很多章节单独拿出来看也是非常精彩的．物理，生物，经济，历史，哲学，宗教等各个方面都有描写．每一个领域的讨论不是很有深度（其实在神学以及宗教的那部分内容我是粗略浏览的，因为本身对这些话题不感兴趣也看不进去），但是这不是缺点，因为这本书的定位应该就是科普而不是专业书籍．我觉得给我最大的应用价值就是拓宽认知吧．</p>
<p>书中有一个观点概括来讲是’’人们越是拓宽自己对科学的认识，就发现自己越是无知，这也是了现代科学发展的原因之一．’’学习了书中的一些现代学科的基础知识，比如银行是如何处理贷款和转账的，大致说来就是一份的钱可以当做六七份来用，这也促进了经济的发展．我第一次知道原来银行背后的资金是这么操作的（原谅我的无知…）然后我觉得许多学科都是很有价值的，应该学习一些相关知识，接下来就打算学习一下基本的经济学和生物学知识．</p>
<p>过去很多的现象是用神学来理解的，就比如说将一个球抛出去为什么会是运动轨迹弧线，人们无法用科学的理论来解释，于是就把这些现象出现的原因归结为上帝让它这样子它就这样了．后来随着数学和物理的发展，牛顿用他的三条力学公式解释了这个现象．书中谈到数学能够解释自然界中的许多现象，数学对于现代科学的发展也确实功不可没．我想想也许随着科学的继续发展，未来人类的一些行为，思想情感都可以用一些数学公式来进行描述．（于是我决定接下来要猛搞数学了）</p>
<p>谈谈对于我对’’知识’’和算法的看法．计算机学科是一种纯粹是人类想象出的学科，设计语言的语法，机器的构造，数据结构和算法都是由想法的提出再到实现的．但是其他学科是不同的，例如生物和化学，研究的是自然界客观存在的一些现象，再用人类的语言抽象出来进行理解的一件事情，这些学科的符号都是为了更加简洁且优雅地描述自然界存在的一些过程．计算机则是人类’’一厢情愿’’的一个学科，所以别人想到事情我们也一定能够理解．很多的算法书总是抛出一个概念，说这个是’’ｘｘ算法’’，接着对这个算法描述进行的流程，进行复杂度分析，用数学公式证明其正确性，但是很少有提及这个算法的发明者到底是<strong>怎么想出来</strong>的，我认为想出来这个过程才是最重要的．然而有一些算法是可以追寻其源头的，例如’’遗传算法’’和’’模拟退火算法’’，两者都是随机性搜索算法，通常用于解决最优化问题．’’遗传算法’’是基于生物学的遗传和进化规律，通过变异和淘汰等操作来优化结果，’’模拟退火算法’’是基于’’退火’’这一金属热处理工艺原理来进行结果的优化．这两种算法可以说是基于其他学科知识的算法，我们也可以知道这个算法是<strong>怎么想出来</strong>的，而不是直接给出一系列的证明．所以我认为应当学习一些解释自然界客观存在现象的学科，因为说不定就能基于某一种已经存在的自然理论来推演出新的算法．</p>
<p>还有一些在方法论上的学习．大家传统的理解是随着人类社会的发展，各种基础设施的完善，人类应该是越来越幸福的．作者提出农业社会以及现代工业社会的人们生活可能不如古时候的采集者，因为在农业化和工业化后又有一系列新出现的问题，’’营养不良’’，’’环境污染’’等等．我们传统的理解只是集中在社会发展提供便利的一面上，虽然社会发展过程中是会有一些漏洞但不至于更差，作者提出的观点的确让人耳目一新．以及一些其他内容：对于’’快乐’’的分析，还有’’国家’’，’’民族’’的概念其实都是虚无是建立在想象上的等等．作者能够提出这种想法，说明他对认识世界的方法论的确与众不同（与曾经提到过的一篇文章类似，<a href="https://scheng52123.com/index.php/2020/03/29/hackersandpainters3/">不能说的话</a>），网络上很多人抨击的也是这些方面，因为违背了过去的传统认知吧，我觉得是不能够完全相信作者的观点，但是他的这种认知世界的方法还是值得通过文字去琢磨的．</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>平均阻尼法</title>
    <url>/2020/05/24/2020/averagedamp/</url>
    <content><![CDATA[<p>这是一种”将长方形变得更像正方形”的方法.</p>
<p>[latexpage]有一个矩形,面积为$S$,设其中一边长为$L_n$,那么另一边长为$\frac{S}{L_n}$.求$L_n$与$\frac{S}{L_n}$的平均值作为下一个边的长度.即</p>
<p>$L_{n+1} &#x3D; \frac{L_n + \frac{S}{L_n}} {2}$</p>
<p>[latexpage]可以发现随着迭代的次数增加,$Ln$与$\frac{S}{L_n}$越来越接近,在面积不变的条件下长方形变得更像正方形了.</p>
<p>[latexpage]S是一个待开方的数,$L_1$为第一次猜测的值,进行多次迭代后,当$L_n$与$L_{n+1}$的差足够小时,就可以认为S的开方被求出来了.</p>
<p><strong>用c语言写的平均阻尼法求开平方.</strong></p>
<p>#define minx 0.0000001</p>
<p>double average( double x, double y ) { return ( x + y ) &#x2F; 2; }</p>
<p>double damp( double x, double guess )<br>{<br>    double S &#x3D; x;<br>    double newGuess &#x3D; average( guess, S &#x2F; guess );<br>    for ( ;; )<br>    {<br>        if ( abs(newGuess-guess) &lt; minx ) break;<br>        guess &#x3D; newGuess;<br>        newGuess &#x3D; average( guess, S &#x2F; guess );<br>    }<br>    return newGuess;<br>}</p>
<p><strong>平均阻尼法处理矩形的图像表示</strong></p>
<p>绘制一个长为8,宽为2的矩形,其面积为16.初始A点坐标为(8,2).可以理解为对于待开平方数16,做出了第一次猜测为8.</p>
<p><img src="/images/1-1024x424.jpg"></p>
<p>[latexpage]进行一次平均阻尼处理,在计算一次$L_{n+1} &#x3D; \frac{L_n + \frac{S}{L_n}} {2}$后得到$L_2&#x3D;5$,求出宽为3.2.A点坐标变为(5,3.2),发现在面积不变的条件下,原来的矩形向正方形变化了.</p>
<p><img src="/images/2-1024x662.jpg"></p>
<p>[latexpage]再进行一次平均阻尼处理,求得$L_3 &#x3D; 4.1$宽接近3.9,A点坐标变为(4.1, 3.9)此时原本的矩形已经非常接近正方形了,4.1也是非常接近$\sqrt{16} &#x3D; 4$的一个值.</p>
<p><img src="/images/3.jpg"></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
  </entry>
  <entry>
    <title>背包DP</title>
    <url>/2020/07/22/2020/bagdpqus/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1381/B">1381 B. Unmerge</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1941">P1941 飞扬的小鸟</a></p>
<p>题解</p>
<p>完全背包与0-1背包结合,十分精妙的上下限控制 f[i][j] :&#x3D; 从开始到坐标i,j),最少跳几次; 注意初始化和上限m的转移; 上升过程是完全背包处理,下降过程是0-1背包;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2011</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> up[maxn], down[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn], x[maxn], y[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="keyword">int</span> p, l, h;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        down[i] = <span class="number">0</span>;</span><br><span class="line">        up[i] = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;p, &amp;l, &amp;h);</span><br><span class="line">        b[p] = <span class="number">1</span>;</span><br><span class="line">        down[p] = l;up[p] = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, INF, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="comment">// 任意整数高度出发</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = x[i] + <span class="number">1</span>; j &lt;= m + x[i]; j ++ )</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j-x[i]] + <span class="number">1</span>, dp[i<span class="number">-1</span>][j-x[i]] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = m + <span class="number">1</span>; j &lt;= m + x[i]; j ++  )</span><br><span class="line">            dp[i][m] = <span class="built_in">min</span>(dp[i][m], dp[i][j] );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - y[i]; j++ )</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][j+y[i]]);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= down[i]; j ++ )</span><br><span class="line">            dp[i][j] = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = up[i]; j &lt;= m; j ++ )</span><br><span class="line">            dp[i][j] = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[n][i]);</span><br><span class="line">    <span class="keyword">if</span> ( ans &lt; INF ) <span class="built_in">printf</span>(<span class="string">&quot;1\n%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( dp[i][j] &lt; dp[<span class="number">0</span>][<span class="number">0</span>] ) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b[i]) cnt ++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n%d\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/07/22/2020/bianrysearchqus/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1370/D">1370 D. Odd-Even Subsequence</a></p>
]]></content>
      <categories>
        <category>binarysearch</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>分块思想</title>
    <url>/2020/07/28/2020/blockqus/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2261">[CQOI2007]余数求和</a></p>
]]></content>
      <categories>
        <category>block</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title>图的建立以及使用数据结构存储</title>
    <url>/2020/02/07/2020/buildagraph/</url>
    <content><![CDATA[<h2 id="邻接表存图"><a href="#邻接表存图" class="headerlink" title="邻接表存图"></a>邻接表存图</h2><p>邻接表存图实际上是用链表来存储边的相关信息,适用于稀疏图.</p>
<p>struct edge<br>{<br>    int to, next, w;<br>} s[1000];<br>int n, num, head[1000];</p>
<p>void build( int u, int v, int w )<br>{<br>    s[++num].w &#x3D; w;<br>    s[num].next &#x3D; head[u];<br>    s[num].to &#x3D; v;<br>      head[u] &#x3D; num;<br>}</p>
<p>void work()<br>{<br>    int u, v, w;<br>    for ( int i &#x3D; 0; i &lt; n; i ++ )<br>    {<br>        scanf(“%d %d %d”, &amp;u, &amp;v, &amp;w);<br>        build( u, v, w );<br>    }<br>}</p>
<p>首先定义一个edge的结构体,以及head[]</p>
<ul>
<li>to为当前边指向的下一个结点.</li>
<li>w为当前边的权重.</li>
<li>next为在同一层的边的下一条边的编号,同一层的边也就是连接当前结点和它的子节点(们)的(那些)边.</li>
<li>head为一个表头,记录邻接表的每一”行”首个元素边的编号,或者说同一层的那些边的首个边的编号.</li>
</ul>
<p>每添加一条新的边就记录下它所指向的下一条边和这条边的权重</p>
<p>s[num].next &#x3D; head[u]; head[u] &#x3D; num;</p>
<p>这两句代码是将当前边插入同一层所在的那个链表,并且插入后的数据与输入的数据是倒序的.</p>
<h2 id="二维矩阵存图"><a href="#二维矩阵存图" class="headerlink" title="二维矩阵存图"></a>二维矩阵存图</h2><p>二维矩阵适合存稠密图,但是能够存储的结点会相对少一些,实现方法非常简单.</p>
<p>int G[100][100]</p>
<p>void work()<br>{<br>    int from, to, weight;<br>    for ( int i &#x3D; 0; i &lt; E; i ++ )<br>    {<br>        scanf(“%d %d %d”,&amp;from, &amp;to, &amp;weight);<br>        G[from][to] &#x3D; weight;<br>    }</p>
<p>}</p>
<h2 id="STL向量存图"><a href="#STL向量存图" class="headerlink" title="STL向量存图"></a>STL向量存图</h2><p>实现方法也很简单,如果想要记录权重等信息则需要建立新的结构体.</p>
<p>void work()<br>{<br>    vector<int> G[1000];<br>    int u, v;<br>    for ( int i &#x3D; 0; i &lt; E; i ++ )<br>    {<br>        scanf(“%d %d”, &amp;u, &amp;v);<br>        G[u].push_back(v);<br>    }<br>}</p>
]]></content>
      <categories>
        <category>graphtheory</category>
        <category>algorithmanddatastruct</category>
      </categories>
      <tags>
        <tag>graphtheory</tag>
      </tags>
  </entry>
  <entry>
    <title>计数DP</title>
    <url>/2020/07/22/2020/calcdpqus/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1369/D">1369 D. TediousLee</a></p>
<p><a href="https://codeforces.ml/contest/1288/problem/C">codeforces 1288 C. Two Arrays</a></p>
<p>题解 将题目要求的两个序列以及要求转化成一个序列以及要求; 有一个序列$A$满足以下要求:</p>
<ol>
<li>长度为$2 * ,$</li>
<li>非递减</li>
<li>$a_i \in [1, n]$</li>
</ol>
<p>设$f(i,j)$为长度为$i$,最后一个数字为$j$的满足上述要求的序列的数量. 状态转移:$f(i,j)&#x3D;\sum_{k&#x3D;1}^{j}dp[i-1][k]$,虽然时间复杂度较高,但是对于这个题目已经足够了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * m; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j ; k ++) </span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">                dp[i][j] %= MOD;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>考虑优化,利用扰动法,对于$f(i,j-1)$有,$f(i,j-1)&#x3D;\sum_{k&#x3D;1}^{j-1}f(i-1,k)$,那么$f(i,j)&#x3D;f(i-1, j)+f(i,j-1)$,就优化到了两层循环嵌套.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>] ) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>练习2.6 丘奇计数</title>
    <url>/2020/05/24/2020/churchcount/</url>
    <content><![CDATA[<p>(define zero<br>    (lambda (f) (lambda (x) x ) )<br>)</p>
<p>(define (add-1 n )<br>    (lambda (f) (lambda (x) ( f (( n f ) x ) ) ))<br>)</p>
<p>刚看到这个定理的时候确实难以理解,花了一些时间去理解后,确实如题目表述的,如雷灌顶.</p>
<p>平时生活和学习上总是会把01234…定义为’’数字’’,但实际上他们只是一个符号,’’数字’’这个概念本来应该是抽象的,用01234….这些符号来表示目的是使这个抽象概念更加形象,但是使用过多后会造成一种定势,使我们认为’’数字’’就是这些符号,这也就是我一时半会儿没看明白这几行代码的原因.</p>
<p><strong>练习2.6</strong>就是在重新告诉我们到底什么才是’’数字’’,数学的运算符号又是什么.</p>
<p>我们总是认为’’0’’表达的就是零,实际上许多’’东西’’也可以表达零这个概念,比如说一个没有水的空瓶子就可以表达零,在河流里的一条鱼可以表达一,等等.</p>
<p><strong>练习2.6</strong>表达的是,有一个过程,和一个’’东西’’.这个过程在这里叫做f,这个’’东西’’叫做x.如果不对x进行f操作,那么就可以表达零的概念.对一个对象n进行一次f,也就是在对象n上加一了(add-1).</p>
<p>那么one的定义就是(add-1 zero),只需要将(zero)带入(add-1 n),进行展开简化.</p>
<p>(define one<br>    (lambda (f)<br>        (lambda (x)<br>            (f x))))</p>
<p>那么two的定义就是运用两次(add-1( add-1 zero ))</p>
<p>(define two<br>    (lambda (f)<br>        (lambda (x)<br>            (f (f x)))))</p>
<p>对于加法,( plus n m ) 就是在调用n次的基础上再调用m次.</p>
<p>(define (plus first second)<br>    (lambda (f)<br>        (lambda (x)<br>            (( first f )<br>             (( second f ) x)<br>            )<br>        )<br>    )<br>)</p>
<p>我们还可以将这种定义方法再具体化一些,使它能够表达出我们日常中习惯的’’数字’’概念.实际上这种做法是对这一高级定义的一个弱化.只需要将真是存在的一个过程f和x传送给它.就可以看到我么习惯的数字概念了.比如说这里定义的一个输出过程foo,在((one foo)’1)里就是进行一次输出,在(( ( plus one two) foo ) ‘1)里就是先进行一次加法后再进行输出.</p>
<p>(define (foo x)<br>    (display “哈”))<br>(( ( plus one two) foo ) ‘1)</p>
<p>(define zero<br>    (lambda (f) (lambda (x) x ) )<br>)</p>
<p>(define (add-1 n )<br>    (lambda (f) (lambda (x) ( f (( n f ) x ) ) ))<br>)</p>
<p>(define one<br>    (lambda (f)<br>        (lambda (x)<br>            (f x))))</p>
<p>(define two<br>    (lambda (f)<br>        (lambda (x)<br>            (f (f x)))))</p>
<p>(define (plus first second)<br>    (lambda (f)<br>        (lambda (x)<br>            (( first f )<br>             (( second f ) x)<br>            )<br>        )<br>    )<br>)</p>
<p>(define (foo x)<br>    (display “哈”))<br>(( ( plus one two) foo ) ‘1)</p>
]]></content>
      <categories>
        <category>sicp</category>
        <category>book</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>sicp</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找Multiset</title>
    <url>/2020/05/22/2020/codeforce1355d/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1354/problem/D">题目链接</a></p>
<p><strong>题目大意:</strong></p>
<p>对一个多重集a[n],进行k次操作.如果k[i]&lt;0那么从a[n]中删除第k[i]个数据.如果k[i]&gt;0,那么就把k[i]放到多重集a[n]中.如果最后a[n]空了就输出0,否则输出多重集中随机的一个数据.</p>
<p><strong>算法分析:</strong></p>
<p>使用二分查找算法来解决.建立一个函数count_item(x),在多重集中搜索对于x在进行所有k[i]操作后多重集剩余的小于x的数据的数量.</p>
<p>从一个极大的右端点开始搜索,如果都能满足就向左缩小,不能满足就向右扩张,直到整个收缩到多重集中某一合适的值.</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int n, q;<br>vector<int> a, k;</p>
<p>int count_item( int x )<br>{<br>    int count &#x3D; 0;<br>    for ( auto iter : a ) if ( iter &lt;&#x3D; x ) count ++;<br>    for ( auto iter : k )<br>    {<br>        if ( iter &gt; 0 &amp;&amp; iter &lt;&#x3D; x ) count ++;<br>        if ( iter &lt; 0 &amp;&amp; abs(iter) &lt;&#x3D; count ) count –;<br>        &#x2F;&#x2F;<br>    }<br>    return count;<br>}</p>
<p>int main()<br>{</p>
<pre><code>scanf(&quot;%d %d&quot;, &amp;n, &amp;q);
a.resize(n );
k.resize(q );
for ( int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a\[i\]);
for ( int i = 0; i &lt; q; i ++ ) scanf(&quot;%d&quot;, &amp;k\[i\]);
//for ( auto y : a ) printf(&quot;%d &quot;, y);
if ( !count\_item((int) 1e9)  ) &#123; printf(&quot;0\\n&quot;); return 0; &#125;
int left = 0; int right = int(1e6) + 1;

while ( right - left &gt; 1 )
&#123;
    int mid = ( right + left ) / 2;
    if ( count\_item(mid) ) right = mid;
    else left = mid; 
&#125;
printf(&quot;%d\\n&quot;,right);

return 0;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>binarysearch</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>Colorful Bricks-codeforce 1081C</title>
    <url>/2020/06/26/2020/colorful-bricks-codeforce-1081c/</url>
    <content><![CDATA[<h1 id="Colorful-Bricks-codeforce-1081C"><a href="#Colorful-Bricks-codeforce-1081C" class="headerlink" title="Colorful Bricks-codeforce 1081C"></a>Colorful Bricks-codeforce 1081C</h1><p><a href="https://codeforces.ml/contest/1081/problem/C">Colorful Bricks</a> 给定n个点,排列成一排，m种颜色和k,k代表有k个点与其左边相邻的点的颜色是不同的。 求有多少种染色方案，答案可能很大，请对998244353取模。</p>
<p>一开始题意理解错了,以为剩下的$n - k$个点的颜色可以相同也可以不同,实际上要求是都要相同的,这样排列组合公式和动态规划方程都简单了许多.</p>
<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>对于$n$个点,第一个点必须是不属于k的那个点,因为它左边没有点了.那么就有了第一个因数$m$ 在剩下的$n-1$个点中选择$k$个,也就是第二个因数$\binom{n-1}{k}$ 这$k$个点每个点可以选择的颜色数是$m-1$,那么第三个因数就是$ (m-1) ^{k} $ 最后答案就是$m * \binom{n-1}{k} * (m-1) ^{k}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line">ll C[<span class="number">20000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">square</span><span class="params">( ll x )</span> </span>&#123; <span class="keyword">return</span> x * x % MOD; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fast_expt_and_mod</span><span class="params">( ll b, ll n, ll mod )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( n % <span class="number">2</span> == <span class="number">0</span> ) <span class="keyword">return</span> <span class="built_in">square</span>( <span class="built_in">fast_expt_and_mod</span>( b, n &gt;&gt; <span class="number">1</span>, mod ) % mod ) % mod;</span><br><span class="line">    <span class="keyword">return</span> b * <span class="built_in">fast_expt_and_mod</span>( b, n - <span class="number">1</span>, mod ) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_C</span><span class="params">( ll up, ll down )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ll i = <span class="number">1</span>; i &lt;= down; i ++  ) C[i] = C[i<span class="number">-1</span>] * i % MOD;</span><br><span class="line">    <span class="keyword">return</span> C[down] * </span><br><span class="line">           <span class="built_in">fast_expt_and_mod</span>(C[up], MOD - <span class="number">2</span>, MOD) % MOD * </span><br><span class="line">           <span class="built_in">fast_expt_and_mod</span>(C[down-up], MOD - <span class="number">2</span>, MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    ll c = <span class="built_in">get_C</span>(k, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="built_in">fast_expt_and_mod</span>(m - <span class="number">1</span>, k, MOD)  * c  % MOD ) *  m % MOD );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>属于$k$的点有$k$个, 不属于$k$的点有$n-k$个 $res[i][j]$为当属于k的点达到i,不属于$k$的点达到j时的涂色方案总数 一个新的点可以通过增加一个属于k的点或者增加一个不属于k的点到达,增加属于k的点就要乘上&amp;m-1&amp;,根据这个写出状态转移方程 $res[i][j] &#x3D; res[i-1][j] * ( m - 1 ) + res[i][j-1] $ 其中的边界是$res[0][i] &#x3D; m , i \in [1, n - k]$ 答案是$res[k][n-k]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">res[<span class="number">0</span>][<span class="number">1</span>] = m;</span><br><span class="line"><span class="keyword">for</span> ( ll i = <span class="number">1</span>; i &lt;= n - k; i ++ ) res[<span class="number">0</span>][i] = m;</span><br><span class="line"><span class="keyword">for</span> ( ll i = <span class="number">1</span>; i &lt;= k; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ll j = <span class="number">1</span>; j &lt;= n - k; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res[i][j] = (res[i<span class="number">-1</span>][j] * ( m - <span class="number">1</span> ) % MOD + res[i][j<span class="number">-1</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dp</category>
        <category>combination</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>dp</tag>
        <tag>combination</tag>
      </tags>
  </entry>
  <entry>
    <title>Count the Arrays-codeforce 1312D</title>
    <url>/2020/06/26/2020/count-the-arrays-codeforce-1312-d/</url>
    <content><![CDATA[<h1 id="Count-the-Arrays-codeforce-1312-D"><a href="#Count-the-Arrays-codeforce-1312-D" class="headerlink" title="Count the Arrays-codeforce 1312 D"></a>Count the Arrays-codeforce 1312 D</h1><p><a href="https://codeforces.com/contest/1312/problem/D">Count the Arrays</a></p>
<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>$n$个数中有两个是相同的,那其余的$n-1$个数的选择方案就是$\binom{m}{n-1}$ 在$n-1$个数里选择一个数让它重复出现,但是不能选最大的,就有了$n-1-1&#x3D;n-2$</p>
<p>对于一个长度为n的数组,让它满足$a_j &lt; a_{j + 1} &gt;a_{j+2}$,其方案数一共有$2^{n-1}$ 除了最大的数无法移动,其余的数都可以移动到最大的数的左边或者右边,在这里是$2^{n-3}$. 最终答案就是$ \binom{m}{n-1} * (n-2) * 2^{n-3}$</p>
<p>其中$x^{MOD - 2}$这个操作是求$x$关于$MOD$的逆元，因为在次数无法用除法，所以用逆元来表示，相当于$\frac{1}{x}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>  ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll a[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">square</span> <span class="params">( ll x )</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fast_expt</span><span class="params">( ll b, ll n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( n % <span class="number">2</span> == <span class="number">0</span> ) <span class="keyword">return</span> <span class="built_in">square</span>( <span class="built_in">fast_expt_and_mod</span>( b, n &gt;&gt; <span class="number">1</span> ) ) % MOD;</span><br><span class="line">    <span class="keyword">return</span> b * <span class="built_in">fast_expt_and_mod</span>( b, n - <span class="number">1</span> ) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">( ll up, ll down )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ll i = <span class="number">2</span>; i &lt;= down; i ++ ) a[i] = a[i<span class="number">-1</span>] * i % MOD;</span><br><span class="line">    <span class="keyword">return</span> a[m] * <span class="built_in">fast_expt_and_mod</span>(a[down - up], MOD - <span class="number">2</span>) % MOD * <span class="built_in">fast_expt_and_mod</span>( a[up], MOD - <span class="number">2</span> ) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">2</span> ) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">&quot;%lld\n&quot;</span>,  (<span class="built_in">fast_expt</span>(<span class="number">2</span>, n - <span class="number">3</span>) % MOD * ( n - <span class="number">2</span> )  % MOD) % MOD * <span class="built_in">C</span>( n - <span class="number">1</span>, m ) % MOD  );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>combination</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>combination</tag>
      </tags>
  </entry>
  <entry>
    <title>计算因子个数</title>
    <url>/2020/02/05/2020/countfactors/</url>
    <content><![CDATA[<p>long long int _num( long long int n)<br>{<br>    long long int count &#x3D; 2;<br>    for(long long int i &#x3D; 2; i &lt;&#x3D; sqrt(n); i++)<br>    {<br>        if( n % i &#x3D;&#x3D; 0 )<br>        {<br>            if( i &#x3D;&#x3D; sqrt(n) &amp;&amp; n &#x2F; i &#x3D;&#x3D; i ) count++;<br>            else count +&#x3D; 2;<br>        }<br>    }<br>    return count;<br>}</p>
]]></content>
      <categories>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
      </categories>
      <tags>
        <tag>maththeory</tag>
      </tags>
  </entry>
  <entry>
    <title>差分数组</title>
    <url>/2020/05/21/2020/differentialarray/</url>
    <content><![CDATA[<p>对于一个数组D,要求其前i项和,$ SUM &#x3D; \sum\limits_{i&#x3D;1}^{n} {D_i}$ 令$f[i] &#x3D; D[i] - D[i-1]      i \in [2, n]$, 当i&#x3D;1时$f[1] &#x3D; D[1] - 0 &#x3D; D[1]$ 简单性质: D[i]的值是f[i]的前缀和,即$D[i] &#x3D;  \sum\limits_{j&#x3D;1}^{i} {f_i}$ 计算D[i]的前缀和, $ SUM &#x3D; \sum\limits_{i&#x3D;1}^{n} {D_i} &#x3D; \sum\limits_{i &#x3D; 1} ^{n} \sum\limits_{j &#x3D; 1}^{i}{f_j} &#x3D; ( n - i + 1 ) * {f_i}$ 这种结构可以快速处理一段区域数据的频繁的加减操作,只需要$f[L] +&#x3D; item, f[R+1] -&#x3D; item $就可以了.其中$f[R + 1] &#x3D; D[R+1] - D[R]$ $ f[R + 1] - item &#x3D; D[R+1] - (D[R] + item) $,对区间的两个端点进行操作,就不必对一段区域进行操作了. 相关例题: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1556">HDU1556</a> 差分数组的模板题. $arr[i] &#x3D; arr[i-1] + f[i]; 是对f[i] &#x3D; arr[i] - arr[i-1]$的一个变形</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t, a, b;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; arr, f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t) &amp;&amp; t )</span><br><span class="line">    &#123;</span><br><span class="line">        arr.<span class="built_in">clear</span>();f.<span class="built_in">clear</span>();</span><br><span class="line">        arr.<span class="built_in">resize</span>(t + <span class="number">1</span>);</span><br><span class="line">        f.<span class="built_in">resize</span>(t + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//f[1] = arr[1];</span></span><br><span class="line">        <span class="keyword">int</span> tmp = t;</span><br><span class="line">        <span class="keyword">while</span> ( tmp -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            f[a] ++; f[b+<span class="number">1</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i ++  ) </span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = arr[i<span class="number">-1</span>] + f[i];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">            <span class="keyword">if</span> ( i != t ) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P1083">luogu_P1083</a></p>
<p>二分查找+差分数组.用二分查找来寻找m中不能使条件满足的第一个请求. $f[i]$表示$arr[i]$的差分数组,对租借天数的$left$和$right$进行操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[arr[i].left] += arr[i].weight;</span><br><span class="line">f[arr[i].right+<span class="number">1</span>] -= arr[i].weight;</span><br></pre></td></tr></table></figure>

<p>根据性质1, 如果$f[i]$的前缀和超过了那一天的教师数量$a[i]$就说明这一次的请求是需要修改的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, weight;</span><br><span class="line">&#125;  arr[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> f[<span class="number">1000010</span>], n, m, a[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">( <span class="keyword">int</span> day )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= day; i ++ )</span><br><span class="line">    &#123;   </span><br><span class="line">        f[arr[i].left] += arr[i].weight;</span><br><span class="line">        f[arr[i].right+<span class="number">1</span>] -= arr[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += f[i];</span><br><span class="line">        <span class="keyword">if</span> ( sum &gt; a[i] ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;arr[i].weight, &amp;arr[i].left, &amp;arr[i].right);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">check</span>(m) ) &#123; <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = m;</span><br><span class="line">    <span class="keyword">while</span> ( right &gt; left )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ( left + right ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">check</span>(mid) ) left = mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; left &lt;&lt; &#x27; &#x27;&lt;&lt;right &lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1\n%d\n&quot;</span>,right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.com/contest/1355/problem/C">codeforce1355C</a></p>
<p>$x_i \in [A, B]$ $y_i \in [B, C]$ $z_i \in [C, D]$ 只要满足$x_i + y_i &gt; z_i$, 观察可得,需要求满足$[x_i + B, x_i + C]&gt;[C, D]$的那些组合的个数. 设置一个差分数组$a[i], a[i]$记录长度为i的边(或者边的和)的个数. 设置一个maxn, 为题目所给的ABCD相加不会超过的一个值 先遍历一遍区间$x \in [A, B]$求出$[x_i + B, x_i + C]$也就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = a; i &lt;= b; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        arr[b + i] ++;</span><br><span class="line">        arr[c + i + <span class="number">1</span>] --;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再根据性质1就能够求出两边和为i的数量了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i ++  ) arr[i] += arr[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>

<p>再进行一次累加,求出前缀和.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = c; i &lt;= d; i ++ ) sum += ( arr[maxn] - arr[i] );</span><br></pre></td></tr></table></figure>

<p>$arr[maxn] - arr[i]$表示比$z_i$大的两边和的总数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000080</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> arr[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = a; i &lt;= b; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        arr[b + i] ++;</span><br><span class="line">        arr[c + i + <span class="number">1</span>] --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i ++  ) arr[i] += arr[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//求两边和为i的项目的个数</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i ++  ) arr[i] += arr[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = c; i &lt;= d; i ++ ) sum += ( arr[maxn] - arr[i] );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>differentialarray</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>differentialarray</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/07/31/2020/fenwickqus/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6447">YJJ’s Salesman</a> 树状数组+离散化+DP</p>
]]></content>
      <categories>
        <category>treearray</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>G. Gliding 2020浙江省省赛动态规划</title>
    <url>/2020/10/21/2020/g-gliding-2020zjcpcdp/</url>
    <content><![CDATA[<p>在省赛的时候没有开这题,结束后发现这居然是个线性DP,写了写一发过了…遗憾遗憾.<a href="https://codeforces.com/gym/102770/problem/G">G. Gliding</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>林克在初始位置$(s_x,s_y,0)$需要到达终点位置$(t_x,t_y,0)$.他只能通过飞行到达目的地,并且有三个参数$v_f$直接下落的速度,$v_p$打开滑翔伞后的下落速度,$v_h$在水平移动时的速度.注意在水平移动时,垂直方向的下落速度为$v_p$.在一些特定的坐标有风,提供一个上升速度$v_i$,根据$v_i - v_p$的大小来决定在这个特定位置$i$上他是上升还是下降还是不变.林克会选择一个特殊的点$(s_x,s_y,0)$拥有大于$v_p$的$v_0$作为起点,在这个点他可以上升到任意高度.求林克从初始位置到达终点位置所用的最短时间.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对比两种飞行方式:</p>
<ol>
<li><p>在一个点先上升到特定高度,这个高度刚好满足从当前点到下一个点的距离除以下落时间.那么总时间就是上升到特定高度的时间$s_1$, 加上水平方向移动的时间$s_2$.</p>
</li>
<li><p>在一个点上升到一个高度,这个高度会满足后续的几个点($2\leq$)的移动,那么总时间就是上升到这个高度的时间$s_1$机上后续几个点移动的时间$s_2$,其中$s_2$又是分段进行计算的.</p>
</li>
</ol>
<p>根据三角形法则可以知道第一种方案是优于第二种方案的.于是就可以开始考虑状态转移方程了.</p>
<p>首先建立数组$a_0 \rightarrow a_{n+1}$,其中$a_0$就是初始点$(s_x,s_y,v_0)$,$a_{n+1}$是终点$(t_x,t_y,0)$并将$a_1$到$a_n$的点按照上升速度进行从小到大的排序.</p>
<p>对$a_1$到$a_{n+1}$中的每一个点进行初始化计算,也就是计算$a_0$到$a_i$的时间,按照第一种飞行方式的规则计算$s_1+s_2$.</p>
<p>两层嵌套计算从初始点到终点的最短用时,两段时间的计算方式如下:</p>
<p><code>double s1 = sqrt(pow(a[i].x - a[j].x, 2) + pow(a[i].y - a[j].y, 2)) / vh;</code></p>
<p><code>double s2 = s1 * vp * 1.0 / (a[j].v - vp);</code></p>
<p>注意判断$v_p$与$v_i$的关系有:</p>
<ul>
<li><p>$dp_i &#x3D; min(dp_i, dp_j + s_1 + s_2)$</p>
</li>
<li><p>$dp_i &#x3D; min(dp_i, \infty)$</p>
</li>
</ul>
<h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sx, sy, tx, ty;</span><br><span class="line"><span class="keyword">int</span> vf, vp, vh;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">4010</span>], ans[<span class="number">4010</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, v;</span><br><span class="line">&#125; a[<span class="number">4010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;sx, &amp;sy, &amp;tx, &amp;ty);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;vf, &amp;vp, &amp;vh);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].v);</span><br><span class="line">        a[n+<span class="number">1</span>].x = tx; a[n+<span class="number">1</span>].y = ty; a[n+<span class="number">1</span>].v = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// a[0].x = sx; a[0].y = ty; a[0].v = 0;</span></span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="built_in">memset</span>(dp, INF, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> s1 = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[i].x - a[<span class="number">0</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[i].y - a[<span class="number">0</span>].y, <span class="number">2</span>)) / vh;</span><br><span class="line">            <span class="keyword">double</span> s2 = s1 * vp * <span class="number">1.0</span> / (a[<span class="number">0</span>].v - vp);</span><br><span class="line">            dp[i] = s1 + s2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n + <span class="number">1</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[j].v &gt; vp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">double</span> s1 = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[i].x - a[j].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[i].y - a[j].y, <span class="number">2</span>)) / vh;</span><br><span class="line">                    <span class="keyword">double</span> s2 = s1 * vp * <span class="number">1.0</span> / (a[j].v - vp);</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + s1 + s2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1.0</span> * INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n&quot;</span>, dp[n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>欧几里得算法</title>
    <url>/2020/03/18/2020/gcd/</url>
    <content><![CDATA[<p>这篇是&lt;<What Is Mathematics>&gt;，紫书以及&lt;&lt;算法导论&gt;&gt;中欧几里得以及其扩展内容的笔记．</p>
<h2 id="一些基础的数论概念"><a href="#一些基础的数论概念" class="headerlink" title="一些基础的数论概念"></a>一些基础的数论概念</h2><h3 id="素数与合数"><a href="#素数与合数" class="headerlink" title="素数与合数"></a>素数与合数</h3><p>首先要有<strong>素数</strong>和<strong>合数</strong>的概念．</p>
<p>如果一个整数a &gt; 1且只能被平凡约束1和它自身整除，则这个数是<strong>素数</strong>．</p>
<p>如果一个整数a&gt;1且不是素数，则称为<strong>合数</strong>．要注意的是<strong>1既不是素数也不是合数</strong>.</p>
<h3 id="公约数与最大公约数"><a href="#公约数与最大公约数" class="headerlink" title="公约数与最大公约数"></a>公约数与最大公约数</h3><p>如果d是a的约数并且d也是b的约束，则d是a与b的<strong>公约数</strong>．</p>
<p>在两个不同时为0的整数a与b的公约数中最大的成为其<strong>最大公约数</strong>．</p>
<p>欧几里得算法即gcd算法，就是用来求两个不同时为0的整数的最大公约数的．</p>
<p>下列性质是gcd函数的基本性质：</p>
<ol>
<li>gcd( a, b ) &#x3D; gcd( b, a )</li>
<li>gcd( a, b ) &#x3D; gcd( -a, b )</li>
<li>gcd( a, b ) &#x3D; gcd( abs(a), abs(b) )</li>
<li>gcd( a, 0 ) &#x3D; abs( a )</li>
<li>gcd( a, k * a ) &#x3D; abs( a )</li>
</ol>
<h3 id="部分相关定理"><a href="#部分相关定理" class="headerlink" title="部分相关定理"></a>部分相关定理</h3><p>１．如果任意整数a和b不都为0，则gcd( a, b )是a与b的线性组合集{ a * x + b * y : x, y ∈ Ｚ }中最小的元素．</p>
<p>２．类似于分配律的一个定理，gcd( a * n, b * n ) &#x3D; n * gcd( a, b )．其中a和b可以是所有整数，n为任意非负整数．</p>
<p>３．对于两个整数a与b只有公约数1，即gcd( a, b ) &#x3D; 1，则a与b成为<strong>互质数</strong>．</p>
<p>４．对任意整数a, b和p，如果gcd( a, p ) &#x3D; 1 且 gcd( b, p ) &#x3D; 1，则gcd( a * b, p ) &#x3D; 1．</p>
<p>５．<strong>唯一因子分解定理</strong>，合数a仅能以一种方式写成如下乘积形式：</p>
<p>[latexpage]</p>
<p>$a$ &#x3D; $p_1 ^ e_1 * p_2 ^ e_2 *…*p_r ^ e_r $</p>
<p>[latexpage]</p>
<p>其中$p_i$为素数，$ p_1 &lt; p_2 &lt; … &lt;p_r $，且 $e_i$为正整数．</p>
<p>这条定理还是很重要的．</p>
<h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p>原则上讲，可以根据a和b的素因子分解求出正整数a和b的最大公约数gcd( a, b )以及最小公倍数lcm( a, b )，如果有</p>
<p>[latexpage]</p>
<p>\[$a$ &#x3D; $p_1 ^ e_1 * p_2 ^ e_2 *…*p_r ^ e_r $\]</p>
<p>\[$b$ &#x3D; $p_1 ^ f_1 * p_2 ^ f_2 *…*p_r ^ f_r $\]</p>
<p>那么　\[gcd( a, b ) &#x3D;p_1 ^ min(f_1, e_1 ) * p_2 ^ min( f_2, e_2 ) * … *p_r ^ min( f_r, e_r) \]</p>
<p>              \[lcm( a, b ) &#x3D;p_1 ^ max(f_1, e_1 ) * p_2 ^ max( f_2, e_2 ) * … *p_r ^ max( f_r, e_r) \]</p>
<p>并且由此不难得到gcd( a, b ) * lcm( a, b ) &#x3D; a * b</p>
<p>( LaTeX不会用公式都好难打啊 )</p>
<p><strong>GCD递归定理</strong>，对任意非负整数a和任意整数b，</p>
<p>gcd( a, b ) &#x3D; gcd( b, a mod b ).</p>
<p><strong>欧几里得算法代码</strong></p>
<p>int gcd(int a, int b){ return a &#x3D;&#x3D; 0 ? b : gcd(b % a, a); } </p>
<p>确实，可以短到一行．这个代码很重要，是那种写时不用想的代码，要记住的．</p>
<h3 id="欧几里得算法的扩展形式"><a href="#欧几里得算法的扩展形式" class="headerlink" title="欧几里得算法的扩展形式"></a>欧几里得算法的扩展形式</h3><p>[latexpage]</p>
<p>扩展欧几里得算法可以用来解决类似与<strong>直线上的点</strong>的问题．求直线a * x + b * y + c &#x3D; 0 上有多少个整点( x, y )满足$x$ ∈ $[ x_1, x_2 ]$, $y$ ∈ $[ y_1, y_2 ]$.</p>
<p>推广欧几里得算法用于计算出满足下列条件的整系数x和y:</p>
<p>d &#x3D; gcd( a, b ) &#x3D; a * x + b * y</p>
<p>注意，x与y可能为0或者负数．我们将发现这些系数对计算模<strong>乘法逆元</strong>是非常有用的．</p>
<p>例如gcd( 6, 15 ) &#x3D; 3， 6 * 3 - 15 * 1 &#x3D; 3，其中x &#x3D; 3, y &#x3D; -1．这个方程还有其他解，如x &#x3D; -2, y &#x3D; 1．</p>
<p><strong>扩展欧几里得算法代码</strong></p>
<p>void ex_gcd( int a, int b, int &amp;d, int &amp;x, int &amp;y )<br>{<br>    if ( !b ) { d &#x3D; a; x &#x3D; 1; y &#x3D; 0; }<br>    else { ex_gcd( b, a % b, d, y, x ); y -&#x3D; x * ( a &#x2F; b ); }<br>}</p>
<p>[latexpage]</p>
<p>对于方程a * x + b * y &#x3D; gcd( a, b ) 有一组特解( $x_0, y_0$ )， 假设另一组解为( $x_1, y_1$ )，则</p>
<p>$a * x_1 + b * y_1 &#x3D; a * x_2 + b * y_2 &#x3D; gcd( a, b )$</p>
<p>$a * ( x_1 - x_2 ) &#x3D; b * ( y_2 - y_1 )$</p>
<p>假设gcd( a, b ) &#x3D; g，方程两边同时除以g．</p>
<p>$a’ * ( x_1 - x_2 ) &#x3D; b’ * ( y_2 - y_1 )$</p>
<p>其中a’ &#x3D; a &#x2F; g，b’ &#x3D; b &#x2F; 并且a’与b’互素．</p>
<p>因此不难得出$x_1 - x_2$一定是b’的整数倍( 笔写一下就好了 )，设它为Kb’，计算得</p>
<p>$y_2 - y_1 &#x3D; K * a $</p>
<p>那么就有任意整数解</p>
<p>$( x_0 + k * b’, y_0 - k * a’ )$</p>
<p>a’ &#x3D; a &#x2F; gcd( a, b )　　　</p>
<p>b’ &#x3D; b &#x2F; gcd( a, b )　　</p>
<p>　　　k是任意整数</p>
<p>有了这个结论，移项得a * x + b * y &#x3D; -c，然后求出一组解即可．</p>
<p>例如 6 * x + 15 * y &#x3D; 9，求得一组特解( -2, 1 )．两边同时乘以3得到６ * ( -6 ) + 15 * 3 &#x3D; 9,</p>
<p>即x &#x3D; -6,y &#x3D; 3时6 * x + 15 * y &#x3D; 9</p>
<p>又有 6 * x + 15 &#x3D; ８，两边同除以3得到2 * x + 5 &#x3D; 8 &#x2F; 3．左边是整数，右边不是整数，显然无解．综合起来有下面结论：</p>
<p>设a, b, c为任意整数，g &#x3D; gcd( a, b )，方程a * x + b * y &#x3D; g的一组解是$( x_0, y_0 )$，则当c是g的倍数时a * x + b * y &#x3D; c的一组解是$( x_0 * c &#x2F; g, y_0 * c &#x2F; g )$，当c不是g的倍数时无整数解．</p>
]]></content>
      <categories>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
      </categories>
      <tags>
        <tag>maththeory</tag>
        <tag>exgcd</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>不能说的话</title>
    <url>/2020/03/28/2020/hackersandpainters3/</url>
    <content><![CDATA[<p>&lt;&lt;不能说的话&gt;&gt;是&lt;&lt;黑客与画家&gt;&gt;中的第三章，今天翻看了一遍觉得非常有意思，并且探讨的是一些我未思考过的问题，于是决定记录其中的一些文字下来．但这里讨论的东西也只能作为一种看待问题的新方法，因为我认为作者的一些其他文章很具有主观色彩和’’民族烙印’’．</p>
<h2 id="为什么这么做"><a href="#为什么这么做" class="headerlink" title="为什么这么做"></a>为什么这么做</h2><p>事实上不论是哪一个时代，都会存在’’不能说的话’’，自以为无害的言论会惹来大麻烦．就例如17世纪地球绕着太阳转的理论，在今天看来再正常不过了，但在当时就大难临头了．有时候人们说出了自己觉得正确的观点，事实上却惹来了麻烦．</p>
<p>我觉得首先要记录的是作者想要找出’’不能说的话’’的原因，其一是他对被禁止的东西有强烈的好奇心；其次是他认为明明正确的事情被认为是错误的就很荒谬；再次是优秀的作品往往来自被他人忽略的想法，最被忽略的想法就是那些被禁止的思想观点．</p>
<p>在有一些人看来拥有自己的观点是对于另一个群体不利的，别人需要你去相信他的观点，进而使你成为随大流的人．并且随大流是不利的，我们将变得无法清晰思考，自己就是潮水的一部分就更难看清潮流的方向．</p>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>作者就’’不能说的话’’也举了一些例子，的确是我先前没有思考过的问题，并且在其说法上也有道理．例如：科学家比其他领域的学者更加聪明，具体地来说，多数物理学家有能力成为文学博士但是文学博士却难成为物理学家．这违反了大家不约而同的一个公理－－各种领域的研究所需要的智力水平是相同的．如果默认这条公理，会减少许多不必要的冲突，承认它会比不承认它少许多麻烦．并且所有学科的难易程度居然一样这件事情也是令人质疑的；对于智力越高的人，传统观念的束缚对他们的束缚力是很小的，他们往往也不穿流行的衣服．美国汽车公司总是在生产烂车，消费者购买一些美国生产的汽车更多是出于品牌而非车的质量．</p>
<h2 id="如何找出它们"><a href="#如何找出它们" class="headerlink" title="如何找出它们"></a>如何找出它们</h2><p>对于如何找出’’不能说的话’’这个问题，作者举例了五种方法．</p>
<p><strong>真话</strong></p>
<p>那些不能说出口的话往往具备两个条件，第一个条件是，这些话不能说出口；第二个条件是，它们是正确的，或者看起来很可能正确．当我们发现某个言论很可以时，试想，这些话即使听上去大逆不道，但是它们有没有可能是真的？最重要的一点就是：判断言论的真伪．</p>
<p><strong>异端邪说</strong></p>
<p>除了真话以外，’’不能说的话’’还有另一种可能．有些想法纯粹因为非常特别，而且不能说出口．这些话语往往被认为是’’异端邪说’’，并且对’’异端邪说’’贴上不好的标签．事实上许多看似叛逆的’’异端邪说’’已经潜伏在思维深处，如果暂时关闭自我审查意识，它们就会第一个浮现出来．作者提供找到它们的方法就是关注这些’’异端邪说’’的标签．</p>
<p>就比如有一个标签叫做’’性别歧视’’，试问自己那些想法是属于’’性别歧视’’的，头脑中会出现一系列想法，再它们逐个询问，这些想法真的属于’’性别歧视’’吗？这是看似很主观的行为，但实际山这些最先出现的想法往往是最困扰自己，很可能是正确的想法，我们已经有注意过它们了，但是还没有认真思考过．</p>
<p><strong>时空差异</strong></p>
<p>曾经我认为当代人比古人更聪明，更优雅，但经过后来的学习，我发现我的这个观点是错的．我阅读过一些先秦诸子的文学和思想作品，我发现古人思考问题的深度以及想象力之丰富等和今人相比不会有差距，甚至更高明．那么无论古人有什么想法，那都是和我们一样的正常人产生的想法．</p>
<p>除此之外，在不同文明之间的人是没有巨大差异的(这里我认为在诸如智力，体格方面其实还是有差异的，这似乎也是’’不能说的话’’，但对于现在研究的问题影响不大)，不同的是文化价值观念．文化价值观念的不同导致了东西方文化的巨大差异．如果一个观点ｘ在众多文明价值观念里是正确的，唯独在一个文明价值观念里是错误的，那么我就有理由相信观点ｘ是正确的．</p>
<p>那么只要我们将当前的这个想法放到不同时代的古人观念和当代观念里进行比较，就会有一些想法是在不同的古代时期是不允许出现的，而在当今却被允许出现，我们有无法断言自己比古人更加聪明，所以这个想法的正确性就不是很绝对了．再将这个想法放到不同文化价值观念的文明里，如果多数文化价值观念里这个想法是正确的，那么这个想法的正确性就蛮高的．</p>
<p><strong>道貌岸然</strong></p>
<p>作者提供的第四个方法是：寻找一些一本正经的卫道者，看看他们到底在捍卫着什么．这个方法过于抽象，以致我没理解他到底是什么意思…</p>
<p>作者提到，孩子的大脑就是我们所有’’不能说的话’’的一面反射镜．成年人会刻意保证孩子不受外界’’不良’’思想的影响，对孩子灌输的想法都是那些他们希望孩子知道的想法，让孩子变成他们想象中的样子．那么最终涉世未深的孩子眼中的社会是虚假不真实的．只要将一个社会经历丰富的人的想法与被刻意保护孩子的想法一减，就可以得出’’不能说的话’’了．</p>
<p><strong>机制</strong></p>
<p>第五种方法就是去观察禁忌是怎样产生的．某种道德观念又是如何产生的，并且又是怎样被人所认同的．如果能够理解它们的产生机制，可能就可以应用于我们的时代．</p>
<p>一个’’生产’’禁忌的背后团队是既不特别强大有不是特别弱小的．实力过强则不需要，实力太弱就无法推行．那些在斗争中略占上风的一方即有实力推行禁忌，又需要禁忌来保护自己的利益．并且在大多数斗争中，无论实际上斗争的是什么，都会以思想斗争表现出来，思想斗争更加容易取得支持者．并且在斗争失败的那一方的思想观点也会受到牵连．</p>
<p>那些接受流行思想的人又是如何产生的？第一批人具有很强的抱负和精英意识，想要把自己和普通人区分开来．后来者则是出于恐惧，并不是因为自己与众不同，而是因为害怕自己变得与众不同．我们要去思考的是想要挣脱当前流行趋势的人会支持什么思想观点，随大流的人对什么思想观点抱有恐惧心．</p>
<h2 id="发现他们之后"><a href="#发现他们之后" class="headerlink" title="发现他们之后"></a>发现他们之后</h2><p>自由思考比畅所欲言更加重要，当发现’’不能说的话’’以后的一个做法就是不与他人争论，如果一定要把话说清楚那么结果就是从此你再也无法理性思考了．在思想与言论之间划一条界限，心里无所不想，但不一定说出来．</p>
<p>如果一定要表达自己的想法，那么可以通过’’隐喻’’，就比如小时候读的寓言故事和中学时期的课本里有许多讽刺’’旧时代’’政府无能的文学作品，他们大多使用的方法就是隐喻．还有一点就是保持幽默．</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>hackersandpainters</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello world!</title>
    <url>/2020/02/02/2020/hello-world/</url>
    <content><![CDATA[<p>本来打算用树莓派做博客的,但是因为后续操作过于繁琐以及安全问题(说到底还是我菜)还是放弃了.然后有折腾了好久才把最后这个博客搭建起来.反正我有我的第一个博客了!</p>
]]></content>
  </entry>
  <entry>
    <title>图论之LCA</title>
    <url>/2020/07/23/2020/lcaqus/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6540">2019湖南邀请赛 I Neko and tree</a> 由于数据太水了,用 LCA 写一个假算法也可以过(正解是树形DP)</p>
]]></content>
      <categories>
        <category>graphtheory</category>
        <category>algorithmanddatastruct</category>
      </categories>
  </entry>
  <entry>
    <title>线性DP</title>
    <url>/2020/10/09/2020/linedp/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1389/B">codeforce 1389 B. Array Walk</a></p>
<p>题解</p>
<p><code>dp[i][j]</code> 为在$i$的位置,已经向左移动了$j$次的最大和</p>
<p>对于直接向右行走有: <code>dp[i][j]=dp[i-1][j]+a[i]</code> 并且在<code>i-1+j*2==k</code>时需要取$ans$的最大值,因为此时是刚好步数达到要求时的状态,其中$2*j$是因为要在$i$与$i-1$之间反复行走,所以前面的项是$i-1$.</p>
<p>对于向左移动的行走有: <code>dp[i-1][j+1]=max(dp[i-1][j+1],dp[i][j]+a[i-1])</code> 这个转移是显然的,即在$i$处向左走到$i-1$的位置,并且向左操作数加了一.注意这个转移是只能在$j+1&lt;&#x3D;z$时才能发生的. 当这种转移结束后,应当再比较一次最大值的变化.即<code>(i-1)-1+(j+1)*2==k</code>,因为又向左了一步,那么就是在$i-1-1$与$i-1$之间反复行走了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, a[<span class="number">100010</span>], k, z, sum[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100010</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;k, &amp;z);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        z = <span class="built_in">min</span>(z, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= z; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + a[i];</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> + <span class="number">2</span> * j == k) ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= z) dp[i<span class="number">-1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>], dp[i][j] + a[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span> ((i - <span class="number">1</span>) - <span class="number">1</span> + <span class="number">2</span> * (j+<span class="number">1</span>) == k) ans = <span class="built_in">max</span>(ans, dp[i<span class="number">-1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dn&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.ml/problemset/problem/1272/D">codeforce 1272 D. Remove One Element</a></p>
<p>题解</p>
<p>两次LIS,$f(i)$为以$i$结尾的最长上升子序列大小,$g(i)$为以$i$开头的最长上升子序列大小. 使用经典的LIS做法进行两种状态转移.枚举每一个$i$,$i$为被删除的数据,并且有$i in [2,n-1]$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[<span class="number">200010</span>], f[<span class="number">200010</span>], g[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    g[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>] &lt; a[i]) f[i] = f[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[i+<span class="number">1</span>]) g[i] = g[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i ++ ) </span><br><span class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>] &lt; a[i+<span class="number">1</span>]) ans = <span class="built_in">max</span>(ans, f[i<span class="number">-1</span>] + g[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lldn&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.ml/problemset/problem/1307/C">codeforces 1307</a></p>
<p>题解</p>
<p>只考虑一位和两位的情况,记$f(i,j)$为以$i$为第二位,$j$为第一位的当前长度为2的子串数量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">string ss;</span><br><span class="line">ll dp[<span class="number">100010</span>][<span class="number">30</span>], cnt[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    ll ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = ss[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">27</span>; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[t][j] = dp[t][j] + cnt[j];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[t] ++;</span><br><span class="line">        ans = <span class="built_in">max</span>(cnt[t], ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>浙江省省赛G题 <a href="https://codeforces.com/gym/102770/problem/G">G. Gliding</a></p>
<p>题解</p>
<p><a href="https://scheng52123.com/index.php/2020/10/21/g-gliding-2020zjcpcdp/">题解</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2577">[ZJOI2004] 午餐</a></p>
<p>题解</p>
<p>考虑两种排序方式： 其中$b_1&gt;b_2$。</p>
<p>第一种:</p>
<ol>
<li>&lt;$a_1$,$b_1$&gt;</li>
<li>&lt;$a_2$,$b_2$&gt;</li>
</ol>
<p>排队加吃饭的总时间是$t&#x3D;a_1+a_2+b_2$，因为第一个人排完队就直接去吃饭了，并且吃饭时间是被第二个人的排队和吃饭时间覆盖掉的。</p>
<p>第二种：</p>
<ol>
<li>&lt;$a_2$,$b_2$&gt;</li>
<li>&lt;$a_1$,$b_1$&gt;</li>
</ol>
<p>总时间$t&#x3D;a_1+a_2+b_1$,原理同上。由于$b_1&gt;b_2$，那么最优的排序方案应该是将吃饭时间大的人排在前面。</p>
<p>在排序完毕后做一个前缀和$sum$,表示前$i$个人排队用的时间<code>sum[i] = sum[i-1] + s[i].a</code>。</p>
<p>$f_{i,j}$表示前$i$个人在1号打饭窗口，打饭总时间为$j$，最早吃完饭的时间。</p>
<p>对于第一个窗口的状态转移如下：</p>
<p>$f_{i,j} &#x3D; min(f_{i,j},max(f{i-1,j-s_{i,a}},j+s_{i,b}))$</p>
<p>由于要新加入一个人，所以要比较当前加入的人和上一个人的吃完饭的时间，取最大。$max$中的状态转移可以类比背包动态规划的转移方式。</p>
<p>在第二个窗口的状态转移如下：</p>
<p>$f{i,j} &#x3D; min(f_{i,j}, max(f_{i-1,j}, sum_{i} - j + s_{i,b}))$</p>
<p>$sum_{i}-j$为第二个窗口的总排队时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; s[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">300</span>][<span class="number">40010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(stu x, stu y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.b &gt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;s[i].a, &amp;s[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + s[i].a;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum[i]; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i].a &lt;= j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], <span class="built_in">max</span>(f[i<span class="number">-1</span>][j-s[i].a], j + s[i].b));</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], <span class="built_in">max</span>(sum[i] - j + s[i].b, f[i<span class="number">-1</span>][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum[n]; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, f[n][i]);</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;, f[n][i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P5788</title>
    <url>/2020/02/03/2020/luogup5788/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5788">https://www.luogu.com.cn/problem/P5788</a></p>
<p>&#x2F;&#x2F;luogu P5788<br>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>struct node<br>{<br>    int val, pos;<br>};</p>
<p>stack <node> s;<br>int n, ans[3000010];</p>
<p>int main()<br>{<br>    scanf(“%d”,&amp;n);<br>    node num, item2;<br>    for ( int i &#x3D; 1; i &lt;&#x3D; n; i ++ )<br>    {<br>        scanf(“%d”,&amp;num.val);<br>        num.pos &#x3D; i;<br>        if ( s.empty() )<br>        {<br>            s.push(num);<br>        }<br>        else<br>        {</p>
<pre><code>        item2 = s.top();
        while ( item2.val &lt; num.val )
        &#123;
            //printf(&quot;item = %d\\n&quot;,item);
            ans\[item2.pos\] = num.pos;
            s.pop();
            if ( s.empty() ) break;
            item2 = s.top();
        &#125;
        s.push(num);
    &#125; 
&#125;
item2 = s.top();
ans\[item2.pos\] = 0;
for ( int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;,ans\[i\]);
return 0;
</code></pre>
<p>}</p>
<p>github:<a href="https://github.com/ShaoChenHeng/codeOfACM/blob/cf6cc30444d8088fc80aac27af18023f0245440a/linearStruct/monotonousStack/modelCode.cpp">https://github.com/ShaoChenHeng/codeOfACM/blob/cf6cc30444d8088fc80aac27af18023f0245440a/linearStruct/monotonousStack/modelCode.cpp</a></p>
]]></content>
      <categories>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>莫比乌斯反演笔记</title>
    <url>/2020/08/01/2020/mobiusnote/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="正因子求和"><a href="#正因子求和" class="headerlink" title="正因子求和"></a>正因子求和</h3><p>$\sum_{d|n}$表示对n的所有正因子求和,例如$\sum_{d|8}&#x3D;1^2+2+2+4^2+8^2 $。</p>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>对于所有的正整数中选取$x,y$,使得$x,y$互素,并且满足$f(x)f(y)&#x3D;f(xy)$的函数$f$,就是积性函数。</p>
<p>如果当$x,y$不互素时,仍然满足上述条件,那么$f$是完全积性函数。</p>
<p>一些积性函数可以参见<a href="https://oi-wiki.org/math/mobius/#_7">例子</a></p>
<h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>见<a href="https://oi-wiki.org/math/mobius/#_11">莫比乌斯函数</a></p>
<p>筛法实现模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10010</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !flag[i] ) prime[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= <span class="number">10010</span>; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( i % prime[j] == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10010</span>; i ++ )</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>常用的两种形式 如果$F(n)&#x3D;\sum_{d|n}f(d)$,那么$f(n)&#x3D;\sum_{d|n}\mu(d)F(\frac{n}{d})$ 如果$F(n)&#x3D;\sum_{n|d}f(d)$,那么$f(n)&#x3D;\sum_{n|d}\mu(\frac{d}{n})F(d)$</p>
<p>具体数学中定义的形式 $ d \backslash n $表示$d$能被$n$整除 如果 $F(n)&#x3D;\sum_{d\backslash n} f(d)$,那么$f(n)&#x3D;\sum_{d\backslash n} \mu(d)F(\frac{n}{d})&#x3D;\sum_{d\backslash n} \mu(\frac{n}{d})F(d)$</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ul>
<li>构造$f$函数,通常是设满足题目条件的个数为$f(d)$</li>
<li>构造$F$函数,通常是即$F(n)&#x3D;\sum_{d|n}f(d)$</li>
<li>得到反演公式$f(n)&#x3D;\sum_{d|n}\mu(d)F(\frac{n}{d})$或$f(n)&#x3D;\sum_{n|d}\mu(\frac{d}{n})F(d)$</li>
<li>对$F(d)$进行计算,即满足题目条件的那些d的整数倍,那么$F(d)$就可以变成另外一种形式.</li>
<li>(可选)分块处理,对$f(n)$求和计算出答案.</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>以<a href="http://poj.org/problem?id=3904">POJ Sky Code</a>为例 题目给出n和n个正整数，问能找出多少个不同的四元组(a,b,c,d)使得该四元组的最大公因数为1.</p>
<p>设$f(x)$是满足$gcd(a,b,c,d)&#x3D;d$的个数 $F(n)$为有多少个四元组满足$gcd(a,b,c,d)&#x3D;d$的整数倍,那么有$F(n)&#x3D;\sum_{d|n}f(d)$,通过莫比乌斯反演得到$f(n)&#x3D;\sum_{n|d}\mu(\frac{d}{n})F(d)$,根据题意求$f(1)$,那么也就是求$f(1)&#x3D;\sum_{1|d}\mu(\frac{d}{1})F(d)&#x3D;\sum_{d&#x3D;1}^{\infty}\mu(d)F(d)$。</p>
<p>考虑$F(d)$为有多少个四元组满足$gcd(a,b,c,d)&#x3D;d$的整数倍,对原数组中计算到能被d整除的数的个数m[i],然后再$\binom{m[i]}{4}$,就可以求出$F(d)$了。 最后全部累加一遍,就可以得到答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10020</span>];</span><br><span class="line">ll mu[<span class="number">10020</span>], flag[<span class="number">10020</span>];</span><br><span class="line">ll prime[<span class="number">10020</span>], sum[<span class="number">10020</span>];</span><br><span class="line">ll my_count[<span class="number">10020</span>], c[<span class="number">10020</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10010</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !flag[i] ) prime[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= <span class="number">10010</span>; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            flag[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( i % prime[j] == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10010</span>; i ++ )</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cnt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>( my_count, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(my_count) );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i  = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( x % j == <span class="number">0</span> ) my_count[j] ++, my_count[x/j] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( m * m == a[i] ) my_count[m] --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10010</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = c[i<span class="number">-1</span>] * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">F</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (ll)m*(m - <span class="number">1</span>)*(m - <span class="number">2</span>)*(m - <span class="number">3</span>) / <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init_c</span>();</span><br><span class="line">    <span class="built_in">seive</span>();</span><br><span class="line">    <span class="keyword">while</span> ( ~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)  )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">init_cnt</span>();</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10010</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            ans += (ll)(<span class="built_in">F</span>(my_count[i]) * mu[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
      </categories>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2020/07/29/2020/mobiusqus/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3455">[POI2007]ZAP-Queries</a> gcd与莫比乌斯反演 <a href="https://www.luogu.com.cn/problem/P2522">[HAOI2011]Problem b</a> 上一个题目的更一般的情况，考虑容斥。 <a href="https://www.luogu.com.cn/problem/P1390">P1390 公约数的和</a> 莫比乌斯反演模板，不用分块也可以过。 <a href="http://poj.org/problem?id=3904">Sky Code</a> 莫比乌斯反演入门题</p>
]]></content>
      <categories>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>同余</title>
    <url>/2020/03/13/2020/mod/</url>
    <content><![CDATA[<p>这篇是&lt;<What Is Mathematics>&gt;以及&lt;&lt;算法导论&gt;&gt;中数论, 同余内容的笔记．</p>
<h2 id="１．一般概念"><a href="#１．一般概念" class="headerlink" title="１．一般概念"></a>１．一般概念</h2><p>如果有两个整数ａ和ｂ被５除有<strong>相同的余数，</strong> 我们称他们是”模5同余”的．</p>
<p>例如$2 % 5 &#x3D; 2$, $7 % 5 &#x3D; 2$．这里2和7是模5同余的.</p>
<p>一般地说，　如果整数ａ和ｂ用ｄ除有相同的余数，即如果有一整数ｎ使a - b &#x3D; n * d成立（这里ｄ是一固定整数），我们就说<strong>ａ和ｂ是模ｄ同余</strong>的．</p>
<p>关于同余的记号</p>
<p>a ≡ b ( mod d )</p>
<p>以下三个命题是等价的</p>
<ol>
<li>ａ和ｂ是模ｄ同余的</li>
<li>存在某个整数ｎ，使a &#x3D; b + n d</li>
<li>ｄ整除ａ－ｂ</li>
</ol>
<p>对于一个一般的关系式ａ＝ｂ，在形式上最重要的性质如下</p>
<ol>
<li>恒有a &#x3D; b</li>
<li>如果a &#x3D; b，则b &#x3D; a</li>
<li>如果a &#x3D; b，b &#x3D; c，则a &#x3D; c</li>
</ol>
<p>再有如果ａ＝ａ’，ｂ＝ｂ’则</p>
<ol>
<li>a + b &#x3D; a’ + b’</li>
<li>a - b &#x3D; a’ - b’</li>
<li>a * b &#x3D; a’ * b’</li>
</ol>
<p>当关系a &#x3D; b用同余关系a ≡ b ( mod d )代替时, 这些性质仍然成立</p>
<ol>
<li>恒有a≡a ( mod d )</li>
<li>如果a≡b ( mod d ), 则b ≡ a ( mod d )</li>
<li>如果a ≡ b( mod d ), 则b ≡ c( mod d ), 则a ≡ c ( mod d )</li>
</ol>
<p>其次如果a ≡ a’ ( mod d ), b ≡ b’ ( mod d ), 则</p>
<ol>
<li>a + b ≡ a’ + b’ ( mod d )</li>
<li>a - b ≡ a’ - b’ ( mod d )</li>
<li>a * b ≡ a’ * b’ ( mod d )</li>
</ol>
<p>关于后三个命题的证明</p>
<p>a &#x3D; a’ + r * d, b &#x3D; b’ + s * d</p>
<p>a + b &#x3D; a’ + b’ + ( r + s ) * d</p>
<p>a - b &#x3D; a’ - b’ + ( r - s ) * d</p>
<p>a * b &#x3D; a’ * b’ + ( a’ * s + b’ * r + s * r * d ) * d</p>
<p>关于a * b ≡ a’ * b’ ( mod d )这条性质，我们可以的得到一个应用</p>
<p>由于　10 ≡ -1 ( mod 11 )</p>
<p>连续地用同余式乘它自己，得到</p>
<p>10 ^ 2 ≡ ( -1 ) * ( -1 ) &#x3D; 1 ( mod 11 )</p>
<p>10 ^ 3 ≡ -1 ( mod 11 )</p>
<p>10 ^ 4 ≡ 1 ( mod 11 )</p>
<p>．．．．．．</p>
<p>这表面对于任何一个十进制整数</p>
<p>[latexpage]$ z &#x3D; a[0] + a[1] * 10 + a[2] * 10 ^ 2 + … + a[n] * 10 ^ n$</p>
<p>（　这里 a[0], a[1]的写法用来分别表示个位, 十位并以此类推．）</p>
<p>被11除后的余数，与它的数码<strong>交替变号求和</strong></p>
<p>t &#x3D; a[0] - a[1] + a[2] - a[3] + …</p>
<p>被11除后的余数是一样的，因为</p>
<p>[latexpage]$z - t &#x3D; a[1] * 11 + a[2] * ( 10 ^ 2 - 1 ) + a[3] * ( 10 ^ 3 + 1 ) + a[4] * ( 10 ^ 4 - 1 ) $…</p>
<p>而11, 10 ^ 2 - 1, 10 ^ 3 + 1…所有这些数每一个和0都是模11同余的，因此z - t也是这样，所以z被除与t被11除有相同的余数．那么一个数能被11整除的条件是它的数码交替变号之和能被11整除．</p>
<p>例如3 - 1 + 6 - 2 + 8 - 1 + 9 &#x3D; 22, 数z &#x3D; 3162819能被11整除</p>
<p>找一个被3或9整除的规律更加简单了.10 ≡ 1 ( mod 3 或 9 ) , 10 ^ n ≡ 1 ( mod 3 或 9 ).即一个整数z的所有数码之和能被3或9整除，那么整数z就能被3或9整除．</p>
<p>再对于模7同余．</p>
<p>10 ≡ 3, 10 ^ 2 ≡ 2, 10 ^ 3 ≡ 6, 10 ^ 4 ≡ 4, 10 ^ 5 ≡ 5, 10 ^ 6 ≡ 1……</p>
<p>然后就都是循环了，因此整数z被7整除的条件是表达式</p>
<p>r &#x3D; a[0] + a[1] * 3 + a[2] * 2 + a[3] * 6 + a[4] * 4 + a[5] * 5 + a[6] * 1 + …</p>
<p>r 能被7整除</p>
<p>对于整数的普遍规律: 仅当a &#x3D; 0或b &#x3D; 0时，a * b &#x3D; 0.推广可以得到</p>
<p>(7) 仅当a ≡ 0 或 b ≡ 0( mod d )时，有a * b ≡ 0 ( mod d ), 并且d为素数</p>
<h2 id="２．费马小定理"><a href="#２．费马小定理" class="headerlink" title="２．费马小定理"></a>２．费马小定理</h2><p>如果p是任意一个不能整除整数a的素数,则</p>
<p>[latexpage]$a ^ { p - 1 } $ ≡ $1 ( mod p )$</p>
<p>这意味着a的( p - 1 )次幂被p除后余1</p>
<p>举一些例子:</p>
<p>[latexpage]$10 ^ 6$ ≡ $1 ( mod 7 )$, $10 ^ 2$ ≡ $1 ( mod 3 )$, $10 ^ 10$ ≡ $1 ( mod 11 )$.</p>
<p>以及 2 ^ 12 ≡ ( mod 13 ), 5 ^ 10 ≡ 1 ( mod 11 )</p>
<p>我们可以利用同余式乘法性质来验证这两个式子</p>
<p>2 ^ 4 &#x3D; 16 ≡ 3 ( mod 13 ),                            5 ^ 2 ≡ 3 ( mod 11 )</p>
<p>2 ^ 8 ≡ 9 ≡ -4 ( mod 13 ),                           5 ^ 4 ≡ 9 ≡ -2 ( mod 11 )</p>
<p>2 ^ 8 ≡ 9 ≡ -4 ( mod 13 ),                           5 ^ 4 ≡ 9 ≡ -2 ( mod 11 )</p>
<p>2 ^ 12 ≡ -4 * 3 &#x3D; 12 ≡ 1 ( mod 13 ),         5 ^ 8 ≡ 4 ( mod 11 )</p>
<p>                                                                               5 ^ 10 ≡ 3 * 4 &#x3D; 12 ≡ 1 ( mod 11 )</p>
<p>为了证明费马定理,考虑a的倍数:</p>
<p>m_1 &#x3D; a,</p>
<p>m_2 &#x3D; 2 * a,</p>
<p>m_3 &#x3D; 3 * a,</p>
<p>… …</p>
<p>m_( p - 1 ) &#x3D; ( p - 1 ) * a</p>
<p>这些数中任意两个都不能模p同余，否则存在一对整数r,s, 满足1 &lt;&#x3D; r &lt; s &lt;&#x3D; ( p - 1 )，使p成为</p>
<p>m_s - m_r &#x3D; ( s - r ) * a 的一个因子．但由规律(7)知这是不可能的，因为s - r是小于p的，所以p不是 s - r的因子，而假设p又不是a的因子，同样地，这些数中没有一个能和0同余，因此数m_1, m_2, m_3……m_(p-1)必须相应地同余于数1, 2, 3, …, ( p - 1 ).故得出</p>
<p>m_1 * m_2 * m_3 …… m( p - 1 ) &#x3D; 1 * 2 * 3 …… ( p - 1 ) * a ^( p - 1 ) ≡ 1 * 2 * 3 ……( p - 1 ) ( mod p )</p>
<p>记K &#x3D; m_1 * m_2 * m_3 …… m( p - 1 )，原式就变成</p>
<p>K * ( a ^ ( p - 1 ) - 1 ) ≡ 0 ( mod p )</p>
<p>但因为K的因子没有能被p整除的，所以K不能被p整除，因而由规律( 7 )可知，a ^ ( p - 1 ) 必须被p整除,即</p>
<p>a ^ ( p - 1 ) - 1 ≡ 0 ( mod p )</p>
<p>这就是费马小定理．</p>
<h2 id="３．二次剩余"><a href="#３．二次剩余" class="headerlink" title="３．二次剩余"></a>３．二次剩余</h2><p>当p为奇数时，有p &#x3D; 2 * p’ + 1则：</p>
<p>a ^ ( p - 1 ) - 1 &#x3D; a ^ ( 2 * p’ ) - 1 &#x3D; ( a ^ p’ - 1 ) * ( a ^ p’ + 1 ) ≡ 0 ( mod p )</p>
<p>这说明或者( a ^ p’ - 1 )或者( a ^ p’ + 1 )必须被p整除，所以对于任一素数p &gt; 2和任一不被p整除的数a有：</p>
<p>或有a ^ ( ( p - 1 ) &#x2F; 2 ) ≡ 1, 或有 a ^ ( ( p - 1 ) &#x2F; 2 ) ≡ -1 ( mod p ).</p>
<p>近代数论出现后，数学家就很感兴趣地去寻找什么样的数a使第一种情形成立，什么样的数a使第二种情形成立.假设a与某个数x的平方是模p同余的，即：</p>
<p>a ≡ x ^ 2 ( mod p )</p>
<p>则a ^ ( ( p - 1 ) &#x2F; 2 ) ≡ x ^ ( p - 1 )，而它按照费马定理是模p同余于1的．</p>
<p>一个数a，如果不是p的倍数且模p同余于某个数的平方，则称a为p的<strong>二次剩余</strong>．</p>
<p>而一个不是p的倍数的数b，不同余于任何数的平方，称它为p的<strong>非二次剩余</strong>．</p>
<p>每一个p的二次剩余a满足同余式a ^ ( ( p - 1 ) &#x2F; 2 ) ≡ 1 ( mod p )，不难证明对每一个非二次剩余b，有同余式b ^ ( ( p - 1 ) &#x2F; 2 ) ≡ -1 ( mod p )．更进一步，在数1, 2, 3, ……, p - 1中恰有( p - 1 ) &#x2F; 2个二次剩余和( p - 1 ) &#x2F; 2个非二次剩余．</p>
<p>对于两个不同素数p和q：</p>
<p>如果乘积( p - 1 ) &#x2F; 2 * ( q - 1 ) &#x2F; 2是偶数，则q是p的二次剩余必须而且只须p是q的二次剩余．</p>
<p>在乘积( p - 1 ) &#x2F; 2 * ( q - 1 ) &#x2F; 2 是奇数时，这情形相反，p是q的剩余必须而且只须q是p的非剩余．</p>
<p>这也就是<strong>二次互反律</strong>．</p>
<p>对于二次互反律的举例：</p>
<p>偶数情况:：取p&#x3D;5，q&#x3D;11，由于 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B(5-1)%7D%7B2%7D%5Ccdot+%5Cfrac%7B(11-1)%7D%7B2%7D" alt="[公式]"> 乘积是偶数，则 <img src="https://www.zhihu.com/equation?tex=11%5Cequiv+1%5E%7B2%7D(mod+%5C+%5C+5)" alt="[公式]"> ，11是二次剩余(mod 5)；并且<img src="https://www.zhihu.com/equation?tex=5%5Cequiv+4%5E%7B2%7D(mod+%5C+%5C+11)" alt="[公式]">，5是二次剩余(mod 11)。</p>
<p>奇数情况：取p&#x3D;7，q&#x3D;11，由于 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B(7-1)%7D%7B2%7D%5Ccdot+%5Cfrac%7B(11-1)%7D%7B2%7D" alt="[公式]"> 乘积是奇数， <img src="https://www.zhihu.com/equation?tex=11%5Cequiv+2%5E%7B2%7D(mod+%5C+%5C+7)" alt="[公式]"> ，11是二次剩余(mod 7)；但是 <img src="https://www.zhihu.com/equation?tex=7%5Cequiv+18(mod+%5C+%5C+11)" alt="[公式]"> ，7是非二次剩余(mod 11)。</p>
]]></content>
      <categories>
        <category>maththeory</category>
      </categories>
      <tags>
        <tag>maththeory</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法</title>
    <url>/2020/05/23/2020/newtonmethod/</url>
    <content><![CDATA[<p>[latexpage]</p>
<p>如果$x \mapsto f(x)$是一个可微函数,那么方程g(x) &#x3D; 0的一个解就是函数$x \mapsto f(x)$的一个不动点,其中:</p>
<p>$f(x) &#x3D; x - \frac{g(x)}{Dg(x)}$                     $(1)$</p>
<p>Dg(x)是g对x的导数,对于许多函数(有一些函数或者特殊情况会使牛顿法无法求解),以及充分好的初始猜测x,牛顿法都能很快收敛到$g(x)&#x3D;0$的一个解.</p>
<p>一般而言,如果g是一个函数而dx是一个很小的数,那么g的导数在任一数值x的值由下面函数(作为很小的数dx的极限)给出:</p>
<p>$Dg(x) &#x3D; \frac{g(x+dx) -g(x)}{dx}$</p>
<p>对于(1)进行推导.</p>
<p>点$x_n$的切线方程为$g(x_n) &#x3D; f’(x_n) ( x - x_n ) + f(x_n)$, $x_{n+1} $为$g(x_n) &#x3D; 0$的解,</p>
<p>$f’(x_n) ( x - x_n ) + f(x_n) &#x3D; 0$</p>
<p>$ x &#x3D; x_n - \frac{f(x_n)}{f’(x_n)} $</p>
<p>$ x_{n+1} &#x3D; x_n - \frac{f(x_n)}{f’(x_n)} $</p>
<p><strong>用图像表示牛顿迭代法的过程</strong></p>
<p><img src="/images/%E6%AD%A3%E7%A1%AE.jpg"></p>
<p>[latexpage]对曲线$f(x) &#x3D; \frac{(x - 5) ^ 3}{10} - 1$以x &#x3D; 10为初始点的应用牛顿迭代法求零点,其中红色为函数切线,蓝色为垂线.B,D,F为三个切点,A,C,E为切点在x轴上的投影,可以发现每一次投影的点都在向曲线与x轴的交点接近.</p>
<p><strong>用scheme写的牛顿迭代法求开方代码</strong></p>
<p>(define dx 0.00001 )</p>
<p>(define tolerance 0.00001 )</p>
<p>(define (fixed-point f first-guess )<br>    (define (close-enough? v1 v2  )<br>        ( &lt; ( abs ( - v1 v2 ) ) tolerance ))<br>    (define (try guess  )<br>        (let ( (next ( f guess ) ) )<br>            (if ( close-enough? guess next )<br>                next<br>                ( try next )<br>            )<br>        )<br>    )<br>    ( try first-guess )<br>)</p>
<p>(define (cube x ) ( * x x x ))</p>
<p>(define (deriv g )<br>    (lambda (x)<br>        ( &#x2F; ( - (g ( + x dx ) ) (g x ) ) dx )<br>    )<br>)</p>
<p>(define (newton-transform g )<br>    (lambda (x)<br>        ( - x ( &#x2F; ( g x ) (( deriv g ) x) ) )<br>    )<br>)</p>
<p>(define (newton-method g guess )<br>    ( fixed-point ( newton-transform g ) guess )<br>)</p>
<p>(define (fixed-point-of-transform g transform guess )<br>    ( fixed-point ( transform g ) guess )<br>)</p>
<p>(define (sqrt3 x )<br>    (fixed-point-of-transform<br>        (lambda (y) ( - ( square y ) x )  )<br>        newton-transform<br>        1.0<br>    )<br>)</p>
<p>( sqrt3 9 )</p>
<p><strong>用c写的牛顿迭代法求开方的代码</strong></p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;<br>#define dx 0.000001<br>#define minx 0.0000001</p>
<p>double f( double x ) {return x * x - 2;}</p>
<p>double Df( double x ) {return (f( x + dx ) - f(x)) &#x2F; dx;}</p>
<p>double next_point ( double x ) { return x - f(x) &#x2F; Df(x); }</p>
<p>double find_ans(double x)<br>{<br>    double point1 &#x3D; x;<br>    double point2;<br>    for ( ;; )<br>    {<br>        point2 &#x3D; next_point(point1);<br>        if ( abs(point1 - point2) &lt; minx ) break;<br>        point1 &#x3D; point2;<br>    }<br>    return point2;<br>}</p>
<p>int main()<br>{<br>    cout &lt;&lt; find_ans(2)&lt;&lt;endl;<br>    return 0;<br>}</p>
<p><strong>一些牛顿法不能求解的例子</strong></p>
<p><img src="/images/%E9%A9%BB%E7%82%B9.jpg"></p>
<p>在迭代过程中遇到了<strong>驻点</strong></p>
<p><img src="/images/%E9%9C%87%E8%8D%A1.jpg"></p>
<p>[latexpage]在$y &#x3D; |x| ^ {1&#x2F;2}$的两个切点之间循环震荡的情况</p>
<p><img src="/images/%E4%B8%8D%E6%94%B6%E6%95%9B-1024x294.jpg"></p>
<p>[latexpage]$y &#x3D; x^{1&#x2F;3}$的切线投影与函数零点越来越远,不收敛于零点的情况</p>
<p>诸如这些的还有在多个零点情况下不能求出多解,或者求出非期望的零点等等,不再一一举例.</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
  </entry>
  <entry>
    <title>2020牛客寒假算法基础集训营2</title>
    <url>/2020/03/08/2020/nkwinter2/</url>
    <content><![CDATA[<p>痛定思痛后觉定把牛客算法集训营的题解写一下,以及学习一下比赛时不会的那些知识.</p>
<p>题目链接:<a href="https://ac.nowcoder.com/acm/contest/3003?&headNav=www">https://ac.nowcoder.com/acm/contest/3003?&headNav=www</a></p>
<h2 id="A-做游戏"><a href="#A-做游戏" class="headerlink" title="A 做游戏"></a>A 做游戏</h2><p>是一道签到题, 当时为了快速解决它, 看漏了条件, 没有真正理解题意, 导致我还是WA了一发.不需要过多的解释, 直接取每一对组合中最小的那个值再累加就好了.</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>long long int a,b,c;<br>long long int x,y,z;</p>
<p>int main()<br>{<br>    scanf(“%lld%lld%lld”,&amp;a,&amp;b,&amp;c);<br>    scanf(“%lld%lld%lld”,&amp;x,&amp;y,&amp;z);<br>    long long int ans &#x3D; 0;<br>    ans &#x3D; min( a , y ) + min( b , z ) + min( c , x );<br>    printf(“%lld”,ans);<br>    return 0;<br>}</p>
<h2 id="B-排数字"><a href="#B-排数字" class="headerlink" title="B 排数字"></a>B 排数字</h2><p>应该是一道思维题, 要正确理解以下这句话的意思</p>
<blockquote>
<p>当两个子串 <strong>S[l1…r1]</strong>, <strong>S[l2…r2]</strong> 满足 l1≠l2​ 或 r1≠r2​ 时它们被认为是不同的。</p>
</blockquote>
<p>就是说比如有四个6四个1, 那么最优的应该是6161616而不是616616.</p>
<p>当然很多选手并不会有616616那种想法,因为我第一发就是计算6和1的个数然后直接</p>
<p>min( cnt6&#x2F;2, cnt1)交了上去, WA了一发…….</p>
<p>正确做法是记录6和1的个数, 特判答案为0的情况, 再根据6和1孰多进行计算.</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>long long int len;<br>string ss;</p>
<p>int main()<br>{<br>    scanf(“%lld”, &amp;len);<br>    cin &gt;&gt; ss;<br>    long long int cnt6, cnt1;<br>    cnt6 &#x3D; cnt1 &#x3D; 0;<br>    for ( long long int i &#x3D; 0; i &lt; len; i ++ )<br>    {<br>        if ( ss[i] &#x3D;&#x3D; ‘6’ ) cnt6 ++;<br>        if ( ss[i] &#x3D;&#x3D; ‘1’ ) cnt1 ++;<br>    }<br>    if ( cnt1 &#x3D;&#x3D; 0 || cnt6 &lt; 2 ) printf(“0\n”);<br>    else if ( cnt6 &gt; cnt1 ) printf(“%lld\n”,cnt1);<br>    else if ( cnt6 &lt;&#x3D; cnt1 ) printf(“%lld\n”,cnt6 - 1);</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<h2 id="G-判正误"><a href="#G-判正误" class="headerlink" title="G 判正误"></a>G 判正误</h2><p>一看到这题以为是一个大数+快速幂的题目, 于是立马想到用py去偷,.当时认为只用写一个快速幂算法就可以AC, 然而发现了诸多问题.</p>
<p>使用python的快速幂运算仍然超时, 在python中快速幂运算甚至比最基础的幂运算效率还低, 这可能关系到pyhton的底层幂运算实现, 我猜想是一种比快速幂运算更优的幂运算算法.</p>
<p>以下是我python的超时代码</p>
<p>def power( base, exponent ):<br>    res &#x3D; 1<br>    while exponent &gt; 0:<br>        if exponent &amp; 1 :<br>            res &#x3D; res * base<br>        base &#x3D; base * base<br>        exponent &gt;&gt;&#x3D; 1<br>    return res</p>
<p>n &#x3D; int(input())<br>while n:<br>    n &#x3D; n - 1<br>    s &#x3D; input().split()<br>    a &#x3D; power( int(s[0]), int(s[3]) ) + power( int(s[1]),int(s[4])  ) + power( int(s[2]), int(s[5]) )<br>    if a &#x3D;&#x3D; int(s[6]):<br>        print(“Yes”)<br>    else:<br>        print(“No”)</p>
<p>后来我看到集训队群里讨论, 有人直接裸写过了这题, 什么大数和快速幂都没用.于是没有想很多立马用C++敲了一发.</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>long long int n;<br>long long int a, b, c, d, e, f, g;<br>long long int ans;</p>
<p>int main()<br>{<br>    scanf(“%lld”, &amp;n);<br>    while ( n – )<br>    {<br>        ans &#x3D; 0;<br>        scanf(“%lld%lld%lld%lld%lld%lld%lld”,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g);<br>        long long int tmp1 &#x3D; pow( a,d ),tmp2 &#x3D; pow( b,e ),tmp3 &#x3D; pow( c,f );<br>        if ( tmp1 + tmp2 &#x3D;&#x3D; g - tmp3 ) printf(“Yes\n”);<br>        else printf(“No\n”);<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<p>这里需要注意的是以下这个判断</p>
<p>if ( tmp1 + tmp2 &#x3D;&#x3D; g - tmp3 ) printf(“Yes\n”);</p>
<p>第一次写的时候我是tmp1 + tmp2 + tmp3 &#x3D;&#x3D; g , 似乎还是把long long 存爆了….然后改成了</p>
<p>tmp1 + tmp2 &#x3D;&#x3D; g - tmp3这种写法.</p>
<p>但是今天(20203.6)我再次把这题交了一遍, 数据加强了….果然还是要快速幂处理的…</p>
<p>然而用python的另一种写法处理大数和幂运算可以AC</p>
<p>m &#x3D; 2**10+7<br>n&#x3D;int(input())<br>for i in range(n):<br>    a,b,c,d,e,f,g &#x3D; map(int,input().split())<br>    if ( pow(a,d,m)+pow(b,e,m)+pow(c,f,m) )%m &#x3D;&#x3D; g % m: print(“Yes”)<br>    else : print(“No”)</p>
<p>数据增强后c++AC代码, 此外在大数的题目设计中, 出题者往往会故意卡掉一些模数, 应当用2-3个模数共同验证, 以提高正确率.这题就是这样的.</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>typedef long long ll;<br>ll n;<br>ll a, b, c, d, e, f, g;<br>ll ans;<br>const long long int mod &#x3D; 1e9+7;</p>
<p>ll qpow(ll a,ll b)<br>{<br>    ll ans&#x3D;1,base&#x3D;a;<br>    while( b )<br>    {<br>        if( b &amp; 1 ) ans&#x3D;ans*base%mod;<br>        b&gt;&gt;&#x3D;1;<br>        base &#x3D; base * base % mod;<br>    }<br>    return ans % mod;<br>}</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;m &#x3D; (int)m;<br>    scanf(“%lld”, &amp;n);<br>    while ( n – )<br>    {<br>        ans &#x3D; 0;<br>        scanf(“%lld%lld%lld%lld%lld%lld%lld”,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g);<br>        long long int tmp1,tmp2,tmp3;<br>        tmp1 &#x3D; qpow( a,d ),tmp2 &#x3D; qpow( b,e ),tmp3 &#x3D; qpow( c,f );<br>        if ( tmp1 + tmp2 + tmp3 &#x3D;&#x3D; g % mod ) printf(“Yes\n”);<br>        else printf(“No\n”);<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<h2 id="I-建通道"><a href="#I-建通道" class="headerlink" title="I 建通道"></a>I 建通道</h2><p>是一道思维题,比赛的时候给题目唬住了….</p>
<p>首先去重,再找出所有数字的二进制中最靠右的1出现的位置k, 并且要保证k的数量小于数字总数,那么答案就是2^k*(cnt - 1).</p>
<p>因为选出二进制中尽量靠右的1的那个数据能够使lowbit后的值尽量小.</p>
<p>举一组例子:</p>
<ul>
<li>1 -&gt; 0 0 0 1</li>
<li>2 -&gt; 0 0 1 0</li>
<li>3 -&gt; 0 0 1 1</li>
<li>4 -&gt; 0 1 0 0</li>
<li>8 -&gt; 1 0 0 0</li>
</ul>
<p>那么先选择1与2 4 8 相连, 再是3与2 4 8其中任意一个相连, 最小生成树就形成了, 答案是4.也可以看做是1连接了两次, 推导一下就得到公式2^k*(cnt - 1).</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>typedef long long ll;<br>ll n, a[200010], b[200010];</p>
<p>int main()<br>{<br>    scanf(“%lld”, &amp;n);<br>    for ( int i &#x3D; 0; i &lt; n; i ++ ) scanf(“%lld”, &amp;a[i]);<br>    sort( a, a + n );<br>    int cnt &#x3D; 1;<br>    b[cnt] &#x3D; a[0];<br>    for ( int i &#x3D; 1; i &lt; n; i ++ )<br>    {<br>        if ( a[i] !&#x3D; a[i-1] )<br>        {<br>            cnt ++;<br>            b[cnt] &#x3D; a[i];<br>        }<br>    }<br>    if ( cnt &#x3D;&#x3D; 1 )<br>    {<br>        printf(“0\n” );<br>        return 0;<br>    }<br>    for ( int i &#x3D; 0; i &lt; 30; i ++ )<br>    {<br>        int k &#x3D; 0;<br>        for ( int j &#x3D; 1; j &lt;&#x3D; cnt; j ++ ) if ( (b[j] &gt;&gt; i) &amp; 1 ) k ++;<br>        if ( k &gt; 0 &amp;&amp; k  &lt; cnt )<br>        {<br>            printf(“%d\n”, (1 &lt;&lt; i) * ( cnt - 1 ) );<br>            return 0;<br>        }<br>    }<br>    return 0;<br>}</p>
<p>另外据说最小生成树算法也可以AC, 日后更新解法.</p>
<h2 id="E-做计数"><a href="#E-做计数" class="headerlink" title="E 做计数"></a>E 做计数</h2><p>完全平方后展开,得到 i + j + 2 * sqrt(i * j) &#x3D; k, 只要i*j是平方数.</p>
<p>判断i * j是否为平方数的方法是, i % sqrt(j) &#x3D;&#x3D; 0</p>
<p>并且解法的枚举是<strong>O( sqrt(N) * sqrt(N) ) &#x3D; O(N)</strong>, 是不会超时的(比赛时候我把它错分析成O(N^2))了.</p>
<p>这里还要注意的是i,j相等时只累加一次.</p>
<p>代码:</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int n;</p>
<p>int main()<br>{<br>    long long int ans &#x3D; 0;<br>    scanf(“%d”, &amp;n);<br>    for ( int i &#x3D; 1; i &lt;&#x3D; sqrt(n); i ++ )<br>    {<br>        for ( int j &#x3D; 1; j &lt;&#x3D; i; j ++ )<br>        {<br>            if ( j &#x3D;&#x3D; i ) ans ++;<br>            else if ( ! (i * i % j) )<br>            {<br>                ans +&#x3D; 2;<br>                &#x2F;&#x2F;printf(“%d %d\n”, i, j);<br>            }<br>        }<br>    }<br>    printf(“%lld\n”, ans);<br>    return 0;<br>}</p>
<h2 id="D-数三角"><a href="#D-数三角" class="headerlink" title="D 数三角"></a>D 数三角</h2><p>又是一道计算几何题, 和杭电的5784类似, 不过5784是数锐角三角形, 这里是数钝角三角形, 解法还是一样的. 是使用极角排序的一个题目.</p>
<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br>const double pi&#x3D;acos(-1.0);<br>const double eps&#x3D;1e-9;<br>int n;</p>
<p>struct node1<br>{<br>    double x,y;<br>} a[510];</p>
<p>double node[4010];</p>
<p>int main()<br>{<br>    scanf(“%d”,&amp;n);</p>
<pre><code>for (int i = 1; i &lt;= n; i ++) scanf(&quot;%lf%lf&quot;,&amp;a\[i\].x,&amp;a\[i\].y);
ll ans = 0;
for(int i = 1; i &lt;= n; i ++ )
&#123;
    int cnt = 0;
    for( int j = 1;j &lt;= n; j ++)
    &#123;
        if( i == j ) continue;
        node\[++cnt\] = atan2(a\[i\].y - a\[j\].y, a\[i\].x - a\[j\].x);
        if( node\[cnt\] &lt; 0 ) node\[cnt\] += 2 \* pi;
    &#125;
    sort( node + 1, node + 1 + cnt);
    for( int j = 1; j &lt;= cnt; j ++) node\[j+cnt\] = node\[j\] + 2 \* pi;
    int l = 1, r = 1, len = 1;
    for(int j = 1; j &lt;= cnt; j ++)
    &#123;
        while( r &lt;= 2 \* cnt &amp;&amp; node\[r\] - node\[j\] &lt; pi ) r ++;
        while( l &lt;= 2 \* cnt &amp;&amp; node\[l\] - node\[j\] &lt;= 0.5 \* pi )l++;
        ans += r - l;
    &#125;
&#125;
printf(&quot;%lld\\n&quot;,ans);

return 0;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>红辣椒</title>
    <url>/2020/03/08/2020/paprika/</url>
    <content><![CDATA[<p>很早之前就看到这部作品的名字了, 但是一直没有去看.昨天下午把它下来看一遍, 红辣椒给我的感觉就如同大梦一场. 在许多场景中我无法分辨此时到底是梦境还是现实, 就如同我真正在做梦时不知道我在做梦的那种感觉.</p>
<p>刚刚开始看的时候由于DCmini能够’共享梦境’的功能,使我想到了盗梦空间, 两部作品是有些许相似之处, 盗梦空间更加偏向理性和逻辑的完美性, 而红辣椒则更加魔幻, 或者说更加像我们真正做梦的那种感觉.拿两部作品进行比较的话, 盗梦空间的主题是在讲如何窃取&#x2F;修改他人梦境中的信息以及意识的故事, 而红辣椒更加多元化, 我看到的就有物质世界与精神世界的碰撞, 对科学日益发展的思考, 人性, 还有爱情等. 我觉得红辣椒看一遍是不够的, 因为有太多太多细节和作者的思想无法在第一次被我捕捉到.</p>
<p><img src="/images/timg?image&quality=80&size=b9999_10000&sec=1583695314029&di=b162883d8356b71c65e16ed0e046439f&imgtype=0&src=http://b-ssl.duitang.com/uploads/item/201808/21/20180821122401_fujfw.thumb.700_0.jpg"></p>
<p><img src="/images/timg?image&quality=80&size=b9999_10000&sec=1583695357591&di=cc7fa873fdf9079d1af5bc267d3164f6&imgtype=0&src=http://b-ssl.duitang.com/uploads/item/201809/05/20180905171004_45QGk.png"></p>
<p><img src="/images/timg?image&quality=80&size=b9999_10000&sec=1583695424077&di=8a8da87d2fef8028d6f602563409d782&imgtype=jpg&src=http://img4.imgtn.bdimg.com/it/u=3674535034,3030225341&fm=214&gp=0.jpg"></p>
<p>故事女主千叶敦子, 事实上去看这部作品的很大一部分原因是女主的颜…..这种样貌冷艳的女子对鄙人吸引力很大, 而且设定上也如同她的外貌, 是一位知识渊博的冰山美人. 故事的最后她嫁给了肥宅科学家, 怎么说呢, 给我的感觉就是羡慕又嫉妒吧, 为什么肥宅抱得美人归???然而实际上, 我猜想作者也是给大多数的相貌平平的人以希望吧, 一个人要是颜值与智谋都不出众的话, 那才是真正的悲哀, 女主这个结局也是给包括我在内的大部分人以慰藉, 好好工作学习折腾出一些名堂.</p>
<p>对于故事中的肥宅科学家时田, 事实上我们的身上(特别是程序员这种职业吧)或多或少都会有他的影子, 宅也好, 钻研自己所喜欢的事物也好, 都还是有些相似的.当然要是成天对着电脑不运动的话可能在体型上很快就要接近时田了.</p>
<p>还有一些令我印象深刻的场景.电影一开始就在讲述粉川警官的梦境, 是诸多不同场景的切换, 人物一直在奔跑, 形体和周围的事物也一直在变换.真的给我一种梦境的感觉, 因为我在做梦时就有遇到过不停在奔跑,以及四周场景不停变换的那种时候, 相信大家也都是会有的. 还有一个引起我共鸣的是DCmini控制研究所的两名工作人员后, 工作人员在楼道里胡言乱语的情形.第一是曾有过经历我无法分清此时此刻到底是在梦境还是现实, 如果真的是在梦境中, 那么我根本就不会知道这是梦境了; 在现实中仔细思考一下是能够立马区分的, 很多次脑海中会浮现场景似乎曾经发生过但又似在梦中难以琢磨.第二是这个场景就很像城市里工作的职员被繁忙的事物压榨后所做出的疯狂表现, 在我看来他们是在现实中做出了自己只敢幻想但又不敢真正在现实中做出来的一些行为.</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583696717069&di=c6ac9526bc0ef01f6cd9a55802acafed&imgtype=0&src=http://img.dedns.cn/wpic/mmbiz_jpg/FdMzmKxmhGjgM8UZibbomH1BR1qiavjnj04V5jBLGyic2yO1xC741fBJ5dIbr8mt3RYbKibzo8YYbnoI40Xlw5U0Dg/0?wx_fmt=jpeg"></p>
<p>我看过的日本动画电影比较少, 先前只看过宫崎骏和新海诚的作品, 我觉得宫崎骏的作品是讲述童年和生活的美好片段, 每一个人物都是善良的, 没有绝对的反派; 新海诚则是在讲述青春, 故事主人公总会有一些与我们成长过程中的类似经历映射或者影子. 今敏的作品则是给我截然不同的感觉, 就单红辣椒来说, 是一种荒诞, 就如同在一张白纸上洒上各种颜色的颜料, 美丽而又疯狂.</p>
<p><img src="https://img3.doubanio.com/view/photo/l/public/p2454662003.webp"></p>
<p>最后聊聊配乐, 最洗脑的还是游行和Paprika在梦境中穿梭的那两首歌.</p>
<p>Parade 是那支游行队伍出现时的配乐, 电影多次出现, 音乐本身就非常洗脑, 真的有一种军队在行进的感觉, 多次重复出现再加上本身音乐的洗脑略微有一种头晕目眩的感觉, 当然这估计也是作者的意图所在吧.</p>
<p>还有就是 <em>媒介野</em> Mediational Field 这首歌, 女声只在唱一句歌词, 但是将这句词多次叠加, 并且在不同的结点出现, 营造出了一种错乱的感觉, 也对应了梦境的无序与复杂.事实上听上去还是很洗脑很带感的, 配上Paprika在各种梦中的地方穿梭, 还是很刺激的.</p>
<p>大致就是这些, 有新想法还会来补充的.</p>
]]></content>
      <categories>
        <category>movie</category>
      </categories>
  </entry>
  <entry>
    <title>Pollar-Rho算法</title>
    <url>/2020/08/04/2020/poolar-rho/</url>
    <content><![CDATA[<p>Pollar-Rho 算法是一种用于快速分解质因数的算法。</p>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>给定一个正整数$N \in \mathbb{N}_{+}$，试快速找到它的一个因数。</p>
<p>考虑朴素算法，因数是成对分布的，$N$的所有因数可以被分成两块，即$[1,\sqrt N]$和$[\sqrt N+1,N]$。只需要把$[1,\sqrt N]$里的数遍历一遍，再根据除法就可以找出至少两个因数了。这个方法的时间复杂度为$O(\sqrt N)$。</p>
<p>当$N\ge10^{18}$时，这个算法的运行时间我们是无法接受的，希望有更优秀的算法。一种想法是通过随机的方法，猜测一个数是不是$N$的因数，如果运气好可以在$O(1)$的时间复杂度下求解答案，但是对于$N\ge10^{18}$的数据，成功猜测的概率是$\frac{1}{10^{18}}$,期望猜测的次数是$10^{18}$。如果是在$[1,\sqrt N]$里进行猜测，成功率会大一些。我们希望有方法来优化猜测。</p>
<h2 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h2><p>不考虑出生年份，问：一个房间中至少多少人，才能使其中两个人生日相同的概率达到$50\%$?</p>
<p>解： 假设一年有 $n$ 天，屋子中有 $k$ 人，用整数 $1, 2,\dots, k$对这些人进行编号。假定每个人的生日均匀分布于 $n$ 天之中，且两个人的生日相互独立。</p>
<p>设 k 个人生日互不相同为事件$A$, 则事件$A$的概率为</p>
<p>$$ P(A)&#x3D;\frac{n}{n} * \frac{n-1}{n} * \dots *\frac{n-k+1}{n} $$</p>
<p>至少有两个人生日相同的概率为$P(\overline A)&#x3D;1-P(A)$。根据题意可知$P(\overline A)\ge\frac{1}{2}$ ,那么就有$1 * \frac{n-1}{n} * \dots *\frac{n-k+1}{n} \le \frac{1}{2}$</p>
<p>由不等式$1+x\le e^x$可得</p>
<p>$$ P(A) \le e^{-\frac{1}{n}}* e^{-\frac{2}{n}}*\dots * e^{-\frac{k-1}{n}}&#x3D;e^{-\frac{k(k-1)}{2n}}\le\frac{1}{2}\ e^{-\frac{k(k-1)}{2n}}\le\frac{1}{2} $$</p>
<p>将$n&#x3D;365$代入，解得$k&#x3D;23$。所以一个房间中至少23人，使其中两个人生日相同的概率达到$50\%$,但这个数学事实十分反直觉，故称之为一个悖论。</p>
<p>然而我们可以得到一个不等式方程，$e^{-\frac{k(k-1)}{2n}}\le 1-p$，其中$p$是一个概率。那么当$k&#x3D;57$，$n&#x3D;365$时，可以求得$p\approx 0.99$。</p>
<p>考虑一个问题，设置一个数据$n$，在$[1,1000]$里随机选取$i$个数（i&#x3D;1时就是它自己），使它们之间有两个数的差值为$k$。当$i&#x3D;1$时成功的概率是$\frac{1}{1000}$，当$i&#x3D;2$时成功的概率是$\frac{1}{500}$（考虑绝对值,$num_2$可以取$num_1-k$或$num_1+k$），随着$i$的增大，这个概率也会增大最后趋向于1。</p>
<h2 id="优化随机算法"><a href="#优化随机算法" class="headerlink" title="优化随机算法"></a>优化随机算法</h2><p>最大公约数一定是某个数的约数，即$\forall k \in\mathbb{N}_{+},gcd(k,n)|n$，只要选适当的$k$使得$1&lt;\gcd(k,n)&lt; n$，就可以求得一个约数$\gcd(k,n)$。满足这样条件的$k$不少，$k$有若干个质因子，每个质因子及其倍数都是可行的。</p>
<p>根据生日悖论，取多组数据作差能够优化取数的精确性。那么不妨取一组数 $x_1,x_2,\dots,x_n$若有$1&lt;\gcd(|x_i-x_j|,n) &lt; n$,则称$gcd(|x_i-x_j|,N)$是$N$的一个因子（更严谨一些，应该是非平凡因子，即满足 $1&lt; d &lt; n,d|n$ 的那些数）。</p>
<h3 id="构造伪随机函数"><a href="#构造伪随机函数" class="headerlink" title="构造伪随机函数"></a>构造伪随机函数</h3><p>构造一个伪随机数序列，取相邻的两项来求$\gcd(|x_i-x_j|,N)$。通过$f(x)&#x3D;(x^2+c)\%n$来生成随机数，其中$c&#x3D;rand()$，是一个随机的常数。</p>
<p>随机取一个$x_1$，令$x_2&#x3D;f(x_1),x_3&#x3D;f(x_2),\dots,x_i&#x3D;f(x_{i-1})$，在一定范围内可以认为这个数列是“随机”的。</p>
<p>举个例子，设$N&#x3D;50,c&#x3D;2,x_1&#x3D;1$ $f(x)$生成的数据为</p>
<p>$$ 1,3,11,23,31,11,23,31,\dots $$</p>
<p>可以发现数据在3以后都在11,23,31之间循环，这也是$f(x)$被称为伪随机函数的原因。</p>
<h3 id="Floyd判环"><a href="#Floyd判环" class="headerlink" title="Floyd判环"></a>Floyd判环</h3><p>考虑两个人在赛跑，A的速度快，B的速度慢，经过一定时间后，A总是会和B相遇，且相遇时A跑过的总距离减去B跑过的总距离一定是圈长的n倍。</p>
<p>初始$a&#x3D;f(1),b&#x3D;f(f(1))$，每一次更新$a&#x3D;f(a),b&#x3D;f(f(b))$，只要检查在更新过程中a、b是否相等，如果相等了，那么就出现了环。</p>
<p>我们每次判断$d&#x3D;gcd(|x_i-x_j|,n)$，判断d是否满足$1&lt; d&lt; n$，若满足则可直接返回$d$。由于$x_i$是一个伪随机数列，必定会形成环，在形成环时就不能再继续操作了，直接返回n本身，并且在后续操作里调整随机常数$c$，重新分解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">PR</span><span class="params">(ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll c = <span class="built_in">rand</span>() % (N - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    ll t = <span class="built_in">f</span>(<span class="number">0</span>, c, N);</span><br><span class="line">    ll r = <span class="built_in">f</span>(<span class="built_in">f</span>(<span class="number">0</span>, c, N), c, N);</span><br><span class="line">    <span class="keyword">while</span>(t != r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(t - r), N);</span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">        t = <span class="built_in">f</span>(t, c, N);</span><br><span class="line">        r = <span class="built_in">f</span>(<span class="built_in">f</span>(r, c, N), c, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="倍增优化"><a href="#倍增优化" class="headerlink" title="倍增优化"></a>倍增优化</h3><p>使用$gcd$求解的时间复杂度为$O(log N)$，频繁地调用会使算法运行地很慢，可以通过乘法累积来减少求$gcd$的次数。如果$1&lt; gcd(a,b)$，则有$1&lt; gcd(ac,b)$，$c\in \mathbb{N}_{+}$，并且有$1&lt; gcd(ac \%b,b)&#x3D;gcd(a,b)$。</p>
<p>考虑每过一段时间将这些差值进行$gcd$运算，设$s&#x3D;\prod|x_0-x_j|\%n$，如果某一时刻得到$s&#x3D;0$那么表示分解失败，退出并返回$n$本身。每隔$2^k$个数，计算是否满足$1&lt; gcd(s, n) &lt; n$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">PR</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>,t = <span class="number">0</span>;</span><br><span class="line">    ll c= <span class="built_in">rand</span>() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>, goal = <span class="number">1</span>;</span><br><span class="line">    ll val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( goal=<span class="number">1</span>; ;goal &lt;&lt;= <span class="number">1</span>, s = t, val = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(step = <span class="number">1</span>; step &lt;= goal; ++step)</span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="built_in">f</span>(t, c, x);</span><br><span class="line">            val= val * <span class="built_in">abs</span>(t - s) % x;</span><br><span class="line">            <span class="keyword">if</span>( (step % <span class="number">127</span>) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ll d = <span class="built_in">gcd</span>(val,x);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll d = <span class="built_in">gcd</span>(val, x);</span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题:<a href="https://www.luogu.com.cn/problem/P4718">P4718 【模板】Pollard-Rho算法</a></p>
<p>对于一个数 n ，用<a href="/prime/#_4">Miller Rabin算法</a>判断是否为素数，如果是就可以直接返回了，否则用Pollard-Rho算法找一个因子 p ，将 n 除去因子 p 。再递归分解 n 和 p ，用Miller Rabin判断是否出现质因子，并用max_factor更新就可以求出最大质因子了。由于这个题目的数据过于庞大，用Floyd判环的方法是不够的，这里采用倍增优化的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll __int128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll max_factor, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qp</span><span class="params">(ll x,ll p,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (lll)ans * x % mod;</span><br><span class="line">        x = (lll) x * x % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Miller_rabin</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll d = p - <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(d&amp;<span class="number">1</span>)) ++r, d &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll k =<span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">        ll a = <span class="built_in">rand</span>() % (p - <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">        ll x = <span class="built_in">qp</span>(a, d, p);</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> || x == p<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            x = (lll)x * x % p;</span><br><span class="line">            <span class="keyword">if</span>(x == p - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != p - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x,ll c,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lll)x * x + c) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PR</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>,t = <span class="number">0</span>;</span><br><span class="line">    ll c = (ll)<span class="built_in">rand</span>() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>, goal = <span class="number">1</span>;</span><br><span class="line">    ll val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( goal=<span class="number">1</span>; ;goal &lt;&lt;= <span class="number">1</span>, s = t, val = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(step = <span class="number">1</span>; step &lt;= goal; ++step)</span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="built_in">f</span>(t, c, x);</span><br><span class="line">            val= (lll)val * <span class="built_in">abs</span>(t - s) % x;</span><br><span class="line">            <span class="keyword">if</span>( (step % <span class="number">127</span>) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ll d = <span class="built_in">gcd</span>(val,x);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll d = <span class="built_in">gcd</span>(val, x);</span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fac</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= max_factor || x &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_rabin</span>(x))</span><br><span class="line">    &#123;</span><br><span class="line">        max_factor = <span class="built_in">max</span>(max_factor, x);</span><br><span class="line">        <span class="keyword">return</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    ll p = x;</span><br><span class="line">    <span class="keyword">while</span>(p &gt;= x) p = <span class="built_in">PR</span>(x);</span><br><span class="line">    <span class="keyword">while</span>((x % p) == <span class="number">0</span>) x /= p;</span><br><span class="line">    <span class="built_in">fac</span>(x),<span class="built_in">fac</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        max_factor=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">fac</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(max_factor == n) <span class="built_in">printf</span>(<span class="string">&quot;Prime\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,max_factor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
      </categories>
  </entry>
  <entry>
    <title>概率DP</title>
    <url>/2020/07/26/2020/probabilitydpqus/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6558">2018CCPC吉林 D The Moon</a></p>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>Python图论绘制库Graphviz小记</title>
    <url>/2020/08/30/2020/pygraphviz/</url>
    <content><![CDATA[<p>话不多说直接上代码，重要的都在注释里．</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Digraph</span><br><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有向图 g = Digraph(name=&quot;photo&quot;,format=&quot;png&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无向图</span></span><br><span class="line"><span class="comment"># name 是名称</span></span><br><span class="line"><span class="comment"># format 是导出文件的格式，默认是pdf</span></span><br><span class="line">g = Graph(name=<span class="string">&quot;photo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># name 是结点的变量名</span></span><br><span class="line"><span class="comment"># label 是显示时候结点的名称，也就是说可以创建两个＂同名＂结点</span></span><br><span class="line"><span class="comment"># color 是描边颜色</span></span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;b1&#x27;</span>, label=<span class="string">&#x27;2&#x27;</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;a&#x27;</span>,label=<span class="string">&#x27;2&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;b&#x27;</span>,label=<span class="string">&#x27;5&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一条边，连接a与b</span></span><br><span class="line"><span class="comment"># label 为线上显示的文本</span></span><br><span class="line"><span class="comment"># color为线的颜色</span></span><br><span class="line">g.edge(<span class="string">&#x27;b1&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,label=<span class="string">&quot;&quot;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;b1&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,label=<span class="string">&quot;&quot;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;c&#x27;</span>, label=<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;d&#x27;</span>, label=<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;e&#x27;</span>,label=<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;f&#x27;</span>,label=<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;g&#x27;</span>,label=<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;h&#x27;</span>,label=<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;i&#x27;</span>,label=<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;j&#x27;</span>,label=<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;k&#x27;</span>,label=<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;l&#x27;</span>,label=<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line">g.node(name=<span class="string">&#x27;m&#x27;</span>,label=<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">g.node(name=<span class="string">&#x27;n&#x27;</span>,label=<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">g.edge(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像 g.view()</span></span><br><span class="line"><span class="comment"># g.view()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图，filename:图片的名称，若无filename，则使用Digraph对象的name，默认会有gv后缀</span></span><br><span class="line"><span class="comment"># directory:图片保存的路径，默认是在当前路径下保存</span></span><br><span class="line">g.view(filename=<span class="string">&quot;mypicture&quot;</span>, directory=<span class="string">&quot;/home/scheng&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后产生的图片文件 <img src="/images/mypicture.png" alt="tournament-tree"></p>
<p>更多详细内容可以参见</p>
<p><a href="https://blog.csdn.net/Edisonleeee/article/details/90214609">地址1</a></p>
<p><a href="https://www.cnblogs.com/Zzbj/p/11431015.html">地址2</a></p>
]]></content>
      <categories>
        <category>disorder</category>
      </categories>
  </entry>
  <entry>
    <title>二次剩余</title>
    <url>/2020/07/08/2020/quad-residue/</url>
    <content><![CDATA[<p>见 <a href="https://oi-wiki.org/math/quad-residue/">二次剩余</a></p>
]]></content>
      <categories>
        <category>math</category>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>强连通分量</title>
    <url>/2020/08/05/2020/sccqus/</url>
    <content><![CDATA[<h2 id="Tarjan-模板"><a href="#Tarjan-模板" class="headerlink" title="Tarjan 模板"></a>Tarjan 模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre[u] = lowlink[u] = ++dfs_clock;</span><br><span class="line">    S.<span class="built_in">push</span>(u);insta[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ( !pre[v] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            lowlink[u] = <span class="built_in">min</span>(lowlink[u], lowlink[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( insta[v] )</span><br><span class="line">        &#123;</span><br><span class="line">            lowlink[u] = <span class="built_in">min</span>( lowlink[u], pre[v] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( lowlink[u] == pre[u] )</span><br><span class="line">    &#123;</span><br><span class="line">        scc_cnt ++;</span><br><span class="line">        <span class="keyword">for</span> ( ;; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();insta[x] = <span class="literal">false</span>;</span><br><span class="line">            sccno[x] = scc_cnt;</span><br><span class="line">            all[scc_cnt] ++;</span><br><span class="line">            <span class="keyword">if</span> ( x == u ) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Garbow-模板"><a href="#Garbow-模板" class="headerlink" title="Garbow 模板"></a>Garbow 模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">garbow</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack1[++p1] = u;</span><br><span class="line">    stack2[++p2] = u;</span><br><span class="line">    low[u] = ++dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!low[v]) <span class="built_in">garbow</span>(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!sccno[v])</span><br><span class="line">            <span class="keyword">while</span>( low[stack2[p2]] &gt; low[v] ) p2 --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( stack2[p2] == u)</span><br><span class="line">    &#123;</span><br><span class="line">        p2 --;</span><br><span class="line">        scc_cnt ++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sccno[stack1[p1]] = scc_cnt;</span><br><span class="line">            <span class="comment">//all_scc[scc_cnt] ++; </span></span><br><span class="line">        &#125; <span class="keyword">while</span>(stack1[p1--] != u) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_scc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs_clock = scc_cnt = <span class="number">0</span>;</span><br><span class="line">    p1 = p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(sccno, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sccno));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(low));</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> ( !low[i] ) <span class="built_in">garbow</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P2341">[USACO03FALL][HAOI2006]受欢迎的牛 G</a></p>
<p><a href="https://codeforces.ml/contest/1249/problem/B2">B2. Books Exchange (hard version)</a></p>
]]></content>
      <categories>
        <category>graphtheory</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>scc</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2020/02/07/2020/search/</url>
    <content><![CDATA[<h2 id="广度优先搜索算法"><a href="#广度优先搜索算法" class="headerlink" title="广度优先搜索算法"></a>广度优先搜索算法</h2><p>广度优先搜索(BFS)之所以如此得名是因为该算法始终是将已发现结点和未发现结点之间的边界, 沿其广度方向向外扩展.即算法需要在发现所有距离源结点s为k的所有结点之后,才会发现距离原点s为k + 1的其他结点.</p>
<p>BFS通常用来解决一些最优化问题,一些经典例子比如迷宫最短路问题,单源最短路等.</p>
<p>对于在图论上的BFS,首先要了解邻接表建图.</p>
<p>struct edge<br>{<br>    int to, next, w;<br>} s[1000];<br>int n, num, head[1000];</p>
<p>void build( int u, int v, int w )<br>{<br>    s[++num].w &#x3D; w;<br>    s[num].next &#x3D; head[u];<br>    s[num].to &#x3D; v;<br>      head[u] &#x3D; num;<br>}</p>
<p>void work()<br>{<br>    int u, v, w;<br>    for ( int i &#x3D; 0; i &lt; n; i ++ )<br>    {<br>        scanf(“%d %d %d”, &amp;u, &amp;v, &amp;w);<br>        build( u, v, w );<br>    }<br>}</p>
<p>用一个</p>
]]></content>
      <categories>
        <category>search</category>
        <category>algorithmanddatastruct</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>区间 DP</title>
    <url>/2020/08/10/2020/sectiondpqus/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a> 经典例题</p>
<p><a href="https://www.luogu.com.cn/problem/P3146">[USACO16OPEN]248 G</a> 模板</p>
<p><a href="https://www.luogu.com.cn/problem/P3147">[USACO16OPEN]262144 P</a> 上一题的优化 dp[i][j] &#x3D; dp[i-1][dp[i-1][j]]; dp[i][j]表示合并到数字是i,左端点是j的右端点的值; 当前i的数据是由i-1合并而来的,那么当前数据i的左端点就是上一次i-1合并的右端点;</p>
<p><a href="https://codeforces.ml/problemset/problem/1336/C">codeforces 1336 C. Kaavi and Magic Spell</a></p>
<p>题解</p>
<p>$f(l,r)$为用$s$的前$r-l+1$个字符拼出$t_{l\dots r}$的方案数; 边界情况:$t_i &#x3D; s_1$,$f(i,i) &#x3D; 2$ 转移:枚举长度为$len$,左边端点为$l$,则$r &#x3D; l + len - 1$. - 当 $s_{len}&#x3D;t_l,f(l,r),$ f(l,r)可由$f(l+1,r)$转移而来 - 当 $s_{len}&#x3D;t_r,f(l,r),$ f(l,r)可由$f(l,r-1)$转移而来</p>
<p>最后答案是$\sum_{i&#x3D;|t|}^{|s|}f(1,i)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line">string ss, tt, s, t;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss = <span class="string">&quot;0&quot;</span>; cin &gt;&gt; s; ss += s;</span><br><span class="line">    tt = <span class="string">&quot;0&quot;</span>; cin &gt;&gt; t; tt += t;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ss &lt;&lt;endl; cout &lt;&lt; tt &lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> m = tt.<span class="built_in">size</span>() - <span class="number">1</span>, n = ss.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) </span><br><span class="line">        dp[i][i] = (ss[<span class="number">1</span>] == tt[i]) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; i ++) dp[i][i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, len = <span class="number">2</span>; i &lt;= n; i ++, len ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len; r &lt;= n; l ++, r ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; m || ss[i] == tt[l])</span><br><span class="line">                dp[l][r] = (dp[l][r] + dp[l+<span class="number">1</span>][r]) % MOD;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; m || ss[i] == tt[r])</span><br><span class="line">                dp[l][r] = (dp[l][r] + dp[l][r<span class="number">-1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m ; i &lt;= n; i ++) ans = (ans + dp[<span class="number">1</span>][i]) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>筛法</title>
    <url>/2020/07/27/2020/shaifa/</url>
    <content><![CDATA[<h2 id="相关教程"><a href="#相关教程" class="headerlink" title="相关教程"></a>相关教程</h2><p><a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演</a> <a href="https://www.cnblogs.com/peng-ym/p/8661118.html">整除分块</a> <a href="https://www.cnblogs.com/peng-ym/p/9446555.html">杜教筛</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P4213">洛谷 P4213 杜教筛模板</a> 莫比乌斯反演 + 杜教筛</p>
<p><a href="https://www.cnblogs.com/peng-ym/p/9446555.html">洛谷 2257 YY的GCD</a> 莫比乌斯反演模板</p>
]]></content>
      <categories>
        <category>maththeory</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
      <tags>
        <tag>sieve</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>SICP第一章-1.3节 部分内容</title>
    <url>/2020/05/24/2020/sicp1_3/</url>
    <content><![CDATA[<p><img src="/images/timg?image&quality=80&size=b9999_10000&sec=1588870556774&di=c6eedad867e852ee890be696cca9bdb6&imgtype=0&src=http://pic1.zhimg.com/50/4d63acf8ef5243bf1dbac5e99341cbf4_hd.jpg"></p>
<h2 id="定积分计算"><a href="#定积分计算" class="headerlink" title="定积分计算"></a>定积分计算</h2><h3 id="定积分近似值的两种计算方法"><a href="#定积分近似值的两种计算方法" class="headerlink" title="定积分近似值的两种计算方法"></a>定积分近似值的两种计算方法</h3><p><strong>1.传统计算公式</strong></p>
<p>[latexpage]</p>
<p>$\int_{a}^{b}f&#x3D;[f(a + \frac{dx}{2}) + f(a + dx  + \frac{dx}{2}) + f(a + 2dx  + \frac{dx}{2})+ …]$</p>
<p>其中dx是一个很小的值,将这个公式描述成一个过程.</p>
<p>(define (cube x) ( * x x x )  )</p>
<p>(define (sum term a next b )<br>    (if ( &gt; a b )<br>        0<br>        ( + ( term a )<br>            ( sum term ( next a ) next b )<br>        )<br>    )<br>)</p>
<p>(define (integral f a b dx )<br>    (define (add-dx x  ) ( + x dx )  )<br>    ( * ( sum f (+ a ( &#x2F; dx 2.0 )) add-dx b ) dx )<br>)</p>
<p>(integral cube 0 1 0.01)</p>
<p><strong>2.辛普森规则</strong></p>
<p><strong>练习1.29</strong></p>
<p>辛普森规则是另一种比上面的传统规则更加精确的数值积分方法.(其证明方法还没找到….)函数f在范围a和b之间的定积分近似值是:</p>
<p>[latexpage]$ \frac{h}{3}[ y_0 + 4y_1+2y_2+4y_3+2y_4+…+2y_{n-2} + 4y_{n-1} + y_n] $</p>
<p>其中$h &#x3D; \frac{b - a}{n}$,n是某个偶数,$y_k &#x3D; f(a+kh)$定义一个具有参数f, a, b和n,采用辛普森规则计算并返回积分值的过程.</p>
<p>(define (cube x) ( * x x x )  )</p>
<p>(define (sum term a next b )<br>    (if ( &gt; a b )<br>        0<br>        ( + ( term a )<br>            ( sum term ( next a ) next b )<br>        )<br>    )<br>)</p>
<p>(define (simpson f a b n)<br>    (define h ( &#x2F; ( - b a ) n ))</p>
<pre><code>(define k a )

(define (next k) ( + k 1 ) )

(define (y k) ( f (+ a ( \* k h ) ) ) )

(define (coefficient k)  
    (cond
        ((or ( = k 0 ) ( = k n )) 1)
        (( even? k ) 2)
        ( else 4 )
    )
)

(define (foo k) ( \* ( coefficient k ) ( y k ) ) )

( \* ( sum foo k next n ) ( / h 3.0 ) )
</code></pre>
<p>)</p>
<p>(simpson cube 0 1.5 100)</p>
<h2 id="函数不动点"><a href="#函数不动点" class="headerlink" title="函数不动点"></a>函数不动点</h2><p>数x称为函数f的不动点,如果x满足方程f(x) &#x3D; x.对于某些函数,通过某个初始猜测出发,反复地应用f</p>
<p>[latexpage]$ f(x), f(f(x)), f(f(f(x)))… $</p>
<p>直到值的变化不大时,就可以找到它的一个不动点.我们可以写出fixed-point的代码.</p>
<p>(define tolerance 0.00001 )</p>
<p>(define (fixed-point f first-guess )<br>    (define (close-enough? v1 v2  )<br>        ( &lt; ( abs ( - v1 v2 ) ) tolerance ))<br>    (define (try guess  )<br>        (let ( (next ( f guess ) ) )<br>            (if ( close-enough? guess next )<br>                next<br>                ( try next )<br>            )<br>        )<br>    )<br>    ( try first-guess )<br>)</p>
<h3 id="求解开平方的两种方法"><a href="#求解开平方的两种方法" class="headerlink" title="求解开平方的两种方法"></a>求解开平方的两种方法</h3><h4 id="平均阻尼法"><a href="#平均阻尼法" class="headerlink" title="平均阻尼法"></a>平均阻尼法</h4><p>[latexpage]计算某个数x的平方根,就是要找到一个y使得$y^2 &#x3D; x$,将这一等式变成另一个等价形式$y &#x3D; \frac{x}{y}$,这里要做的就是寻找函数$y \mapsto \frac{x}{y}$的不动点.但是这个搜索不动点的过程不会收敛.从初始猜测$y_1$开始,下一个猜测$y_2&#x3D; \frac{x}{y_1}$,而再下一个猜测是$y_3 &#x3D; \frac{x}{y_2}&#x3D;\frac{x}{\frac{x}{y_1}}&#x3D;y_1$.结果就是进入了一个无限循环,没完没了地重复$y_1$,$y_2$.</p>
<p>[latexpage]这时将$y &#x3D; \frac{x}{y}$变形为$ y &#x3D; \frac{1}{2} ( y + \frac{x}{y} ) $,那么下一个猜测的值就是$\frac{1}{2} ( y + \frac{x}{y} ) $,而不是$\frac{x}{y}$,做出这种猜测序列的计算过程也就是搜寻$y \mapsto \frac{1}{2} ( y + \frac{x}{y} )$的不动点.</p>
<p><strong>使用scheme编写的平均阻尼法求平方及立方的代码</strong></p>
<p>(define (average a b ) ( &#x2F; ( + a b ) 2 ))</p>
<p>( define tolerance 0.00001 )</p>
<p>(define (average-damp f )<br>    (lambda (x) ( average x ( f x ) )  )<br>)</p>
<p>(define (fixed-point f first-guess )<br>    (define (close-enough? v1 v2  )<br>        ( &lt; ( abs ( - v1 v2 ) ) tolerance ))<br>    (define (try guess  )<br>        (let ( (next ( f guess ) ) )<br>            (if ( close-enough? guess next )<br>                next<br>                ( try next )<br>            )<br>        )<br>    )<br>    ( try first-guess )<br>)</p>
<p>(define (sqrt x )<br>    (fixed-point (average-damp (lambda (y) ( &#x2F; x y ) ) ) 1.0 )<br>)</p>
<p>(define (cube-root x )<br>    (fixed-point (average-damp (lambda (y) ( &#x2F; x ( square y ) ) ) ) 1.0 )<br>)</p>
<p>( cube-root 27 )</p>
<p>更多内容可见:<a href="https://scheng52123.com/index.php/2020/05/24/averagedamp/">平均阻尼法</a></p>
<h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p><a href="https://scheng52123.com/index.php/2020/05/23/newtonmethod/">牛顿迭代法</a></p>
<p><strong>练习1.40</strong></p>
<p>[latexpage]定义一个cubic,使用牛顿迭代法计算三次方程$x^3 + ax^2+c$的零点</p>
<p>(define (cubic a b c )<br>    (lambda (x)  ( + (cube x) ( * a ( square x ) ) ( * b x ) c ) )<br>)</p>
<p><strong>练习1.31</strong>计算圆周率</p>
<p>[latexpage]按照下面公式计算$\pi$的近似值.</p>
<p>$\frac{\pi}{4} &#x3D; \frac{2 * 4 * 4 * 6 * 6 *8…}{3 * 3 * 5 * 5 * 7 * 7…}$</p>
<p>先将这个式子进行一次变形,分子分母的每次增量就对称了.</p>
<p>$\frac{\pi}{8} &#x3D; \frac{ 4 * 4 * 6 * 6 *8…}{3 * 3 * 5 * 5 * 7 * 7…}$</p>
<p>(define (product term a next b )<br>    (if ( &gt; a b )<br>        1<br>        (* ( term a )<br>            ( product term ( next a ) next b )<br>        )<br>    )<br>)</p>
<p>(define (product2 term a next b)<br>    (define (iter a ans)<br>        (if ( &gt; a b )<br>            ans<br>            ( iter ( + a 1 ) ( * ( term a ) ans ) )<br>        )<br>    )<br>    ( iter a 1 )<br>)</p>
<p>(define ( multi a b )<br>    (define (itself a) a)<br>    (define (multi-next a) ( + a 1 ))<br>    ( product itself a multi-next b)<br>)</p>
<p>(define ( pi n )<br>    (define (term-up x )<br>        (cond ( ( &#x3D; x 1 ) 1 )<br>            ( ( even? x ) ( + x 2) )<br>            ( else ( + x 1 ) )<br>        )<br>    )</p>
<pre><code>(define (term-down x )
    (cond (( = x 1 ) 3)
        ( ( even? x ) ( + x 1 ) )
        (else  ( + x 2 ) )
    )
)
(define (next x ) ( + x 1 ) )
(  \* ( exact-&gt;inexact ( / ( product2 term-up 1 next n )
                    ( product2 term-down 1 next n ) )) 8)
</code></pre>
<p>)</p>
<p>( pi 1000 )</p>
<p><strong>练习1.43</strong></p>
<p>写一个过程,它的输入是一个计算f的过程和一个正整数n,返回的是能计算f的n次重复应用的那个函数.</p>
<p>这里的解法是基于<strong>练习1.42</strong>的,scheme能够将过程作为返回值,再一次使我见识到了这个语言神奇的地方.</p>
<p>(define (compose f g )<br>    (lambda (x)<br>        ( f ( g x ) )<br>    )<br>)</p>
<p>(define (square x ) ( * x x ))</p>
<p>(define (repeated f n )<br>    (if ( &#x3D; n 1 )<br>        ;(lambda (x) (f x))<br>        f<br>        (lambda (x) (<br>            f ( (repeated<br>                    f<br>                     (- n 1)<br>                )<br>              x )))<br>    )<br>)</p>
<p>(define (repeated1 f n )<br>    (define (iter a g )<br>        (if ( &#x3D; a n )<br>            g<br>            (lambda (x) ( f ( g x ) ) )<br>        )<br>    )<br>    ( iter 1 f )<br>)</p>
<p>(define (repeated2 f n )<br>    (if ( &#x3D; n 1 )<br>        f<br>        (<br>            compose f ( repeated2 f ( - n 1 ) )<br>        )<br>    )<br>)</p>
<p>(define (repeated3 f n )<br>    (define (iter a g )<br>        (if ( &#x3D; a n )<br>            g<br>            ( compose g ( iter ( + a 1 ) g ) )<br>        )<br>    )<br>    ( iter 1 f )<br>)</p>
<p>( (repeated3 square 2 ) 5 )</p>
]]></content>
      <categories>
        <category>sicp</category>
        <category>book</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>sicp</tag>
      </tags>
  </entry>
  <entry>
    <title>SICP第一章-1.2节 部分笔记</title>
    <url>/2020/05/09/2020/sicp_1_2/</url>
    <content><![CDATA[<p><img src="/images/timg?image&quality=80&size=b9999_10000&sec=1588870556774&di=c6eedad867e852ee890be696cca9bdb6&imgtype=0&src=http://pic1.zhimg.com/50/4d63acf8ef5243bf1dbac5e99341cbf4_hd.jpg"></p>
<h2 id="增长的阶"><a href="#增长的阶" class="headerlink" title="增长的阶"></a>增长的阶</h2><p><strong>练习1.15  b)</strong> 在求值( sine a )时,由过程$sine$所产生的计算过程使用的空间和增长的阶是什么?</p>
<p>(define(cube x) ( * x x x ))</p>
<p>(define( p x ) ( - ( * 3 x ) ( * 4 ( cube x ) ) ))</p>
<p>(<br>    define( sine _angle )<br>    (<br>        if ( not ( &gt; ( abs _angle ) 0.1 ) )<br>        _angle<br>        ( p ( sine ( &#x2F; _angle 3.0 ) ) )<br>    )<br>)</p>
<p>根据<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AE%9A%E7%90%86/3463232?fr=aladdin">主定理</a>分析, $T(n) &#x3D; aT( \frac{b}{n} )+ f(n) $ 其中$a &#x3D; 1, b &#x3D; 3, f(n) &#x3D; \Theta ( 1 )$</p>
<p>符合主定理的第二条,若$ f(n) &#x3D; \Theta( n ^ \log_b a ) $, 那么$T( n ) &#x3D; \Theta( {n ^ \log_b a} log n )$</p>
<p>$ \log_b a &#x3D; \log_3 1 &#x3D; 0$ $\therefore $ $T( n ) &#x3D; \Theta( {n ^ \log_b a} log n ) &#x3D; \Theta( log n ) $</p>
<p>因此计算sine增长的阶是$\Theta(log n)$</p>
<p><strong>练习1.26</strong> 将原( expmod )的算法更改了一下,时间复杂度发生了改变,由O(log n)变成了O( n ),试分析两个算法的时间复杂度.原算法在下文的<strong>快速幂取模</strong>.以下是更改后的代码.</p>
<p>(define (expmod base exp m)<br>    (<br>        cond ( ( &#x3D; exp 0 ) 1 )<br>            ( (even? exp)<br>            ( remainder (  * ( expmod base ( &#x2F; exp 2 ) m )<br>                             ( expmod base ( &#x2F; exp 2 ) m )<br>                        ) m ))<br>            (<br>                else ( remainder ( * base ( expmod base ( - exp 1 ) m ) ) m )<br>            )<br>    )<br>)</p>
<p>[latexpage]</p>
<p>原算法的递推关系式是$T( n ) &#x3D; T( \frac{n}{2} ) + \Theta( 1 )$ , 根据主定理计算出算法的时间复杂度为$ \Theta( log n ) $</p>
<p>更改后的递推关系式是$T( n ) &#x3D; 2T( \frac{n}{2} ) + \Theta( 1 )$, 根据主定理计算出算法的时间复杂度为$ \Theta( n ) $</p>
<p>看上去是相同的计算实际上square(x)将计算减少了很多</p>
<h2 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h2><h3 id="朴素幂运算"><a href="#朴素幂运算" class="headerlink" title="朴素幂运算"></a>朴素幂运算</h3><p>$ b^n &#x3D; b * b ^ {n - 1} $</p>
<p>$ b ^ 0 &#x3D; 1 $</p>
<p>可以直接翻译为以下过程</p>
<p>(<br> define ( expt b n )<br> ( if ( &#x3D; n 0 )<br>   1<br>   ( * b ( expt b ( - n 1 ) ) )<br>   )<br>)</p>
<p>这是一个线性的递归计算过程,需要$\Theta (n)$的空间( 因为递归运算的堆栈需要空间 )以及</p>
<p>$ \Theta (n) $的时间.</p>
<p>一个将空间优化为$ \Theta(1) $ 的迭代版本</p>
<p>(<br>    define ( expt2 b n )<br>    ( expt_iter b n 1 )<br>)</p>
<p>(<br>    define ( expt_iter b counter product )<br>    (<br>        if ( &#x3D; counter 0 )<br>        product<br>        (<br>            expt_iter b ( - counter 1 ) ( * b product )<br>        )<br>    )<br>)</p>
<h3 id="快速幂运算"><a href="#快速幂运算" class="headerlink" title="快速幂运算"></a>快速幂运算</h3><p>在计算$b ^ 8$时可以通过连续求平方,以更少的步骤完成幂运算.例如,在朴素幂运算下$ b ^ 8 $:</p>
<p>$ b ^ 8 &#x3D; b * ( b * ( b * ( b * ( b * ( b * ( b * b ) ) ) ) ) ) $</p>
<p>用连续求平方:</p>
<p>$ b ^ 2 &#x3D; b * b $</p>
<p>$ b ^ 4 &#x3D; b ^ 2 * b ^ 2 $</p>
<p>$ b ^ 8 &#x3D; b ^ 4 * b ^ 4 $</p>
<p>连续求平方发的一般乘幂计算:</p>
<p>$ b ^ n &#x3D; ( b ^ {n &#x2F; 2} ) $, 若n是偶数</p>
<p>$ b ^ n &#x3D; b * b ^ { n - 1 } $, 若n是奇数</p>
<p>将这个方法定义成以下过程:</p>
<p>(<br>    define ( fast_expt b n )<br>    (<br>        cond ( ( &#x3D; n 0 ) 1 )<br>        ( ( is_even n ) ( square ( fast_expt b ( &#x2F; n 2 ) )) )<br>        ( else ( * b ( fast_expt b ( - n 1 ) ) ) )<br>    )<br>)</p>
<p>(define ( square n )( * n n ))</p>
<p>(define ( is_even n )( &#x3D; ( remainder n 2 ) 0))</p>
<p>时间复杂度为$\Theta ( log n )$</p>
<p><strong>练习1.16</strong> 利用关系$ ( b ^ { n &#x2F; 2 } ) ^ 2 &#x3D; ( b ^ 2 ) ^ { n &#x2F; 2 } $将上面的快速幂算法改成按照迭代方式的求幂计算.</p>
<p>(<br>    define ( fast_expt b n  )<br>    ( fast_expt_iter b n 1 )<br>)</p>
<p>(<br>    define ( fast_expt_iter b counter product )<br>    (<br>        cond ( ( &#x3D; counter 0 ) product )<br>        ( ( is_even counter  ) (  fast_expt_iter ( square b ) ( &#x2F; counter 2 ) product ))<br>        ( else ( fast_expt_iter b ( - counter 1 ) ( * product b ) ) )<br>    )<br>)</p>
<p>除了基数b和指数n之外,还有一个附加的状态变量a(上面的代码是product),并定义好状态变换,使得从一个状态到另一个状态时乘积$ a b ^ n $不变.在计算过程开始时a取1,并用计算过程结束时a的值作为回答.一般说,定义一个不变量,要求它在状态之间保持不变,这一技术是思考迭代算法设计问题时的一种强有力的方法.</p>
<h3 id="俄罗斯农夫算法"><a href="#俄罗斯农夫算法" class="headerlink" title="俄罗斯农夫算法"></a>俄罗斯农夫算法</h3><p><strong>练习1.18</strong> 利用反复加法的方式求出乘积.</p>
<p>(<br> define ( * a b )<br> (<br>  if ( &#x3D; b 0 )<br>      0<br>      ( + a ( * a ( - b 1 ) ) )<br>  )<br> )</p>
<p>这是一个线性算法,在<strong>练习1.17</strong>中要求将其优化为对数复杂度的算法,并且使用double和halve两个方法;在<strong>练习1.18</strong>中要求再改为迭代计算过程.</p>
<p><em><strong>练习1.17</strong></em></p>
<p>( define (double x)( * x 2 ) )</p>
<p>( define ( halve y ) ( &#x2F; y 2 ) )</p>
<p>( define (is_even n) ( &#x3D; ( remainder n 2 ) 0 ))</p>
<p>(<br>    define ( fast_mul1 a b  )<br>    (<br>        cond ( ( &#x3D; b 0 ) 0)<br>        ( ( is_even b ) ( double ( fast_mul1 a ( halve b ) ) ) )<br>        ( else ( + a (fast_mul1 a ( - b 1 ) ) ) )<br>    )<br>)</p>
<p><strong>练习1.18</strong></p>
<p>(<br>    define ( fast_mul a b )<br>    ( fast_mul_iter a b 0  )<br>)</p>
<p>;Russian farmer algorithm<br>(<br>    define ( fast_mul_iter a b product )<br>    (<br>        cond ( ( &#x3D; b 0 ) product)<br>        ( ( is_even b ) ( fast_mul_iter ( double a ) ( halve b ) product ) )<br>        ( else ( fast_mul_iter a ( - b 1 ) ( + product a ) ) )<br>    )<br>)</p>
<p>这里的$product$就是附加的状态变量,也是最后要输出的答案.</p>
<p>有一个乘法表达式:$ans &#x3D; a * b$</p>
<p>当b为奇数时 $ ans &#x3D; a * b_1 + c_1, b_1 &#x3D; ( b - 1 ), c_1 &#x3D; a$并将$c_1$累加到$product$上</p>
<p>当b为偶数时$ ans &#x3D; (a * 2) * ( b &#x2F; 2 ) $, 这时b的状态就有可能会改变</p>
<p>当b为0时,就可以输出$product$了</p>
<p>这一算法又被称为”俄罗斯农夫算法”</p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="朴素斐波那契函数"><a href="#朴素斐波那契函数" class="headerlink" title="朴素斐波那契函数"></a>朴素斐波那契函数</h3><p>根据斐波那契数列的定义:</p>
<p>[latexpage]</p>
<p>$Fib( x )&#x3D; \begin{cases} 0, &amp;x &#x3D; 0 \cr 1, &amp; x &#x3D;1 \cr Fib( x - 1 ) + Fib( x - 2 ) , &amp; x &gt; 1 \end{cases}$</p>
<p>将这个过程翻译为一个计算斐波那契数的递归过程</p>
<p>(<br> define ( fib n )<br> (<br>  cond (( &#x3D; n 0 ) 0 )<br>          ( ( &#x3D; n 1 ) 1 )<br>          ( else ( + ( fib ( - n 1 ) )<br>                 ( fib ( - n 2 ) ))<br>        )<br>     )<br> )</p>
<p>但是这个过程有太多的冗余计算,时间复杂度可以说是一个指数级别的.</p>
<p>$ Fib(n) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5} $</p>
<h3 id="迭代的斐波那契函数"><a href="#迭代的斐波那契函数" class="headerlink" title="迭代的斐波那契函数"></a>迭代的斐波那契函数</h3><p>用一对整数a和b将它们分别初始化为$ Fib(1) &#x3D; 1 $ 和$ Fib(0) &#x3D; 0 $,然后反复同时使用下面的变换规则:</p>
<p>$ a \leftarrow a + b $</p>
<p>$ b \leftarrow a $</p>
<p>不难证明在$n$次这些变换后,a和b将分别等于Fib( n + 1 ) 和 Fib( n ), 将其翻译为下面过程:</p>
<p>( define ( fib2 n )<br>    ( fib_iter 1 0 n)<br>)</p>
<p>( define ( fib_iter a b count )<br>    (if ( &#x3D; count 0 )<br>        b<br>        ( fib_iter ( + a b ) a ( - count 1 ) )<br>    )<br>)</p>
<p>另外两种优化思路是(不再贴出代码):</p>
<p>1.使用记忆化搜索</p>
<p>2.递推方法,用数组记录fib[0] &#x3D; 0, fib[1] &#x3D; 1, 并递推fib[i] &#x3D; fib[i - 1] + fib[i - 2].</p>
<p>[latexpage]</p>
<p><em><strong>练习1.13</strong></em> 证明$Fib( n ) $是最接$\frac{\phi ^ n }{\sqrt 5}$的整数，其中$\phi &#x3D; \frac{1 + \sqrt 5 }{2}$，证明$ Fib(n) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5} $</p>
<p>先证明$ Fib(n) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5} $</p>
<p>令$A(n) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5}$</p>
<p>$Fib(1) &#x3D; 1$ $A(1) &#x3D; 1$ $ Fib(1) &#x3D; A(1) $</p>
<p>$Fib(2) &#x3D; 1$ $A(1) &#x3D; 1$ $ Fib(2) &#x3D; A(2) $</p>
<p>设当$k &#x3D; n $时有$ Fib(n) &#x3D; A(n) $，则当$k &#x3D; n + 1$时有</p>
<p>$Fib(n + 1) &#x3D; Fib( n ) + Fib(n - 1)$</p>
<p>$Fib( n ) &#x3D; A(n) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5}$</p>
<p>$Fib( n - 1 ) &#x3D; A( n - 1 ) &#x3D; \frac{ \phi ^ {n - 1} - \gamma ^ {n - 1}}{\sqrt 5}$</p>
<p>则有 $Fib( n ) + Fib(n - 1) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5} + \frac{ \phi ^ {n - 1} - \gamma ^ {n - 1}}{\sqrt 5} $ $&#x3D; \frac{\phi ^ n( 1 + \frac{1}{\phi} ) - \gamma ^ n( 1 + \frac{1}{\gamma } )}{\sqrt 5}$</p>
<p>其中 $ 1 + \frac{1}{\phi ^ n} &#x3D; \frac{3 + \sqrt 5}{1 + \sqrt 5}  &#x3D;  \frac{(3 + \sqrt 5)(1 - \sqrt5)}{(1 + \sqrt5)( 1 - \sqrt 5 )}  &#x3D; \frac{1 + \sqrt 5}{2} &#x3D; \phi$</p>
<p>          $ 1 + \frac{1}{\gamma ^ n} &#x3D; \frac{3 - \sqrt 5}{1 - \sqrt 5}  &#x3D;  \frac{(3 - \sqrt 5)(1 + \sqrt5)}{(1 - \sqrt5)( 1 + \sqrt 5 )}  &#x3D; \frac{1 - \sqrt 5}{2} &#x3D; \gamma$</p>
<p>则 $Fib( n ) + Fib(n - 1) &#x3D; \frac{\phi ^ {n + 1} - \gamma ^ { n + 1 }}{\sqrt 5} &#x3D; A(n+1)$</p>
<p>$ \therefore Fib(n + 1) &#x3D; A(n+1)$</p>
<p>$ \therefore Fib(n) &#x3D; \frac{ \phi ^ n - \gamma ^ n}{\sqrt 5} $</p>
<p>这个证明也可以用特征根方程来证明,这里不再赘述.</p>
<p>$| {Fib(n) - \frac{\phi}{\sqrt 5} | &#x3D; | \frac{\gamma ^ n}{\sqrt 5} |$</p>
<p>其中 $| \gamma | &#x3D; | \frac{1 - \sqrt 5}{2} | &lt; 1$</p>
<p>          $ | \gamma ^ 2 | &lt; 1 $</p>
<p>          $ | \frac{\gamma ^ 2}{\sqrt 5} | &lt;, 0.5$</p>
<p>$ \therefore $ $ Fib( n )$ 是最接 $\frac{\phi ^ n }{\sqrt 5}$ 的整数</p>
<p><strong>练习1.19</strong></p>
<p>[latexpage]</p>
<p>主要是求出$p_1$和$q_1$ ,题目说的操作两次$T_{pq}$相当于操作一次$T_{p’q’}$</p>
<p>其中$T_{pq}$是对于对偶$(a,b)$按照如下的规则变化</p>
<p>$a \leftarrow bq + aq + ap$</p>
<p>$ b \leftarrow bp + aq $</p>
<p>对$T_{pq}$操作两次有</p>
<p>$a_1 &#x3D; bq + a( p + q )$</p>
<p>$ b_1 &#x3D; bp + aq $</p>
<p>$ a_2 &#x3D; b_1 q + a_1 ( p + q ) &#x3D; ( b1 + aq ) q + ( bq + a ( p + q )( p + q ) )$</p>
<p>         $&#x3D; b( 2pq + q^2 ) + q( p ^2 + 2 p ^2 + 2pq )$</p>
<p>其中$ q_1 &#x3D; 2pq + q^2 $         $ p_1 &#x3D; p ^ 2 + q ^2 $</p>
<p>$ b_2 &#x3D; b_1 q + a_1 q &#x3D; ( bp + aq ) p + ( bq + a( p + q ) ) q &#x3D; b( p^2 + q^2 ) + a( 2pq + p^2 )$</p>
<p>这里$b_2$求出的$q_1$和$p_1$可以作为一个验证.</p>
<p>$\therefore $ $ q_1 &#x3D; 2pq + q^2 $         $ p_1 &#x3D; p ^ 2 + q ^2 $</p>
<p>然后贴出代码</p>
<p>(define (fib n )<br>    ( fib_iter 1 0 0 1 n )<br>)</p>
<p>(define (even? n ) ( &#x3D; ( remainder n 2 ) 0 ) )</p>
<p>(define (square x ) ( * x x ) )</p>
<p>(define (fib_iter a b p q count )<br>    (<br>        cond( ( &#x3D; count 0 ) b )<br>            ( ( even? count )<br>                ( fib_iter a<br>                           b<br>                            ( + ( square p) (square q) )<br>                            ( + ( * 2 p q ) ( square q ) )<br>                            ( &#x2F; count 2 )<br>                )<br>            )<br>            (<br>                else ( fib_iter ( + ( * b q ) ( * a q ) ( * a p ) )<br>                        ( + ( * b p ) ( * a q ) )<br>                        p<br>                        q<br>                        ( - count 1 )<br>                )<br>            )<br>    )<br>)</p>
<h2 id="最大公约数的Lame定理"><a href="#最大公约数的Lame定理" class="headerlink" title="最大公约数的Lame定理"></a>最大公约数的Lame定理</h2><p>如果欧几里得算法需要用k步计算出一对整数的GCD,那么这对数中较小的那个数必然大于或者等于第k个斐波那契数.</p>
<p>[latexpage]考虑数对序列$( a_k, b_k )$,其中$a_k \geq b_k$, 假设欧几里得算法在第k步结束.</p>
<p>如果$ ( a_{k+1}, b_{k+1} ) \rightarrow ( a_{k}, b_{k} ) \rightarrow ( a_{k-1}, b_{k-1} )$是归约序列中连续的三个数对,必然有$ b_{k + 1} \geq b_k + b_{k - 1} $.这里的每个归约步骤都是通过应用变换$ a_{k-1} &#x3D; b_k $,   $ b_{ k - 1 } &#x3D; a_{k}$除以$ b_k $的余数.</p>
<p>$ a_k &#x3D; q b_k + b{ k - 1 } $ 其中$ q \geq 1 $所以有 $ a_k &#x3D; q b_k + b_{k - 1}  \geq b_k + b_{ k - 1 }$,在前一个归约步骤中有$ b_{ k + 1 } &#x3D; a_k $, 因此 $b_{k + 1} &#x3D; a_k &#x3D; q b_k + b_{ k - 1 }  \geq b_k + b_{ k - 1 }$</p>
<p>要证明$ b_k \geq Fib(k) $, 一定有$ b_1 \geq Fib(1) &#x3D; 1 $</p>
<p>设$ b_{ k } \geq Fib(k) $</p>
<p>     $ b_{ k - 1 } \geq Fib(k - 1) $.</p>
<p>则 $b_{ k } +b_{ k- 1} \geq Fib(k) + Fib(k - 1)$</p>
<p>$ \because b_{k + 1} \geq b_k + b_{ k - 1 } \geq Fib(k) + Fib(k - 1) $</p>
<p>$ \therefore  b_{k + 1} \geq Fib( k + 1 )$</p>
<p>$ \therefore  b_k \geq Fib(k)$</p>
<h2 id="素数检测"><a href="#素数检测" class="headerlink" title="素数检测"></a>素数检测</h2><p>[latexpage]提供两种素数检测方法,第一种具有$\Theta ( \sqrt n )$的增长阶, 另一个是运用费马小定理的概率算法,具有$\Theta ( log n )$的增长阶.</p>
<h3 id="传统素数检测方法"><a href="#传统素数检测方法" class="headerlink" title="传统素数检测方法"></a>传统素数检测方法</h3><p>[latexpage]通过枚举2到$ \sqrt(n) $的所有整数来验证n是否为素数.<strong>时间复杂度为$\Theta ( \sqrt n )$</strong></p>
<p>(define ( smallest_divisor n ) ( find_divisor n 2 ))</p>
<p>(define ( square x ) ( * x x ) )</p>
<p>( define ( find_divisor n test_divisor )<br>    (cond ( ( &gt; ( square test_divisor ) n  ) n )<br>          ( ( divides? test_divisor n  ) test_divisor )<br>          ( else ( find_divisor n ( + test_divisor 1 ) ) )<br>    )<br>)</p>
<p>(define ( divides? a b ) ( &#x3D; ( remainder b a ) 0 ))</p>
<p>(define ( prime? n )<br>    ( &#x3D; n ( smallest_divisor n ) )<br>)</p>
<h3 id="费马检查"><a href="#费马检查" class="headerlink" title="费马检查"></a>费马检查</h3><p>[latexpage]<strong>费马小定理</strong>:如果n是一个素数,a是小于n的任意正整数,那么a的n次方与a模n同余.(更多详细内容可见<a href="https://scheng52123.com/index.php/2020/03/13/mod/">费马小定理</a>)对于给定的整数n, 随机任取一个$a &lt; n$ 计算出$ a^n $取模n的余数.如果结果不等于a,那么n就肯定不是素数;如果结果等于a,那么n就有<strong>很大可能</strong>是素数.检查的a越多,那么n是素数的可能性也就越大,也存在一些数据能够欺骗费马检查,所以综上这是一个概率算法.</p>
<p>要完成费马检查需要先写一个快速幂取模的过程.</p>
<h4 id="快速幂取模"><a href="#快速幂取模" class="headerlink" title="快速幂取模"></a>快速幂取模</h4><p>快速幂取模基于以下定理</p>
<p>[latexpage]$(a * b) \% c&#x3D; ( a \% c ) * ( b \% c ) \% c $</p>
<p>[latexpage]可以将一个大数分成几部分来求模以达到快速运算的目的,这个过程类似之前的fast-exp过程.其增长的阶是$ \Theta( log n ) $.</p>
<p>费马检查的代码</p>
<p>(define (square x ) ( * x x ) )</p>
<p>(define (expmod base exp m)<br>    (<br>        cond ( ( &#x3D; exp 0 ) 1 )<br>            ( (even? exp)<br>            ( remainder ( square ( expmod base ( &#x2F; exp 2 ) m ) ) m ))<br>            (<br>                else ( remainder ( * base ( expmod base ( - exp 1 ) m ) ) m )<br>            )<br>    )<br>)</p>
<p>(define (fermat_test n )<br>    (define (try_it a )<br>        ( &#x3D; ( expmod a n n ) a )<br>    )<br>    ( try_it ( + 1 ( random( - n 1 ) ) ) )<br>)</p>
<p>(define (fast_prime? n times)<br>    (<br>        cond( ( &#x3D; times 0 ) true )<br>            ( ( fermat_test n ) ( fast_prime? n ( - times 1 ) ) )<br>            ( else false )<br>    )<br>)</p>
<p>能够欺骗费马检查的数成为_Carmichael_数,其中最小的只有561,在练习1.28中提供了一种优化过的不会被欺骗的费马检查.以下是对561进行费马检查的中间生成数据,看看它是如何欺骗费马检查的.</p>
<p>exp &#x3D; 1         * &#x3D; 3                   mod &#x3D; 3<br>exp &#x3D; 2         squared &#x3D; 9             mod &#x3D; 9<br>exp &#x3D; 4         squared &#x3D; 81            mod &#x3D; 81<br>exp &#x3D; 8         squared &#x3D; 6561          mod &#x3D; 390<br>exp &#x3D; 16        squared &#x3D; 152100        mod &#x3D; 69<br>exp &#x3D; 17        * &#x3D; 207                 mod &#x3D; 207<br>exp &#x3D; 34        squared &#x3D; 42849         mod &#x3D; 213<br>exp &#x3D; 35        * &#x3D; 639                 mod &#x3D; 78<br>exp &#x3D; 70        squared &#x3D; 6084          mod &#x3D; 474<br>exp &#x3D; 140       squared &#x3D; 224676        mod &#x3D; 276<br>exp &#x3D; 280       squared &#x3D; 76176         mod &#x3D; 441<br>exp &#x3D; 560       squared &#x3D; 194481        mod &#x3D; 375<br>exp &#x3D; 561       * &#x3D; 1125                mod &#x3D; 3</p>
<h3 id="Miller-Rabin检查"><a href="#Miller-Rabin检查" class="headerlink" title="Miller-Rabin检查"></a>Miller-Rabin检查</h3><p>[latexpage]费马检查的一种不会被欺骗的变形成为Miller-Rabin检查,来源与费马小定理的一个变形. 如果n是素数,a是小于n的整数,则a的( n - 1 )次幂与1模n同余.这个算法需要查看是否遇到了”1取模的非平凡平方根”,也就是说,是不是存在不等于1或者n-1的数使平方取模等于1.如果1取模的非平凡平方根存在,那么n就不是素数.并且,如果n是非素数的奇数,至少有一半的数a &lt; n 按照这种方式计算$a^{ n - 1 }$,将会遇到1取模n的非平凡平方根.</p>
<p>[latexpage] Miller-Rabin检查基于的定理: 如果p是素数，x是小于p的正整数，且$x^2$ mod p &#x3D; 1，那么要么x&#x3D;1，要么x&#x3D;p-1。这是显然的，因为$x^2$ mod p &#x3D; 1相当于p能整除$x^2$-1，也即p能整除(x+1)(x-1)。由于p是素数，那么只可能是x-1能被p整除(此时x&#x3D;1)或x+1能被p整除(此时x&#x3D;p-1)。</p>
<p><strong>练习1.28</strong> 编写Miller-Rabin检查</p>
<p>(define (square x ) ( * x x ) )</p>
<p>(define (Miller_Rabin base exp m  )<br>    (<br>        cond( ( &#x3D; exp 0 ) 1)<br>            ( ( square_check base m ) 0)<br>            ( ( even? exp ) ( remainder ( square ( Miller_Rabin base ( &#x2F; exp 2 ) m ) ) m ) )<br>            (else<br>                (remainder  ( Miller_Rabin base ( - exp 1 ) m ) m)<br>            )<br>    )<br>)</p>
<p>(define (square_check a n )<br>    (<br>        and ( not ( &#x3D; a 1 ) )<br>            ( not ( &#x3D; a ( - n 1 ) ) )<br>            ( &#x3D; 1 ( remainder ( square a ) n ) )<br>    )<br>)</p>
<p>(define (Miller_Rabin_test n )<br>    (define (try_it a )<br>        ( &#x3D; ( Miller_Rabin a n n ) a )<br>    )<br>    ( try_it ( + 1 ( random( - n 1 ) ) ) )<br>)</p>
<p>(define (fast_prime? n times)<br>    (<br>        cond( ( &#x3D; times 0 ) true )<br>            ( ( Miller_Rabin_test n ) ( fast_prime? n ( - times 1 ) ) )<br>            ( else false )<br>    )<br>)</p>
<p>Miller_Rabin方法参考的文章:<a href="http://www.matrix67.com/blog/archives/234">http://www.matrix67.com/blog/archives/234</a></p>
]]></content>
      <categories>
        <category>sicp</category>
        <category>book</category>
        <category>maththeory</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>sicp</tag>
        <tag>maththeory</tag>
        <tag>gcd</tag>
        <tag>fastexp</tag>
        <tag>fib</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/02/03/2020/stack1/</url>
    <content><![CDATA[<p>栈是一种动态集合,栈的实现是一种<strong>后进先出</strong>策略,其中被删除的是最近插入的元素.</p>
<h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作:"></a>栈的操作:</h2><ol>
<li>判断栈是否为空</li>
<li>将一个元素压人(push)栈</li>
<li>将一个元素弹出(pop)栈</li>
<li>返回栈顶元素</li>
<li>清空栈</li>
</ol>
<blockquote>
<p>一个有趣的笑话:问一个人PUSH的反义词是什么.回答PULL的是普通人,而回答POP的才是程序员.</p>
<p>刘汝佳紫书</p>
</blockquote>
<h2 id="用c-手写一个栈"><a href="#用c-手写一个栈" class="headerlink" title="用c++手写一个栈:"></a>用c++手写一个栈:</h2><p>#include &lt;bits&#x2F;stdc++.h&gt;<br>#define N 100000<br>using namespace std;</p>
<p>int stk[N];<br>int point;</p>
<p>bool stack_empty()<br>{<br>    if ( point &#x3D;&#x3D; 0 ) return true;<br>    return false;<br>}</p>
<p>void stack_push( int num )<br>{<br>    point ++;<br>    stk[point] &#x3D; num;<br>}</p>
<p>void stack_pop()<br>{<br>    if ( stack_empty() ) printf(“underflow\n”);<br>    else point –;<br>}</p>
<p>int stack_top()<br>{<br>    return stk[point];<br>}</p>
<p>void stack_clear()<br>{<br>    point &#x3D; 0;<br>}</p>
<p>int main()<br>{<br>    point &#x3D; 0;<br>    int n;<br>    scanf(“%d”,&amp;n);<br>    int cmd, num;<br>    &#x2F;&#x2F;对一个栈进行n次操作<br>    &#x2F;&#x2F;0压 1弹 2返回栈顶<br>    stack_clear();<br>    for ( int i &#x3D; 0; i &lt; n; i ++ )<br>    {<br>        scanf(“%d”,&amp;cmd);<br>        if ( cmd &#x3D;&#x3D; 0 )<br>        {<br>            scanf(“%d”,&amp;num);<br>            stack_push(num);<br>        }<br>        else if ( cmd &#x3D;&#x3D; 1 ) stack_pop();<br>        else if ( cmd &#x3D;&#x3D; 2 )<br>        {<br>            int item &#x3D; stack_top();<br>            printf(“%d\n”,item);<br>        }<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<h2 id="在STL中的栈"><a href="#在STL中的栈" class="headerlink" title="在STL中的栈"></a>在STL中的栈</h2><ul>
<li>stack<int> stk;声明一个栈</li>
<li>stk.empty();判断栈是否为空</li>
<li>stk.push(num);将num压入栈</li>
<li>stk.pop();弹出一个元素</li>
<li>stk.top();返回栈顶元素</li>
<li>stk.size();返回当前栈内元素个数</li>
</ul>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>stack<int> stk;</p>
<p>int main()<br>{<br>    int n;<br>    scanf(“%d”,&amp;n);<br>    int cmd, num;<br>    &#x2F;&#x2F;对一个栈进行n次操作<br>    &#x2F;&#x2F;0压 1弹 2返回栈顶<br>    while ( !stk.empty() ) stk.pop();<br>    for ( int i &#x3D; 0; i &lt; n; i ++ )<br>    {<br>        scanf(“%d”,&amp;cmd);<br>        if ( cmd &#x3D;&#x3D; 0 )<br>        {<br>            scanf(“%d”,&amp;num);<br>            stk.push(num);<br>        }<br>        else if ( cmd &#x3D;&#x3D; 1 ) stk.pop();<br>        else if ( cmd &#x3D;&#x3D; 2 )<br>        {<br>            int item &#x3D; stk.top();<br>            printf(“%d\n”,item);<br>        }<br>    }<br>    return 0;<br>}</p>
<p>一些题目:</p>
<p>单调栈模板:<a href="https://www.luogu.com.cn/problem/P5788">https://www.luogu.com.cn/problem/P5788</a></p>
<p>题解:<a href="https://scheng52123.com/index.php/2020/02/04/luogup5788/">https://scheng52123.com/index.php/2020/02/04/luogup5788/</a></p>
]]></content>
      <categories>
        <category>algorithmanddatastruct</category>
      </categories>
  </entry>
  <entry>
    <title>状态压缩DP</title>
    <url>/2020/07/21/2020/statedp/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1360/F">1360 F. Spy-string</a></p>
<p><a href="https://codeforces.ml/problemset/problem/1340/B">1340 B. Nastya and Scoreboard</a> __builtin_popcount(int x)计算x的二进制里有多少个1</p>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>Summer 2020 从申请到结项</title>
    <url>/2020/09/29/2020/summer-2020/</url>
    <content><![CDATA[<p>非常荣幸能够参与这次的暑期活动，参加了 <a href="https://oi-wiki.org/">Oi Wiki</a> 的内容维护，编写和完善了一些算法与数据结构的页面。这篇文章记录一下我整个Summer 2020活动的过程。</p>
<p>大一一学年以及2020年总算做了点事情吧，没有碌碌无为(大概)，自我感觉良好。大一刚入学的时候是打算直接参与 Google 的 GSoC 的，但是因为我太菜了，并没有什么信心去准备。并且大一投入了一些时间到算法竞赛中，没有仔细去了解工程这方面的东西，于是大一的一大半段时间都在咕咕。</p>
<h2 id="项目浏览与选择"><a href="#项目浏览与选择" class="headerlink" title="项目浏览与选择"></a>项目浏览与选择</h2><p>在五月份，表哥发给了我一个网站链接，是此次中科院软件研究所的<a href="https://isrc.iscas.ac.cn/summer2020/">Summer 2020的活动网站</a>，进去浏览了一下得知是一个类似 GSoC 的活动，并且今年是举办的第一年。五月中旬的时候大概有两百多个项目在招收学生了，到后面六月初项目总数增长到了300+。我将两百多个项目的标题都看了一遍，发现大多数是我看不懂的东西，诸如深度学习、操作系统、编译器功能编写等。都是我不会的东西，然后找了一些感兴趣的标题点进去看了一眼项目要求，发现我十分不符合要求…比如一个做前端网页的项目吧，需要的是JavaScript的东西…</p>
<p>翻着翻着就在列表里翻到 Oi Wiki 了，这个站点我还是清楚的。先前高中自学Oi的时候有看过里面的内容，不过当时内容十分少，后来大学学模拟退火算法也是在这里学会的，里面的算法流程还是比较清晰的。于是就点进去看项目技术要求和产出要求了，如下：</p>
<p>产出要求：</p>
<ul>
<li>编写完整而易于理解的文档，能使初学者快速了解到算法或数据结构的主要思想</li>
<li>使用 C &#x2F; C++ 完整实现所选的算法数据结构</li>
<li>设计 testcase</li>
<li>协助解决目前项目中存在的 issue</li>
</ul>
<p>技术要求：</p>
<ul>
<li>能使用 Git 进行协作开发</li>
<li>熟悉 C &#x2F; C++</li>
<li>热爱算法与数据结构</li>
</ul>
<p>更详细的内容可以参见<a href="https://github.com/OI-wiki/OI-wiki/wiki/Open-Source-Promotion-Plan---Summer-2020#">这个页面</a>，发现其实我还是蛮符合要求的，并且先前也在博客水过几篇文章，于是就准备做这个项目了。</p>
<p>其实我考虑过可能不会被 Oi Wiki 选中，和表哥交流过后准备报两个项目的。第二个期望的项目是AOSC的一个打包软件的项目。技术要求是这几个方面：Liunx的软件包管理，软件测试方法，Python。想想Ubuntu也用过几年了，Python也能写几行，测试方法么一两个月总是会学会的，于是也准备写这个项目的申请书。</p>
<p>事实上，很多项目要求的东西虽然看上去十分高大上，但是整个项目是在三个月内完成的，完全可以用一部分的时间去学习技术要求的那些东西，并在后续的时间参与开发。所以我现在认为，当时有许多项目我是可以参与的（不过最后只能选一个哈），应该不止这两个项目。</p>
<h2 id="项目申请书的编写"><a href="#项目申请书的编写" class="headerlink" title="项目申请书的编写"></a>项目申请书的编写</h2><p>活动要求是要自己和导师邮件联系的，表哥作为过来人建议先咨询期望项目的报名情况，因为有一些项目会在直接决定好学生的。于是我分别给项目的两位 mentor 发送了邮件。得知<strong>撰写</strong>已经有同学在咨询了，但是没有合适人选；<strong>打包</strong>没有人报名；Wiki的另一个项目已经定好人员了。</p>
<p>编写项目申请书的过程大致流程就是自己先起草一份，发给导师询问哪里需要修改的，再根据导师的建议修改，当然会不止一次修改，改到导师一个满意的版本后就可以作为报名的那一份。</p>
<p>由于此次活动的模式是仿照 GSoC 的，那当然直接根据 GSoc 的模板编写最好啦。表哥将他当年 GSoC 的申请书以及其他几位大牛（记得其中一位是骆粱宸巨巨）的申请书发给我作为参考。需要包括这几个方面：个人简介；对当前项目的概述包括存在的问题，自己的修改计划等；具体时间安排等。</p>
<p>这一份是我的<a href="https://scheng52123.com/wp-content/uploads/2020/09/proposal1.pdf">初稿</a>，mentor 觉得我的时间安排并不是很合理，以及计划安排上存在问题，我就回去修改了。<a href="https://scheng52123.com/wp-content/uploads/2020/09/proposal2.pdf">第二版</a>我细化了时间安排，并且添加了一个更新清单，mentor 觉得还不错表示非常喜欢，这时候大概率就已经决定是我做这个项目了吧。我首次询问项目的时间是5.26，编写第一版申请书并给mentor看的时间是5.28，改出mentor满意的版本的时间是在5.31,Summer 2020报名开始时间是6.1，截止时间是6.20。其实在6.1~6.20期间完全可以帮助社区开始施工的，不过当时因为要期末考了，就没有去搞，如果直接开始施工当然入选概率会更大吧。当时我是这个项目第一个提交申请书的，一直到6.10前这个项目的申请人数一直是1人。</p>
<p>按 GSoC 的传统，写申请书的过程是需要疯狂找导师套磁的，帮助修修issue啊之类的，展示一下自己的能力啥的。同社区的一位老哥，从五月开始帮助wiki修东西了，当然最后也成功入选了。不过俺当时啥都没干（其实是准备写一个 树的直径 的内容的，不过岛娘巨巨先交了pr，于是我就找不到什么事情可以干…），甚至连咋交pr都不会…</p>
<p>为了防止Wiki那边的项目被筛掉，我在5.31写了<strong>打包</strong>的申请书，也发给那位mentor了。初稿也是不满意的，不过我也没有去修改，因为觉得Wiki那边还是比较稳的。到了6.14我发现Wiki撰写的报名人数已经有6人了，害怕被刷，于是就按照mentor的意思重新修改了<strong>打包</strong>的申请书，并且提交了报名，后来一直到报名截止这个项目都只有1人报名。</p>
<h2 id="筛选环节"><a href="#筛选环节" class="headerlink" title="筛选环节"></a>筛选环节</h2><p>这里主要导师比较各个申请书了，看谁的时间安排和计划更为合理，然后选择一位参与暑期工作。打包那边只有一份申请书，mentor为了考察我的代码能力，叫我用Python写一个下载器。我查询了一些资料后花了一个下午实现了，发给mentor，他觉得还不错，于是打包这边我就入选了。</p>
<p>然后Wiki这边的mentor也发邮件询问我是否会去他们这边，因为如果我拒绝的话，撰写这个项目就没有人了。那最后我还是答应去Wiki了，毕竟算法竞赛我更熟悉一些。（对不起AOSC，qaq）</p>
<h2 id="施工过程"><a href="#施工过程" class="headerlink" title="施工过程"></a>施工过程</h2><p>这个时候就是帮助社区按照项目申请书的内容开始施工了。7.1~7.4和导师商量了一下具体的执行步骤，然后复习（重新学习）了一下Git的命令操作。在7.5提交了我的第一个pr，是<a href="https://oi-wiki.org/math/quad-residue/">二次剩余</a>的内容。当时有两位reviewers帮我点approve的，我看到一位reviewer的id，然后就习惯性开始社工了一下…发现位神仙，居然是最强大脑脑王nano（zlk）！当时真的是给吓到了。后续的许多文章也是nano点的approve（感谢！）。社区里还有许多巨巨，OI金牌爷、国家队、PKU等很多的，卑微的我…</p>
<p>其中还有一些插曲，比如直接用master分支交pr啊啥的…不过后来Git能力就突飞猛进（大概）了。并且认识了一位西交大的同学（和我一样，不会Git…)。</p>
<p>然后具体施工过程可以参见<a href="https://github.com/OI-wiki/OI-wiki/commits?author=ShaoChenHeng&before=b3a10f2e0d712575d97a28791eafe279edfc5465+35">我的commit</a>总共写了2800 line,提交了四十多个commit，可见咕咕咕十分严重。后来mentor还邀请我加入Oi Wiki 的organization并且成为editor了。然后最后提交的一篇是<a href="https://oi-wiki.org/graph/mdst/">最小直径生成树</a>，9.28因为开学了并且一些烦人事情（朱震霆的论文太难懂了，我好菜qaq）就和mentor那边说先结项了，11月后会再参与的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次能被选中还是非常幸运的，因为是第一次活动，各个项目报名的人数都很少，竞争不是很激烈。据说明年还会有Summer 2021，GSoC进不去的话可能会考虑一下？</p>
<p>Oi Wiki那边会持续参与的，因为的确是个很好的算法学习网站。然后接下来学学数学和巩固一下先前学过的东西吧，在GitHub上找一些项目交几个pr,争取明年能进GSoC吧。</p>
]]></content>
      <categories>
        <category>summer</category>
      </categories>
  </entry>
  <entry>
    <title>读&lt;&lt;硅谷之火&gt;&gt;</title>
    <url>/2020/04/25/2020/thefireofsiliconvalley/</url>
    <content><![CDATA[<p><img src="/images/timg?image&quality=80&size=b9999_10000&sec=1587826780318&di=eafd0c25f0b960d41ba7e50e3bcafe0f&imgtype=0&src=http://n.sinaimg.cn/sinakd20200419ac/213/w640h373/20200419/5c7c-iskepxt5079307.jpg"></p>
<p>第一次听到&lt;&lt;硅谷之火&gt;&gt;这本书还是在高中时候，雷军在大学时期在图书馆里读了&lt;&lt;硅谷之火&gt;&gt;然后在操场里走了一圈又一圈，大喊＂我要创业！我要创业！＂但是在高中时期一直没有时间去读它．后来在刷Ｂ站时有看到了一些雷军的视频，就想起了&lt;&lt;硅谷之火&gt;&gt;，于是就去买来读了．</p>
<p>书的前面很多内容是描述微型计算机发展的，书中使我印象很深的一个观点：人们都觉得微型计算机应该有像IBM这样的老牌计算机公司来开发，但是首先研发微型计算机的却是与这个行业根本不相关的人．在许多产业中引起革新的往往也不是当前行业的从业者，而是一些门外汉．</p>
<p>我认为全书最精彩的应该是后面７８９章的内容，讲述的是苹果公司从一个有两个年轻人在车库里发展壮大和后来个人计算机产业遍地开花的故事．我觉得其中最精彩的当属第７章，我目前看来乔布斯是一个拥有艺术家的浪漫和工科生的严谨的一个人，极具个人魅力．反正我在读完第７章后就立马去买了&lt;&lt;乔布斯传&gt;&gt;．以及在乔布斯重返苹果后他的一系列操作，推出了许多的经典设备，我觉还是最喜欢它们家的nano4，第一眼的视觉冲击效果太强了，以后苹果的设备还是要买一台的．</p>
<p>从最早的Altair开始，微型计算机就带动了许多的产业发展，例如相关的计算机配套设备的研发，各个地区的计算机社区的建立，软件产业的发展以及后来的互联网的出现等等．我也意识到在一个划时代产品的诞生之际实际上是能引起一个产业的出现的．书中更是提到在当时那个年代，只要具备一定的研发资金，精密的设备和对产品发售做好足够的宣传，那么任何人都能在微型计算机产业里分一杯羹．雷军本人也曾谈到:’’大风来临，当处于风口的时候，猪都能飞起来．’’后来在10年代手机产业的火爆就像是当年微型计算机产业的重演．</p>
<p>当然很多人最后还是以失败告终的，研究这些人失败的原因也是我阅读这本书的一个初衷．</p>
<p>2018年的语文全国二卷的作文题目谈到了’’幸存者偏差’’这个概念</p>
<blockquote>
<p>“二战”期间。为了加强时战机的防护。英美军方调查了作战后幸存飞机上弹痕的分布，决定哪里弹痕多就加强哪里。然而统计学家沃德力排众议，指出更应该注意弹痕少的部位。因为这些部位受到重创的战机，很难有机会返航，而这部分数据被忽略了。事实证明，沃德是正确的。</p>
<p>2018年语文全国二卷</p>
</blockquote>
<p>现在有许多’’当前成功人士’’，在成功人士前加一个当前的原因是我无法判断他在以后的一段时间里是否还能维持现状．在70，80年代的时候MITS，IMSAI等一系列最初的微型计算机公司可以说的成功的，但他们最后也都销声匿迹了．这些公司最后破产会是出于一些决策上的失误的，某一个起初被忽略的失误都可能导致最后的覆灭，然而那些仍然处在’’当前成功’’的人或者公司他们可能没有犯这样的失误也就是幸存者偏差，所以只研究’’当前成功人士’’的优秀品质或者某一些惊为天人的决策是不够的．&lt;&lt;硅谷之火&gt;&gt;中的公司大多都是以破产和被收购而告终的，有一些失误是出在产品的更新过于迟缓；有一些是因为销售部门和研发生产部门的进度或者说是节奏上的问题；还有一些则是机器自身的某一个部件在价格，质量上不如其他生产商等等．我甚至觉得乔布斯被赶出苹果是由于他在待人处事上存在一些问题．</p>
<p>还有就是计算机产业的发展确实带动了一些产业发展，但是也会影响到一些产业．甚至一些与信息不相关的产业会因为信息技术的发展而遭受影响，一如数字音乐的发展冲击了CD音乐，MP３的出现使过去唱片租赁公司的湮灭等等．在浏览器刚刚开始发展的时候，盖茨就意识到了问题的严重性，于是立即有关的浏览器公司，并立马开始发展自家的IE．浏览器和软件，系统看似是毫无关系的事物，但实际上在日后浏览器会代替系统，虽然这一天还没来到但我觉得和微软的打压是分不开的．我也相信未来会有一个设备只存在一块屏幕，里面也只有一个浏览器，而一切的服务和应用都是在远程的服务器上．</p>
<p>我认为当初投身微型计算机产业的人都是相当浪漫的．他们其中有的人是完全出于兴趣，有的人则是上一次的投资计划破产后的背水一战，还有的人则是在餐桌上不经意间的一次谈话从而萌生了投身计算机产业的想法．当年乔布斯那句’’你是要继续卖糖水，还是和我们一起去改变世界?’’就足以煽动人心．后来的程序员群体也是像他们一样热衷于改变世界的一群人，许多人对从事计算机行业的人的看法是他们是木讷而严肃的，实际上我觉得他们也是浪漫的一群人．</p>
<p>这是我读完这本书后的一些想法，在我还没读完这本书的时候就已经产生了很多想法了，但是当时是想把书读完了再一起写下来，然而有一些想法到现在以及遗忘了，所以下次读书的时候应该先记一部分下来，再在最后来一个汇总．要是以后想起来了一些相关的想法我还会更新到这里的．</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯2016决赛T3出租</title>
    <url>/2020/03/16/2020/tianti200163chuzu/</url>
    <content><![CDATA[<p>题目链接:<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805107638517760">https://pintia.cn/problem-sets/994805046380707840/problems/994805107638517760</a></p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>string ss;<br>string ans1, ans2;<br>set &lt;int, greater<int>&gt; SET;<br>map&lt;int, int&gt; MAP;</p>
<p>int main()<br>{</p>
<pre><code>cin &gt;&gt; ss;
ans1 = &quot;int\[\] arr = new int\[\]&#123;&quot;;
ans2 = &quot;int\[\] index = new int\[\]&#123;&quot;;
for ( int i = 0; i &lt; ss.length(); i++ ) SET.insert(ss\[i\] - &#39;0&#39;);

cout &lt;&lt; ans1;
set&lt;int&gt;::iterator ite;
int total = SET.size();
int count = 0;
for ( ite = SET.begin(); ite != SET.end(); ite ++ )
&#123;
    cout &lt;&lt; \*ite;
    MAP\[\*ite\] = count;
    count ++;
    if ( count != total ) cout &lt;&lt; &#39;,&#39;;
&#125;
cout &lt;&lt; &#39;&#125;&#39; &lt;&lt; &#39;;&#39; &lt;&lt; endl;

cout &lt;&lt; ans2;
for ( int i = 0; i &lt; ss.length(); i ++ )
&#123;
    cout &lt;&lt; MAP\[ss\[i\] - &#39;0&#39;\];
    if ( i != ss.length() - 1 ) printf(&quot;,&quot;);
&#125;
cout &lt;&lt; &#39;&#125;&#39; &lt;&lt; &#39;;&#39; &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p>set中默认从小到大排序，以下是从大到小排序的方案．</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set &lt;int, greater&lt;int&gt;&gt; SET;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>天梯2016家庭房产</title>
    <url>/2020/03/11/2020/tianti2016simulate11/</url>
    <content><![CDATA[<p>给定每个人的家庭成员和其自己名下的房产，请你统计出每个家庭的人口数、人均房产面积及房产套数。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a><strong>输入格式：</strong></h3><p>输入第一行给出一个正整数N（≤1000），随后N行，每行按下列格式给出一个人的房产：</p>
<p><em>编号 父 母 k 孩子1 … 孩子k 房产套数 总面积</em></p>
<p>其中<code>编号</code>是每个人独有的一个4位数的编号；<code>父</code>和<code>母</code>分别是该编号对应的这个人的父母的编号（如果已经过世，则显示<code>-1</code>）；<code>k</code>（0≤<code>k</code>≤5）是该人的子女的个数；<code>孩子i</code>是其子女的编号。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出家庭个数（所有有亲属关系的人都属于同一个家庭）。随后按下列格式输出每个家庭的信息：</p>
<p><em>家庭成员的最小编号 家庭人口数 人均房产套数 人均房产面积</em></p>
<p>其中人均值要求保留小数点后3位。家庭信息首先按人均面积降序输出，若有并列，则按成员编号的升序输出。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">6666 5551 5552 1 7777 1 100</span><br><span class="line">1234 5678 9012 1 0002 2 300</span><br><span class="line">8888 -1 -1 0 1 1000</span><br><span class="line">2468 0001 0004 1 2222 1 500</span><br><span class="line">7777 6666 -1 0 2 300</span><br><span class="line">3721 -1 -1 1 2333 2 150</span><br><span class="line">9012 -1 -1 3 1236 1235 1234 1 100</span><br><span class="line">1235 5678 9012 0 1 50</span><br><span class="line">2222 1236 2468 2 6661 6662 1 300</span><br><span class="line">2333 -1 3721 3 6661 6662 6663 1 100</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">8888 1 1.000 1000.000</span><br><span class="line">0001 15 0.600 100.000</span><br><span class="line">5551 4 0.750 100.000</span><br></pre></td></tr></table></figure>

<p>一道并查集题目, 由于太长时间没用过并查集了来写一篇相关题解.</p>
<p>顺便回忆一下C++的结构体函数构造以及重载.</p>
<p>将同一个家庭中的所有成员累加到编号最小的那个成员上, 再排序输出即可.</p>
<pre><code>double area\_ave() const
&#123;
    return ( (double)(house\_area) ) / ( (double)(member\_number) );
&#125;
double number\_ave() const
&#123;
    return ( (double)(house\_number) / ( (double)(member\_number) ) );
&#125;
</code></pre>
<p>计算平局值的结构体内函数, 这种写法更为方便, 也便于后面的排序操作</p>
<p>bool operator &lt; ( const node &amp;b ) const<br>    {<br>        if ( area_ave() !&#x3D; b.area_ave())<br>        {<br>            return area_ave() &gt; b.area_ave();<br>        }<br>        return ID &lt; b.ID;<br>    }</p>
<p>重载小于号,使面积降序, 当面积相同时按照ID大小升序</p>
<p>int find ( int x )<br>{<br>    if ( arr[x].ID !&#x3D; x ) arr[x].ID &#x3D; find( arr[x].ID );<br>    return arr[x].ID;<br>}</p>
<p>经典的查询最上层结点操作, 这里是返回当前家庭中的最小编号.</p>
<p>void _union( int x, int y )<br>{<br>    x &#x3D; find(x); y &#x3D; find(y);<br>    if ( x &#x3D;&#x3D; y ) return;<br>    else if ( x &gt; y ) swap(x, y);<br>    arr[y].ID &#x3D; x;<br>    arr[x].house_area +&#x3D; arr[y].house_area;<br>    arr[x].house_number +&#x3D; arr[y].house_number;<br>    arr[x].member_number +&#x3D; arr[y].member_number;<br>    arr[y].member_number &#x3D; -1;<br>    arr[y].house_area &#x3D; arr[x].house_area;<br>}</p>
<p>x y在同一个家庭</p>
<p>分别得到当前的x, y 的最小家庭成员编号.</p>
<p>如果相同就说明已经合并过了, 直接返回. 如果x家庭的最小编号大于y家庭的最小编号, 那么就进行交换.</p>
<p>再将y家庭的最小编号设置承x家庭的最小编号(此时x的编号比y的编号小), 相应的各种数据也累加到x家庭, 最后把y的最小编号的房屋数量标成-1，这样除了当前合并后最小编号的人均是大于零，其他的人均都小于0.</p>
<p>全部代码</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>struct node<br>{<br>    int ID;<br>    int house_number, house_area, member_number;<br>    double area_ave() const<br>    {<br>        return ( (double)(house_area) ) &#x2F; ( (double)(member_number) );<br>    }<br>    double number_ave() const<br>    {<br>        return ( (double)(house_number) &#x2F; ( (double)(member_number) ) );<br>    }<br>    bool operator &lt; ( const node &amp;b ) const<br>    {<br>        if ( area_ave() !&#x3D; b.area_ave())<br>        {<br>            return area_ave() &gt; b.area_ave();<br>        }<br>        return ID &lt; b.ID;<br>    }</p>
<p>} arr[10010];</p>
<p>int tmp[1010][10];<br>int vis[10010];</p>
<p>int n;</p>
<p>int find ( int x )<br>{<br>    if ( arr[x].ID !&#x3D; x ) arr[x].ID &#x3D; find( arr[x].ID );<br>    return arr[x].ID;<br>}</p>
<p>void _union( int x, int y )<br>{<br>    x &#x3D; find(x); y &#x3D; find(y);<br>    if ( x &#x3D;&#x3D; y ) return;<br>    else if ( x &gt; y ) swap(x, y);<br>    arr[y].ID &#x3D; x;<br>    arr[x].house_area +&#x3D; arr[y].house_area;<br>    arr[x].house_number +&#x3D; arr[y].house_number;<br>    arr[x].member_number +&#x3D; arr[y].member_number;<br>    arr[y].member_number &#x3D; -1;<br>    arr[y].house_area &#x3D; arr[x].house_area;<br>}</p>
<p>int main()<br>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for ( int i = 0; i &lt; 10001; i ++ )
&#123;
    arr\[i\].ID = i;
    arr\[i\].house\_area = 0;
    arr\[i\].house\_number = 0;
    arr\[i\].member\_number = 1;
&#125;

for ( int i = 0; i &lt; n; i ++ )
&#123;
    scanf(&quot;%d %d %d %d&quot;, &amp;tmp\[i\]\[1\],&amp;tmp\[i\]\[2\],&amp;tmp\[i\]\[3\],&amp;tmp\[i\]\[4\] );
    vis\[tmp\[i\]\[1\]\] = 1;
    if ( tmp\[i\]\[2\] != -1 ) vis\[tmp\[i\]\[2\]\] = 1;
    if ( tmp\[i\]\[3\] != -1 ) vis\[tmp\[i\]\[3\]\] = 1;
    for ( int j = 0; j &lt; tmp\[i\]\[4\]; j ++ )
    &#123;
        scanf(&quot;%d&quot;, &amp;tmp\[i\]\[5+j\]);
        vis\[tmp\[i\]\[5+j\]\] = 1;
    &#125;
    scanf(&quot;%d %d&quot;, &amp;arr\[tmp\[i\]\[1\]\].house\_number, &amp;arr\[tmp\[i\]\[1\]\].house\_area);
&#125;
for ( int i = 0; i &lt; n; i ++ )
&#123;
    if ( tmp\[i\]\[2\] != -1 ) \_union( tmp\[i\]\[1\], tmp\[i\]\[2\] );
    if ( tmp\[i\]\[3\] != -1 ) \_union( tmp\[i\]\[1\], tmp\[i\]\[3\] );
    for ( int j = 0; j &lt; tmp\[i\]\[4\]; j ++ )
    &#123;
        \_union( tmp\[i\]\[1\], tmp\[i\]\[j+5\] );
    &#125;
&#125;
sort(arr, arr + 10000);
int cnt = 0;
while ( vis\[arr\[cnt\].ID\] ) cnt ++;
printf(&quot;%d\\n&quot;, cnt);
for ( int i = 0; i &lt; cnt; i ++ )
&#123;
    printf(&quot;%04d %d &quot;, arr\[i\].ID, arr\[i\].member\_number);
    printf(&quot;%.3f %.3f\\n&quot;, arr\[i\].number\_ave(), arr\[i\].area\_ave());

&#125;
return 0;
</code></pre>
<p>}</p>
<p>还有一个一直被我忽略的地方(c语言课没仔细听)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%04d %d &quot;, arr[i].ID, arr[i].member_number);</span><br></pre></td></tr></table></figure>

<p>%04d的写法能够补齐0, 就不用保存为字符串了, 更加方便.</p>
]]></content>
      <categories>
        <category>catchthem</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2020/07/23/2020/treedp/</url>
    <content><![CDATA[<h2 id="普通树形DP"><a href="#普通树形DP" class="headerlink" title="普通树形DP"></a>普通树形DP</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6540">2019湖南邀请赛 I Neko and tree</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2016">P2016 战略游戏</a> 树形 DP 入门</p>
<p>题解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[u][<span class="number">0</span>] += dp[to][<span class="number">1</span>];</span><br><span class="line">dp[u][<span class="number">1</span>] += <span class="built_in">min</span>(dp[to][<span class="number">1</span>], dp[to][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P3174">[HAOI2009]毛毛虫</a> 题解</p>
<p>对任意一条链，「链上的节点」和「与该链直接相连且不在链上的节点」构成一条「毛毛虫」。 求树上「毛毛虫」节点数的最大值。</p>
<p><a href="https://www.luogu.com.cn/blog/ScanfN/solution-p3174">参考</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>], tot;</span><br><span class="line"><span class="keyword">int</span> size[maxn], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = node&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sizei, sizej;</span><br><span class="line">    sizei = sizej = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%d %d\n&quot;, from, fa);</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = head[from]; i; i = e[i].next )</span><br><span class="line">    &#123;</span><br><span class="line">        deg ++;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ( to == fa ) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to, from);</span><br><span class="line">        sizei = <span class="built_in">max</span>(sizei, size[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( deg == <span class="number">1</span> ) size[from] = sizei + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> size[from] = sizei + deg - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sizei, sizej;</span><br><span class="line">    sizei = sizej = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = head[from]; i; i = e[i].next )</span><br><span class="line">    &#123;</span><br><span class="line">        deg ++;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ( to == fa ) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(to, from);</span><br><span class="line">        <span class="keyword">if</span> ( size[to] &gt; sizei ) &#123; sizej = sizei; sizei = size[to]; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( size[to] &gt; sizej ) sizej = size[to];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( sizei == <span class="number">0</span> ) ans = <span class="built_in">max</span>( ans, deg + <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( sizej == <span class="number">0</span> ) ans = <span class="built_in">max</span>( ans, sizei + deg );</span><br><span class="line">    <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, sizei + sizej + deg - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sizei, sizej;</span><br><span class="line">    sizei = <span class="number">0</span>, sizej = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = head[from]; i; i = e[i].next  )</span><br><span class="line">    &#123;</span><br><span class="line">        deg ++;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ( to == fa ) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs3</span>(to, from);</span><br><span class="line">        <span class="keyword">if</span> ( size[to] &gt; sizei ) &#123; sizej = sizei; sizei = size[to]; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( size[to] &gt; sizej ) sizej = size[to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( sizei == <span class="number">0</span> ) ans = <span class="built_in">max</span>( ans, deg + <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( sizej == <span class="number">0</span> ) ans = <span class="built_in">max</span>( ans, sizei + deg );</span><br><span class="line">    <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, sizei + sizej + deg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( deg == <span class="number">1</span> ) size[from] = sizei + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> size[from] = sizei + deg - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">        <span class="built_in">add</span>(from, to);</span><br><span class="line">        <span class="built_in">add</span>(to, from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*dfs1(1, 0);</span></span><br><span class="line"><span class="comment">    dfs2(2, 0);*/</span></span><br><span class="line">    <span class="built_in">dfs3</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/record/36551219">[JSOI2015]salesman</a> 题解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// 注意分析多种情况出现时子树的形状</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], tot, n;</span><br><span class="line"><span class="keyword">int</span> times[maxn], val[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn], flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = node&#123;v,head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> u, <span class="keyword">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = head[u]; i; i = e[i].next )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ( to == fa ) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, u);</span><br><span class="line">        q.<span class="built_in">push</span>(f[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, jil = INF; </span><br><span class="line">    <span class="keyword">int</span> xx;</span><br><span class="line">    <span class="keyword">if</span> ( q.<span class="built_in">size</span>() &gt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        xx = q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        jil = q.<span class="built_in">top</span>();q.<span class="built_in">push</span>(xx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !q.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        xx = q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> ( xx == <span class="number">0</span> || ( times[u] == cnt &amp;&amp; jil == xx ) ) flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( xx &lt; <span class="number">0</span> || times[u] + <span class="number">1</span> == cnt  ) <span class="keyword">break</span>;</span><br><span class="line">        f[u] += xx;</span><br><span class="line">        jil = xx;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ×[i]);</span><br><span class="line">        times[i] --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    times[<span class="number">1</span>] = INF;val[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">        <span class="built_in">add</span>(from, to);</span><br><span class="line">        <span class="built_in">add</span>(to, from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) f[i] = val[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//for ( int i = 1; i &lt;= n; i ++ )</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( flag )  <span class="built_in">printf</span>(<span class="string">&quot;solution is not unique\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;solution is unique\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P3574">[POI2014]FAR-FarmCraft</a></p>
<p>题解 dp[u]为以u为根的树,每个人装好电脑且遍历完的时间(不包括回来) g[u]为以u为根的树,遍历(一次)完的时间 dp[u]-g[u]为等待时间,且从大到小排序,因为一棵树的总操作时间取决于这棵树的所有子树中操作时间最长的那一棵</p>
<p>转移方程: dp[u] &#x3D; max(dp[u], dp[sons] + g[u] + 1); g[u] +&#x3D; (g[sons] + 2); 可以认为dp[sons]是进入子树,g[u]是从子树回来,加一是从 u 到 sons.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> c[maxn], head[maxn], tot;</span><br><span class="line"><span class="keyword">int</span> dp[maxn], g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> u, <span class="keyword">int</span> v )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = node&#123;v,head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[a] - g[a] &gt;  dp[b] - g[b] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="number">1</span>) dp[u] = c[u];</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; son;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ( to == fa ) <span class="keyword">continue</span>;</span><br><span class="line">        son.<span class="built_in">push_back</span>(to);</span><br><span class="line">        <span class="built_in">dfs</span>(to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(son.<span class="built_in">begin</span>(), son.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ite : son)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sons = (<span class="keyword">int</span>) ite;</span><br><span class="line">        dp[u] = <span class="built_in">max</span>(dp[u], dp[sons] + g[u] + <span class="number">1</span>);</span><br><span class="line">        g[u] += (g[sons] + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">        <span class="built_in">add</span>(from, to);</span><br><span class="line">        <span class="built_in">add</span>(to, from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(dp[<span class="number">1</span>], g[<span class="number">1</span>] + c[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="换根树形DP"><a href="#换根树形DP" class="headerlink" title="换根树形DP"></a>换根树形DP</h2><p>模板 <a href="https://www.luogu.com.cn/problem/P3478">[POI2008]STA-Station</a></p>
<p>题解</p>
<p><code>f[i]</code>为以i为根时，深度的最大和 <code>f[v] = f[u] - size[v] * 2 + n</code>由于从u转移到v，v的所有子节点深度都减少了1就有<code>-size[v]</code>，然后u的所有子结点深度加了1那么就有<code>+n-size[u]</code>。 只要先dfs一次将size和dep计算出，再dfs求dp转移就好了。 <code>f[e[i].to] = f[u] - size[e[i].to] * 2 + n;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[<span class="number">1000010</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1000010</span>&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = node&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, size[<span class="number">1000010</span>], dep[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(e[i].to, u);</span><br><span class="line">            size[u] += size[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            f[e[i].to] = f[u] - size[e[i].to] * <span class="number">2</span> + n;</span><br><span class="line">            <span class="built_in">get_ans</span>(e[i].to, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u, v;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[<span class="number">1</span>] += dep[i];</span><br><span class="line">    <span class="built_in">get_ans</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt; ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = f[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.ml/contest/1092/problem/F">CF1092 F. Tree with Maximum Cost</a> 上一题的带点权版 题解</p>
<p>转移方程：<code>f[v] = f[u] + sum -size[v] * 2;</code> <code>d[u] += (d[v] + size[v]);</code>计算有深度的点权乘积和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll n, val[maxn], sum;</span><br><span class="line">ll d[maxn], size[maxn];</span><br><span class="line">ll f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = node&#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u] = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            size[u] += size[v];</span><br><span class="line">            d[u] += (d[v] + size[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa)</span><br><span class="line">        &#123; </span><br><span class="line">            f[v] = f[u] + sum -size[v] * <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">get_ans</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;val[i]);</span><br><span class="line">        sum += val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;f1 = %lld\n&quot;, f[1]); </span></span><br><span class="line">    f[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">get_ans</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P2986">Great Cow Gathering G</a></p>
<p>题解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e55</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll to, next, w;</span><br><span class="line">&#125; e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll n, val[maxn], sum;</span><br><span class="line">ll d[maxn], size[maxn];</span><br><span class="line">ll f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u, ll v, ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot] = node&#123;v, head[u], w&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u] = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next )</span><br><span class="line">    &#123;</span><br><span class="line">        ll v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            size[u] += size[v];</span><br><span class="line">            d[u] += (d[v] + size[v] * e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">1</span>) f[u] = d[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        ll v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa)</span><br><span class="line">        &#123; </span><br><span class="line">            f[v] = f[u] + (sum -size[v]) * e[i].w - size[v] * e[i].w;</span><br><span class="line">            <span class="built_in">get_ans</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;val[i]);</span><br><span class="line">        sum += val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll x, y, z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;f1 = %lld\n&quot;, f[1]); </span></span><br><span class="line">    f[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">get_ans</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ll ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans = <span class="built_in">min</span>(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dp</category>
        <category>algorithmanddatastruct</category>
        <category>algorithmquiz</category>
      </categories>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/02/02/2020/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algorithmanddatastruct</category>
      </categories>
  </entry>
  <entry>
    <title>泥潭</title>
    <url>/2021/07/14/2021/856/</url>
    <content><![CDATA[<p>首先我想说的是这篇文章本来不应该存在的，但是由于太多想法如果不写一写，我就会一直思考这些想法，现在我不想去再想这些事情了。这篇文章会有很多我的主观情感，但是我尽量写的客观一些。五月份就打算写了，一直因为很多事情才拖到现在。主要记录一下到目前（大二结束）我看待事物看待人的态度的转变。</p>
<p>刚刚进入大学的时候我对待各种人和事情的看法还是和高中相似的，我的高中没有什么坏人，所以一开始我就习惯用好的眼光看待别人。十分感谢我的专业的学长学姐，是他们带我第一次在未进入真正大学生活的军训期间给了我改变自己的想法的机会，大学的大部分人都是为了自己的利益的。就像这些带学弟学妹的学长学姐，或是为了学分或是为了其他目的，自己能力根本不够，但是硬是要凑上去，只是为了自己的利益。但是我还是把大学的整个环境想的太好了。我想想，这些学长学姐也只是学生，为了一些学分绩点无可厚非，但是老师教授总不会这样子吧？</p>
<p>大一一开始的十月份，我认识了一个人，以下就简称为W。当时听了他讲述，我认为他是一个十分厉害的人，在那个时候可以算是志同道合的一个人吧。但是认识的人总是如同第一次见面的时候该有多好，随着对一个人的深入了解，这个人的各种个性就会暴露出来。大一第一次放假，是爸妈来接我回家的，当时我对他们说我认识了一个很厉害的人，人生经历曲折，而且这些事情他都挺过来了。不得不说我爸妈在这一方面还是有远见的，他们说“这种人十分聪明，也许表面上他看上去容易相处，但是内心并不是这样的，甚至连怎么算计你都已经想好了。”当时我觉得他们的话太过恶毒，就没有太理会。后来W的种种行为的确证明了我父母的话是正确的。在大一阶段，我会因为一个人的单一行为直接认定他是好的，并且不会因为一个人的单一行为直接认定他的坏的。然而就目前而言，我对待一个人的态度的改变是渐进的，我不会因为一个人的单一行为直接认定他是好的，可能会因为一个人的单一行为直接认定他的坏的，并且在第一次了解到某人时，我不会认定对方是一个好人。这种态度转变和W的行为和学院里认识的一些人的行为是有关系的。</p>
<p>我第一次接触编程是在初三的一个假期，当时上网冲浪无意间看到了一些和编程相关的内容，就开始搜索各种编程语言，看到最多的就是C和C++了。我一直对这方面的东西很感兴趣。询问正在学习编程的表哥，他推荐我先学Python,于是在初三五一的假期我安装了第一个Python的解释器，写了写 ```print”Hello World!”```以及其他的一些语句。中考考完的第二天，我马上去图书馆找来了Python的相关书籍以及Linux的书开始学编程。到高一开始，我写的最棒的程序大概就是一个Python的百度贴吧爬虫了吧。后来高中学业繁忙就没有在深入学习了。但是有一次表哥和我提到了算法，那是我第一听说算法，所有的程序的背后都是由算法支撑的。高二的一个晚自习下课，学校的某科技社团突然说要找人报名信息技术竞赛（也就是Noip），我就报名了后来暑假学习C语言和算法，准备10月份（对不起我忘记了是10月还是11月）的Noip。第一次参加很烂很烂，不再细说…虽然第二次也很烂。反正这就是我对算法和数据结构的最初体验，我感觉我对这个东西还是喜欢的，这也成为了我高中时期的一个爱好。</p>
<p>那么到了大学我自然是继续研究算法与数据结构了，也很自然地参加了校ACM集训队，如果不发生意外，在大一的下学期是完全有机会去参加区域赛的。但是意外还是发生了，这也是我对W态度改观的最初阶段。突然发生的疫情冲击了我所有的安排，我再也无心关注这些比赛。我觉得这些比赛再当时的那个时间节点已经不可能举行了，我就开始读一些科普的书，而不是写代码。我高中读的书（非技术性书本）真的很少，更多是在写题目和看课内书。W开始散播焦虑，W就是一个容易焦虑的人，并且喜欢将焦虑施加在其他人身上。并且W的控制欲望也在逐渐表达。</p>
<p>返校后W似乎有要排除异己的行为。我当时在看SICP，W来询问我最近在做的事情，我和W说了一番，从W的举止反应来看，W应该已经觉得不参加训练而去看其他的书已经是令W十分失望的行为了。我当时同时在学算法与FP（函数式编程），FP真的太妙了！FP的各种表达与我一直接触的过程式的程序设计完全不同，对我吸引很强。但是后来我没有继续看SICP，继续去搞算法与程序设计竞赛的事情了。</p>
<p>当为一个爱好投入了太多时间，而忽略了其他事情（也有可能是其他的爱好）的时候，也是一件十分悲伤的事情。</p>
<p>到了大一的暑假时间，我把大部分的暑假时间都投入到了训练里面。但是以防万一，我申请了中科院的编程之夏。我在刚进入大学的时候就有两个目标，一个是参与GSoC，一个是ACM铜牌。中科院编程之夏作为我的GSoC的前置任务吧，通过它来熟悉开源这方面的一些东西，并且是参与OI Wiki社区，也是对我训练的一个提升。庆幸的是，还好我申请了中科院编程之夏。暑假过后，内部决定将更多的名额分配给上一届学长。然后有趣的事情就发生了。由于学长队伍的变动，W将我许多已经组建完的队伍数次拆分重组，这也导致了许多同学心态的变化。区域赛拿到的名额是打星，没有正式名额。十分混乱地，我居然参加了省赛，并且在强力的D君的领导下，我们成功地得到了铜牌。后来的各种打星均无入铜线。W多次散播焦虑，让同学们感受与他自己相同程度的压力，下半年的时间里我已经开始对W的行为反感了，并且他对同班同学一些行为让我觉得这个人是有问题的。</p>
<p>关于学校的课程，我最初进入大学以为我终于可以一门心思学编程的东西了，但是事实不是这样子的。学校总是会喜欢安排一些不相关的东西来影响学生学习的。诸如大学物理、电工电子技术这些课程，我曾无数次地自问，我明明是要成为软件工程师或者算法工程师的，为什么却要学习这种以后一辈子都用不上的东西呢？类似的问题在我的高中阶段也出现过，我问过自己我以后是要进计算机或者软件工程专业的人，为什么要去学习生物和地理呢？每一次上生物课的时候我都无比煎熬，每一天我都为了认真学习生物而找一个能够说服自己去学习生物学的理由。所以我高中阶段就一直对大学抱有幻想，幻想我能够一门心思学编程和我感兴趣的东西，但是到了大学才发现实际上不是这样的。我和我的大学班主任W君讨论过这个问题，我很深刻地记得他的一句话“当我们没有能去去改变自己不喜欢的事情的时候，最好的办法就是接受它。”。我知道这句话是绝对正确的，但是我根本无法服从。我也和学院领导T讨论过课程的事情，我洋洋洒洒写了许多字，里面包括了我对诸如大学物理、电工、应用文（计算机专业居然要学应用文，太可笑了）这些无用课程的讨论，以及我希望添加学习的一些最基础内容，诸如Git，Python,增强基础数学的学习等等。但是没有回应，渐渐地我觉得我们学院可能已经没救了，虽然它有许多“光鲜”的荣誉。我也不再想去纠正事情不好的做法。</p>
<p>2020年的下半年的大部分时间直到2021年的4月上旬，是我目前过的最难受的一段时间。因为我真的不知道该去做些什么，是应该继续训练竞赛，还是去做工程方面的东西？一直没有决定，也没有行动。只是看了一些书，期间在看混凝土数学和GEB。精神也不好，由于W的行为，原本安静的实验室可以说是乌烟瘴气，我忍受不了嘈杂的环境，神经性耳鸣了半个多月。W喜欢用自己的思维来决定事情的发展方向，例如一场比拼手速的比赛名额通过思维来选拔参赛队员，由于W除了思维强力，在别的事情上一无是处，于是他经常安排码量少想的多的问题给大家。这也造成了各种题目训练不均的问题。再加上学院领导给了W过多的权力，W的控制欲的本性暴露了出来。由于神经性耳鸣，每天都十分难受，我已经不想再去管这些事情了。期间唯二的好事，一是认识了T君，但是T君是一个保守的人，起初并无过多交谈，是痛苦但又快乐的一件事；二是我找到了一件可能成为我终身参与的一项运动————网球，进入大学这么久，我终于开始运动了。我觉得我通过打网球认识的一些同学，性质上来说就很单纯，因为与他们不会有其他的一些活动，就是单纯的打球，所以不会再产生对这个人的种种看法。事实上，参与程序设计竞赛也应该是一件十分简单的事情，或者说什么事情本身都应该是简单纯粹的，但是由于人的因素，因为人会加入个人的情感到一件事情上，这就会使一些原本简单事情变得很复杂。</p>
<p>到了2021年的4月下旬，我突然想起来我应该去参加GSoC了，于是翻看各种社区，查找各种资料，看了将近一周，在五月初完成了proposal。然后又得知了我的队伍居然被分配到去银川参赛了，因为各种队伍的参赛队伍都已经打完名额了，大二拿得出手的队伍又那么几个，于是我的队伍就去比赛了。之后就是和队友隔几天就进行一次组队训练，我也很意外地发现了，我可能再写计算几何方面的题目上有一些天赋？可惜发现的太晚了，我已经打算好了在银川赛后就不再打了，认真搞工程和开源方面的事情。但是恶心人的事情就发生了。（事实上在银川的时候我也非常厌恶他的做法了，用D君的话来说就是“明明是一个心智不成熟的人，却要伪装成大人模样，太搞笑了。”）。</p>
<p>我不想详细描述这件事情，用一句话概括就是，君子疾夫舍曰欲之而必为之辞。我终于还是被W给恶心到了，他的做法犹如去年暑假对待同届同学一样恶心，只不过去年没有恶心到我，今年把我恶心到了。这件事情之后，又有多少同届的同学会再相信他呢？估计不多吧。我又可怜起下一届的同学们了，也许在他们半年多的训练之后，也经历一次W的“舍曰欲之而必为之辞”。</p>
<p>实际上这件事情对我的影响不是很大，但是我的确是看清了W，并且不会再去轻易相信一个人。现在想想我先前的信任真的十分廉价，但是信任本身应该是一个十分昂贵的东西。我也与一些非利益相关的人，将整个事情的经历描述了一次，请他们分析原因。我得到了一些启发。有的人会做错事情，但是做错事情之后会反思自己的行为并为他的行为感到抱歉，然后对受到影响的人道歉；有的人则是知道自己做了错事，但是就是不愿意去承认、去道歉；有的人却是根本不认为自己做了错事，并且继续我行我素。我的一位INFP朋友和T君都认为W应该属于第三种（十分感谢T君带我了解了MBTI这种神奇的东西）。我们再将第三种样例拓展一下，就会发现这种人还有可能将自己的个人经历扭曲，因为他们发现不了问题的主要矛盾，而找其他的原因去解释一些问题。于是我就开始思考，我从认识W的开始，他是不是就是在伪装？或者说他不是在伪装，而是他给的描述是自己认为正确但是实际上是错误的。他告诉我的那些个人经历，实际上都是来自他错误的分析，导致他经历那些事情的原因不应该是他所描述的，而是有其他原因的。我毫无根据地猜想，会不会与现在我所经历地他的那些做法相似呢？我不敢继续想象了。</p>
<p>好了，我的梦话说完了。</p>
]]></content>
      <categories>
        <category>disorder</category>
      </categories>
  </entry>
  <entry>
    <title>Arch折腾记录</title>
    <url>/2021/11/02/2021/arch_setup/</url>
    <content><![CDATA[<p><img src="/images/2021-11-02_14-09.png"></p>
<p>我的y7000上装了三个操作系统，win10，ubuntu，arch。其中win10和ubuntu都跑了俩年了都没挂。前几个星期不小心把arch滚挂了，就没再去理她，反正还有一个ubuntu可以用。然后前几天给ubuntu换桌面启动器的时候一不小心把它也整挂了，各种调试都不行（主要是我菜），于是就打算直接重装一个arch吧，只是重装系统，文件数据都还是有保留的。</p>
<p>这一篇只会记录一些我在装arch的时候查询的网站和一些注意事项，不会详细讲怎么装，毕竟网上已经有这么多教程了。</p>
<p><a href="https://www.viseator.com/2017/05/19/arch_setup/">https://www.viseator.com/2017/05/19/arch_setup&#x2F;</a></p>
<p><a href="https://www.cnblogs.com/freerqy/p/8502838.html">https://www.cnblogs.com/freerqy/p/8502838.html</a></p>
<p><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/">https://archlinuxstudio.github.io/ArchLinuxTutorial/#/</a></p>
<p><a href="https://arch.icekylin.online/prologue.html">https://arch.icekylin.online/prologue.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/138951848">https://zhuanlan.zhihu.com/p/138951848</a></p>
<p>上面这几个链接基本上可以解决90%的安装时候的问题了吧（</p>
<p>记录几个坑点</p>
<h2 id="wifi连接"><a href="#wifi连接" class="headerlink" title="wifi连接"></a>wifi连接</h2><p>在进入usb启动盘里的arch,wifi是默认关闭的，所以要先将它打开。</p>
<p><code>rfkill unblock wifi</code></p>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>大多数教程并不是使用cfdisk来分区的，我比较喜欢用cfdisk来分区，因为界面相对友好，看的也比较清楚。</p>
<p>我给根目录分区分的太小了，只分了30g，用了两三天就爆满了。并且后续更改根目录分区是一件比较困难的事情。如果cfdisk上显示根目录分区后已经没有更多的剩余空间了，是很难通过常规手段进行扩容的，所以划分区的时候要注意，要么根目录分区大一些，要么在根目录后剩余一点未分配的磁盘空间。</p>
<p>我的情况是，跟目录后有一个8g的交换分区，交换分区后面有一个10g的剩余磁盘空间。于是就把交换分区删了，一共腾出来18g的新空间给根目录扩容。然后交换分区就用交换文件来替代。并且在删除&#x2F;添加分区后，要更改fstab文件的相关内容。</p>
<h2 id="交换空间-x2F-交换文件"><a href="#交换空间-x2F-交换文件" class="headerlink" title="交换空间&#x2F;交换文件"></a>交换空间&#x2F;交换文件</h2><p>交换空间可以用交换目录来替代，因为有的时候电脑的物理内存会满了，然后就会用交换空间&#x2F;交换目录来替代物理内存。也就是说当电脑的物理内存爆满了，使用交换空间&#x2F;交换文件还可以抢救一下。</p>
<p>关于交换空间&#x2F;交换文件的大小分配，网上各种说法众说纷纭，我选择的是分配了8g给交换文件。一个参考区间是8g~32g建议的大小是8g。</p>
<h2 id="关于双系统"><a href="#关于双系统" class="headerlink" title="关于双系统"></a>关于双系统</h2><p><a href="https://zhuanlan.zhihu.com/p/138951848">https://zhuanlan.zhihu.com/p/138951848</a> 这一篇文章已经详细介绍了如何安装双系统。第一次安装因为没有设置好EFI分区，导致进系统的时候有引导错误，于是采用了这篇文章里介绍的方法。</p>
<h2 id="文件迁移"><a href="#文件迁移" class="headerlink" title="文件迁移"></a>文件迁移</h2><p>原先的arch系统的文件和系统是在我的机械硬盘上的，这次把系统装在了固态硬盘里。但是固态硬盘的空间是比较宝贵的，所以软件应该要安装在机械硬盘里，节省空间。可以直接使用上一次的arch的home目录分区的那一块磁盘，首先要做的是把这个盘挂在到当前系统，再使用chown命令重新更改一下那个home里面的文件所有者。chown的时间比较长，需要耐心等待一会儿。</p>
<p>操作完成后就会发现，之前的软件设置全都回来了，还是十分方便的。</p>
<h2 id="桌面美化"><a href="#桌面美化" class="headerlink" title="桌面美化"></a>桌面美化</h2><p>这个部分可以直接到b站找一些视频对着操作就好了，kde store里面有许多现成的配置。</p>
<p>比如我的arch现在看起来是这样的。</p>
<p><img src="/images/2021-11-02_14-07.png"></p>
<h2 id="常用应用"><a href="#常用应用" class="headerlink" title="常用应用"></a>常用应用</h2><p>可以在我上面的dock里面看到，我装的常用软件都在dock里面了。</p>
<p>其中qq是用的deepin-wine-qq，运行起来比较卡，但是目前没有比它好一些的解决方案了。安装方法是yay -s deepin-wine-qq，有一个依赖是deepin-wine6-stable，在安装的时候会产生包冲突，还是反复安装了几次的。要注意的是首先需要去掉<code>/etc/pacman.conf</code>里面multilib的注释，才可以进行安装。</p>
<p>其他应用使用搜索引擎查一下安装起来还是十分轻松的。</p>
<p>也可以再在上面提到的那几篇文章里面进行查看，安装自己喜欢的应用。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>如何给一个新的语言命名？</title>
    <url>/2021/10/26/2021/howtonameanewlanugage/</url>
    <content><![CDATA[<p>最近在看Crafting Interpreters，虽然只看到第一章，但是其中的一个note还是挺有意思的，所以在这里记录、翻译一下。</p>
<blockquote>
<h3 id="DESIGN-NOTE-WHAT’S-IN-A-NAME"><a href="#DESIGN-NOTE-WHAT’S-IN-A-NAME" class="headerlink" title="DESIGN NOTE: WHAT’S IN A NAME?"></a>DESIGN NOTE: WHAT’S IN A NAME?</h3><p>One of the hardest challenges in writing this book was coming up with a name for the language it implements. I went through pages of candidates before I found one that worked. As you’ll discover on the first day you start building your own language, naming is deviously hard. A good name satisfies a few criteria:</p>
<ol>
<li><p><strong>It isn’t in use.</strong> You can run into all sorts of trouble, legal and social, if you inadvertently step on someone else’s name.</p>
</li>
<li><p><strong>It’s easy to pronounce.</strong> If things go well, hordes of people will be saying and writing your language’s name. Anything longer than a couple of syllables or a handful of letters will annoy them to no end.</p>
</li>
<li><p><strong>It’s distinct enough to search for.</strong> People will Google your language’s name to learn about it, so you want a word that’s rare enough that most results point to your docs. Though, with the amount of AI search engines are packing today, that’s less of an issue. Still, you won’t be doing your users any favors if you name your language “for”.</p>
</li>
<li><p><strong>It doesn’t have negative connotations across a number of cultures.</strong> This is hard to be on guard for, but it’s worth considering. The designer of Nimrod ended up renaming his language to “Nim” because too many people remember that Bugs Bunny used “Nimrod” as an insult. (Bugs was using it ironically.)</p>
</li>
</ol>
<p>If your potential name makes it through that gauntlet, keep it. Don’t get hung up on trying to find an appellation that captures the quintessence of your language. If the names of the world’s other successful languages teach us anything, it’s that the name doesn’t matter much. All you need is a reasonably unique token.</p>
</blockquote>
<h3 id="以下是我翻译的内容"><a href="#以下是我翻译的内容" class="headerlink" title="以下是我翻译的内容"></a>以下是我翻译的内容</h3><p>编写这本书的时候最困难的挑战之一就是为其实现的语言命名。在选择出一个合适的名字之前，我浏览了几页候选的名字。就好像你在构建自己的语言的第一天就会发现，命名十分困难。一个好名字满足几个条件：</p>
<ol>
<li><p><strong>没有被使用过。</strong> 如果你不小心与别人的名字重名了，那么就会遇到诸如法律问题、社会问题等的各种麻烦。</p>
</li>
<li><p><strong>发音容易。</strong> 如果一切顺利，那么大家将可能念出以及写下你的语言的名字，任何长于几个音节或者比几个字母长的东西都会使大家厌烦的。</p>
</li>
<li><p><strong>足够独特，易于搜索。</strong>大家会通过搜索引擎搜索你的语言名称来了解它，所以你需要一个足够罕见的词，那么大多数的结果都会指向你的文档了。不过随着目前人工智能搜索引擎数量的增加，这已经不是什么问题了。尽管如此，如果你把你的语言命名为“for”，这是不会给你的用户带来好处的。</p>
</li>
<li><p><strong>在许多文化中没有负面意义。</strong>，这是很难提防的，但是也是值得考虑的。Nimrod的设计师最终把他的语言重命名为”Nim”，因为大多数人及的Bugs Bunny使用“Nimrod”作为侮辱。</p>
</li>
</ol>
<p>如果你的潜在名字通过了这些挑战，请保留它。不要急于寻找一个能体现你的语言精髓的称谓。如果说世界上的其他语言的名字教会了我们什么，那就是名字并不重要。你所需要只是一个相当独特的象征。</p>
<hr>
<p>然后我已经想好了在读完这本书后该给我的语言取的名字了，等我真的把这个语言做出来了再讲。</p>
]]></content>
      <categories>
        <category>book</category>
        <category>解释器</category>
      </categories>
  </entry>
  <entry>
    <title>java package小记</title>
    <url>/2021/11/16/2021/java-package/</url>
    <content><![CDATA[<p>今天我开始构造lox语言了，lox也就是crafting interpreters这本书实现的一个语言，原书是使用java语言实现的。</p>
<p>代码仓库：<a href="https://github.com/emp1dAo/code-of-crafting-interpreters/tree/master/jlox">https://github.com/emp1dAo/code-of-crafting-interpreters/tree/master/jlox</a></p>
<p>因为我java很菜，所以马上就遇到了一个问题，这里记录一下问题以及解决方案。</p>
<p>我使用emacs加终端来编写编译</p>
<p>在<code>~/code-of-crafting-interpreters/jlox</code> 目录进行编译<code>javac Lox.java</code>，得到编译后文件<code>Lox.class</code>，按理来说直接敲<code>java Lox</code>应该就能运行了，但是出现了<code>错误: 找不到或无法加载主类 jlox</code>这样的错误。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jlox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hadError = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage: jlox [script]&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">64</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        runFile(args[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runPrompt();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Files.readAllBytes(Paths.get(path));</span><br><span class="line">    run(<span class="keyword">new</span> String(bytes, Charset.defaultCharset()));</span><br><span class="line">    <span class="keyword">if</span> (hadError) System.exit(<span class="number">65</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runPrompt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader input = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">        String line = reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (line == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        run(line);</span><br><span class="line">        hadError = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(source);</span><br><span class="line">    List&lt;Token&gt; tokens = scanner.scanTokens();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Token token : tokens) &#123;</span><br><span class="line">        System.out.println(token);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">int</span> line, String message)</span> </span>&#123;</span><br><span class="line">    report(line, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(<span class="keyword">int</span> line, String where,</span></span></span><br><span class="line"><span class="params"><span class="function">                   String message)</span> </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;[line &quot;</span> + line + <span class="string">&quot;] error&quot;</span> + where + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    hadError = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>据说这种错误是不会在IDE上出现的，应该是终端运行的问题。主要问题出在代码的第一行<code>package jlox;</code>，这时候需要到<code>jlox</code>的上一层目录进行运行，命令也就变成了<code>java jlox.Lox</code>，这样就可以顺利运行了。</p>
]]></content>
      <categories>
        <category>interpreter</category>
        <category>java</category>
        <category>book</category>
      </categories>
  </entry>
  <entry>
    <title>java手动编译小记</title>
    <url>/2021/11/18/2021/java_compile/</url>
    <content><![CDATA[<p>这篇文章记录如何不使用IDE，使用javac进行编译。</p>
<h2 id="单文件编译"><a href="#单文件编译" class="headerlink" title="单文件编译"></a>单文件编译</h2><p>最简单的例子就是HelloWorld程序了，直接给出代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意文件名与类名相同，所以应该保存为HelloWorld.java，直接在当前目录进行编译即可。</p>
<p><code>javac HelloWorld.java</code></p>
<p>会在当前目录（与HelloWorld.java的同一级目录）生成了HelloWorld.class。</p>
<p>直接运行<code>java HelloWorld</code>就可以看见输出了，要注意的是<code>java HelloWorld.class</code>是无法运行的。</p>
<p>传入的是main函数所在的类的名字，而不是class文件；java会根据类名自动去找class文件。</p>
<h3 id="添加包名"><a href="#添加包名" class="headerlink" title="添加包名"></a>添加包名</h3><p>这个内容在<a href="https://scheng52123.com/index.php/2021/11/16/java-package/">上一篇文章</a>里已经提到了，再复述一下。</p>
<p>在原先的HelloWorld里面加一句<code>package com.test</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>javac HelloWorld.java</code>，生成了<code>HelloWorld.class</code>文件。这时需要先创建目录：<code>/com/test</code>然后在<code>com/</code>的上一层目录执行<code>java com.test.HelloWorld</code>。</p>
<p>或者使用命令<code>javac -d . HelloWorld.java</code>，会在当前目录下生成一个<code>.../com/test/HelloWorld.class</code>，然后再运行<code>java com.test.HelloWorld</code>这样子也是可以的。</p>
<p>以上的这些行为说明，增加了package名，class名也会变化，在需要运行时候就要使用全限定名（关于全限定名、简单名的定义可以查看<a href="https://mingshan.fun/2018/09/18/fully-qualified-name-simple-name-descriptor/">这篇文章</a>）；java会根据包名对应出目录结构，并从class path搜索该目录去找到class文件。</p>
<h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><p>有两个文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com1.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HelloService service = <span class="keyword">new</span> HelloService();</span><br><span class="line">        service.printHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com1.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HelloService service = <span class="keyword">new</span> HelloService();</span><br><span class="line">        service.printHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种编译方式，第一种和上面单文件编译类似。</p>
<p>先执行<code>javac -d . HelloService.java</code>得到了<code>com1/test/HelloService.class</code>，再执行<code>javac -d . HelloWorld.java</code>，得到了<code>com1/test/HelloWorld.class</code>，然后就可以通过<code>java com1.test.HelloWorld</code>顺利运行了。</p>
<p>另外一种是直接写上全部需要的文件，在现在情况下就是<code>javac -d . HelloWorld.java HelloService.java</code>，不需要区分前后，会根据依赖关系自动确定顺序。</p>
<p>也可以使用<code>javac -d . *.java</code>直接对当前目录下的所有java文件进行编译。</p>
<h2 id="使用src和target目录"><a href="#使用src和target目录" class="headerlink" title="使用src和target目录"></a>使用src和target目录</h2><p>希望能够想IDE一样，src目录下保存原文件，target目录下生成可运行文件。例如在<code>javatest</code>目录下有<code>src</code>目录，<code>src</code>目录中保存了各种java原文件。在<code>javatest</code>目录下执行<code>javac -d target src/*.java</code>就能将编译后的文件生成在<code>target</code>目录下了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>如何让Vue.js能够调用Python函数？</title>
    <url>/2021/10/27/2021/jsreadwrite/</url>
    <content><![CDATA[<p>这个问题主要来自我今年的暑期项目，eaf-rss-reader。因为前端是使用vue.js，数据处理部分是python，涉及到了文件读写，但是出于安全考虑，vue.js以及js是不直接提供本地文件读写的，在eaf里提供了一种通过 <strong>QWebChannel</strong> 来实现vue.js调用python函数的方法。</p>
<p>首先，在Vue组件的<code>created()</code>函数中写下如下代码，表示绑定Python端的QWebChannel对象<code>pyobject</code>到JavaScript端的<code>window.pyobject</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-undef</span></span><br><span class="line">  <span class="keyword">new</span> QWebChannel(qt.webChannelTransport, <span class="function"><span class="params">channel</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.pyobject = channel.objects.pyobject;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在Python端定义函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore</span><br><span class="line"></span><br><span class="line"><span class="meta">@QtCore.pyqtSlot(<span class="params"><span class="built_in">str</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_in_dired</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    eval_in_emacs(<span class="string">&#x27;dired&#x27;</span>, [path])</span><br></pre></td></tr></table></figure>

<p>最后，直接在Vue组件任意地方调用<code>window.pyobject.open_in_dired(path)</code>即可。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>vue-js</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始的Emacs配置学习</title>
    <url>/2021/01/30/2021/learnemacs/</url>
    <content><![CDATA[<p>该怎么说呢，很早就下载了这个操作系统（编辑器）了，一年前（2019）在看SICP的时候就有想法用emacs写scheme，但是由于配置过于复杂，还是选择了用vscode进行编辑。然后中间因为一些其他的事情停止了对SICP的学习，总共四章的内容也只看了两章多，这次放假希望一次性把emacs配置好再把SICP看完吧。接下来将介绍我的emacs配置过程。</p>
<h2 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用"></a>快捷键的使用</h2><p>C 即 Control , M 即 Alt (至少在我的键盘上是这样的)</p>
<p><code>C - x , C - s</code> 对当前文档进行保存</p>
<p><code>C - x, C - c</code> 关闭当前程序</p>
<p><code>C - x, C - f</code> 输入文件名，emacs会搜索文件并打开</p>
<p><code>M - x</code> 输入具体操作(这个比较类似 sublime 和 vscode 里面的<code>C - p</code>)</p>
<p><code>C - w</code>剪切</p>
<p><code>M - w</code> 复制</p>
<p><code>C - y</code> 粘贴</p>
<p><code>M - y</code> 在按下<code>C - y</code>后，按此键，切换粘贴的内容</p>
<p><code>C - /</code> 撤销</p>
<p><code>C - g</code>中断当前命令输入</p>
<p><code>C - s</code> 或者<code>C - r</code> 搜索（方向不同）</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在emacs 27以前的版本通常是在”.emacs”这个文件里进行修改的，具体操作是<code>M - x</code>后，输入.emac回车，就可以进入配置文件了。</p>
<h2 id="关闭滚动条与工具栏"><a href="#关闭滚动条与工具栏" class="headerlink" title="关闭滚动条与工具栏"></a>关闭滚动条与工具栏</h2><p><code>(scroll-bar-mode -1)</code> 关闭滚动条 <code>(tool-bar-mode -1)</code> 关闭工具栏</p>
<h2 id="添加国内源"><a href="#添加国内源" class="headerlink" title="添加国内源"></a>添加国内源</h2><p>这个设置和Linux系统下的添加镜像源的操作如出一辙。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; add tinghua resource</span><br><span class="line">(setq package-archives &#x27;((&quot;gnu&quot;   . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;)</span><br><span class="line">             (&quot;org&quot;   . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/org/&quot;)</span><br><span class="line">                         (&quot;melpa&quot; . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;)))</span><br><span class="line"></span><br><span class="line">(package-initialize) ;; You might already have this line</span><br></pre></td></tr></table></figure>

<h2 id="包管理器的初始化、刷新、安装"><a href="#包管理器的初始化、刷新、安装" class="headerlink" title="包管理器的初始化、刷新、安装"></a>包管理器的初始化、刷新、安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ;; package initialize</span><br><span class="line">(setq package-check-signature nil)</span><br><span class="line"></span><br><span class="line">(require &#x27;package)</span><br><span class="line"></span><br><span class="line">(unless (bound-and-true-p package--initialized)</span><br><span class="line">  (package-initialize))</span><br><span class="line"></span><br><span class="line">;; refresh resource</span><br><span class="line">(unless package-archive-contents</span><br><span class="line">  (package-refresh-contents))</span><br><span class="line"></span><br><span class="line">;; use-package</span><br><span class="line">(unless (package-installed-p &#x27;use-package)</span><br><span class="line">  (package-refresh-contents)</span><br><span class="line">  (package-install &#x27;use-package))</span><br></pre></td></tr></table></figure>

<p><code>unless</code> 语句即如果没有进行(…)那么就进行(…)。</p>
<h2 id="使用use-package管理扩展"><a href="#使用use-package管理扩展" class="headerlink" title="使用use-package管理扩展"></a>使用use-package管理扩展</h2><h3 id="最基本的格式"><a href="#最基本的格式" class="headerlink" title="最基本的格式"></a>最基本的格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(use-package restart-emacs)</span><br></pre></td></tr></table></figure>

<p><code>M-x</code>后输入<code>restart-emacs</code>,emacs就会重启了。</p>
<h3 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; 常用格式</span><br><span class="line">(use-package smooth-scrolling</span><br><span class="line">: ensure t; 是否一定要确保已安装</span><br><span class="line">: defer nil ;是否延迟加载</span><br><span class="line">: init (setq smooth-scrolling-margin 2) ;初始化参数</span><br><span class="line">: config (smooth-scrolling-mode t) ;基本配置参数</span><br><span class="line">: bind ;快捷键绑定</span><br><span class="line">: hook ;hook模式的绑定)</span><br></pre></td></tr></table></figure>

<h3 id="推荐添加的配置"><a href="#推荐添加的配置" class="headerlink" title="推荐添加的配置"></a>推荐添加的配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(eval-and-compile</span><br><span class="line">  (setq use-package-always-ensure t)    ; 不用每个包都手动添加:ensure t 关键字</span><br><span class="line">  (setq use-package-always-defer t)     ; 默认都是延时加载，不用每个包都手动添加:defer t 关键字</span><br><span class="line">  (setq use-package-always-demand nil)  ;</span><br><span class="line">  (setq use-package-expand-minimally t) ;</span><br><span class="line">  (setq use-package-verbose t)          ; 打印安装过程</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><h3 id="使用-use-package-安装"><a href="#使用-use-package-安装" class="headerlink" title="使用 use-package 安装"></a>使用 use-package 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; install a theme</span><br><span class="line">;;(use-package gruvbox-theme</span><br><span class="line">;;  :init(load-theme &#x27;gruvbox-dark-soft t))</span><br></pre></td></tr></table></figure>

<h3 id="通过他人编写的文件安装"><a href="#通过他人编写的文件安装" class="headerlink" title="通过他人编写的文件安装"></a>通过他人编写的文件安装</h3><p>在这个开源项目（<a href="https://github.com/belak/emacs-monokai-pro-theme">https://github.com/belak/emacs-monokai-pro-theme</a> ）中找到了合适版本的emacs配色，然后根据README.md的教程完成。</p>
<p>将monokai-pro-theme.el文件放入.emacs.d&#x2F;themes&#x2F;中 然后执行<code>M-x package-install monokai-pro-theme</code> 将<code>(load-theme &#39;monokai-pro t)</code>添加到配置文件，重启后就可以看见主题更改了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; use monokai</span><br><span class="line">(load-theme &#x27;monokai t) ;; or (load-theme &#x27;monokai-pro t）</span><br></pre></td></tr></table></figure>

<h2 id="更换一个更加优雅的状态栏"><a href="#更换一个更加优雅的状态栏" class="headerlink" title="更换一个更加优雅的状态栏"></a>更换一个更加优雅的状态栏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; an elegent mode-line</span><br><span class="line">(use-package smart-mode-line</span><br><span class="line">  :init</span><br><span class="line">  (setq sml/noconfir-load-theme t</span><br><span class="line">    sml/theme &#x27;respectful)</span><br><span class="line">  (sml/setup))</span><br></pre></td></tr></table></figure>

<h2 id="显示行标"><a href="#显示行标" class="headerlink" title="显示行标"></a>显示行标</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(global-linum-mode t)</span><br></pre></td></tr></table></figure>

<h2 id="工程化管理配置"><a href="#工程化管理配置" class="headerlink" title="工程化管理配置"></a>工程化管理配置</h2><p>由于将所有的配置都写到.emacs里会使整个文档看起来很凌乱，于是就需要将不同方面（ui界面，use-package管理等）的配置代码区分开来。</p>
<p>于是不妨新建一个文件夹&#x2F;.emacs.d&#x2F;lisp&#x2F;里面专门存放配置文件。并且根据配置的不同方向，命名如下：</p>
<ul>
<li>init-elpa.el 存放镜像源相关配置</li>
<li>init-package.el 存放包管理器的相关配置u</li>
<li>init-startup.el emacs启动时运行的一些代码（关闭工具栏和滚动条等）</li>
<li>init-ui.el 界面的主题和字体等配置</li>
</ul>
<p>比如目前我的init-ui.el是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; install a theme</span><br><span class="line">;;(use-package gruvbox-theme</span><br><span class="line">;;  :init(load-theme &#x27;gruvbox-dark-soft t))</span><br><span class="line"></span><br><span class="line">;; use monokai</span><br><span class="line">(load-theme &#x27;monokai t) ;; or (load-theme &#x27;monokai-pro t)</span><br><span class="line"></span><br><span class="line">;; an elegent mode-line</span><br><span class="line">(use-package smart-mode-line</span><br><span class="line">  :init</span><br><span class="line">  (setq sml/noconfir-load-theme t</span><br><span class="line">    sml/theme &#x27;respectful)</span><br><span class="line">  (sml/setup))</span><br><span class="line"></span><br><span class="line">;; show the line number</span><br><span class="line">(global-linum-mode t)</span><br><span class="line"></span><br><span class="line">;; make the background transparent</span><br><span class="line">(set-frame-parameter (selected-frame) &#x27;alpha (list 85 60))</span><br><span class="line">(add-to-list &#x27;default-frame-alist (cons &#x27;alpha (list 85 60)))</span><br><span class="line">(put &#x27;downcase-region &#x27;disabled nil)</span><br><span class="line"></span><br><span class="line">(provide &#x27;init-ui)</span><br></pre></td></tr></table></figure>

<p><code>(provide &#39;init-ui)</code>在这里是将<code>init-ui</code>暴露的意思，后续的<code>require</code>会根据是否暴露来找到配置文件。</p>
<p>将所有的配置往&#x2F;.emacs.d&#x2F;目录下的init.el文件里迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(add-to-list &#x27;load-path</span><br><span class="line">         (expand-file-name(concat user-emacs-directory &quot;lisp&quot;)))</span><br><span class="line"></span><br><span class="line">(require &#x27;init-startup)</span><br><span class="line">(require &#x27;init-elpa)</span><br><span class="line">(require &#x27;init-ui)</span><br><span class="line">(require &#x27;init-package)</span><br></pre></td></tr></table></figure>

<p><code>load-path</code>是一个<code>list</code>，需要将配置添加进去。</p>
<p><code>expand-file-name</code>将后面的两个字符串拼接成一个目录，<code>concat</code>是拼接的意思,<code>user-emacs-directory</code>系统的全局变量，寻找emacs的目录，即&#x2F;.emacs.d&#x2F;这个目录。</p>
<p>诸如<code>(require &#39;init-startup)</code>require和provide是配对的，调用之前配置好的<code>init-startup</code>。</p>
<p>这些都配置好了以后就可以把.emacs文件删了。</p>
<h2 id="关于自定义配置"><a href="#关于自定义配置" class="headerlink" title="关于自定义配置"></a>关于自定义配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(setq custom-file (expand-file-name &quot;custom.el&quot; user-emacs-directory))</span><br></pre></td></tr></table></figure>

<p>通过这个命令可以将一些自定义配置(诸如鼠标点击的)后系统生成的文字，保存到custom.el里面。 通过这个方法可以使得init.el文件看上去并不是那么凌乱了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(when (file-exits-p custom-file)</span><br><span class="line">  (load-file custom-file))</span><br></pre></td></tr></table></figure>

<p>系统可能不会自动加载custom里面的配置，这里的代码意思是当发现custom-file文件存在是就自动加载。</p>
<h2 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(prefer-coding-system &#x27;utf-8)</span><br><span class="line">(set-default-coding-systems &#x27;utf-8)</span><br><span class="line">(set-terminal-coding-system &#x27;utf-8)</span><br><span class="line">(set-keyboard-coding-system &#x27;utf-8)</span><br><span class="line">(setq default-buffer-file-coding-system &#x27;utf-8)</span><br></pre></td></tr></table></figure>

<p>用于解决乱码问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(setq gc-cons-threshold most-positive-fixnum)</span><br></pre></td></tr></table></figure>

<p>控制垃圾回收阈值，满了再回收。</p>
<h2 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h2><p>使用company插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(use-package company</span><br><span class="line">  :diminish (company-mode &quot; Cmp.&quot;)</span><br><span class="line">  :defines (company-dabbrev-ignore-case company-dabbrev-downcase)</span><br><span class="line">  :hook (after-init . global-company-mode)</span><br><span class="line">  :config (setq company-dabbrev-code-everywhere t</span><br><span class="line">                company-dabbrev-code-modes t</span><br><span class="line">                company-dabbrev-code-other-buffers &#x27;all</span><br><span class="line">                company-dabbrev-downcase nil</span><br><span class="line">                company-dabbrev-ignore-case t</span><br><span class="line">                company-dabbrev-other-buffers &#x27;all</span><br><span class="line">                company-require-match nil</span><br><span class="line">                company-minimum-prefix-length 1</span><br><span class="line">                company-show-numbers t</span><br><span class="line">                company-tooltip-limit 20</span><br><span class="line">                company-idle-delay 0</span><br><span class="line">                company-echo-delay 0</span><br><span class="line">                company-tooltip-offset-display &#x27;scrollbar</span><br><span class="line">                company-begin-commands &#x27;(self-insert-command))</span><br><span class="line">  (eval-after-load &#x27;company</span><br><span class="line">    &#x27;(add-to-list &#x27;company-backends</span><br><span class="line">                  &#x27;(company-abbrev company-yasnippet company-capf))))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>emacs</category>
      </categories>
  </entry>
  <entry>
    <title>npm权限调试小记</title>
    <url>/2021/08/26/2021/npm1/</url>
    <content><![CDATA[<p>今天安装javascript的lovefield插件，github地址为：<a href="https://github.com/google/lovefield/blob/master/demos/todo/README.md">https://github.com/google/lovefield/blob/master/demos/todo/README.md</a></p>
<p>根据这个教程，首先是要安装gulp等插件的。</p>
<p>我将<code>npm install -g gulp·</code>输入终端，结果出现了这样的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! code EACCES</span><br><span class="line">npm ERR! syscall mkdir</span><br><span class="line">npm ERR! path /usr/lib/node_modules/gulp</span><br><span class="line">npm ERR! errno -13</span><br><span class="line">npm ERR! Error: EACCES: permission denied, mkdir &#x27;/usr/lib/node_modules/gulp&#x27;</span><br><span class="line">npm ERR!  [Error: EACCES: permission denied, mkdir &#x27;/usr/lib/node_modules/gulp&#x27;] &#123;</span><br><span class="line">npm ERR!   errno: -13,</span><br><span class="line">npm ERR!   code: &#x27;EACCES&#x27;,</span><br><span class="line">npm ERR!   syscall: &#x27;mkdir&#x27;,</span><br><span class="line">npm ERR!   path: &#x27;/usr/lib/node_modules/gulp&#x27;</span><br><span class="line">npm ERR! &#125;</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! The operation was rejected by your operating system.</span><br><span class="line">npm ERR! It is likely you do not have the permissions to access this file as the current user</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! If you believe this might be a permissions issue, please double-check the</span><br><span class="line">npm ERR! permissions of the file and its containing directories, or try running</span><br><span class="line">npm ERR! the command again as root/Administrator.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /home/scheng/.npm/_logs/2021-08-26T14_32_18_031Z-debug.log</span><br></pre></td></tr></table></figure>

<p>起先以为是权限问题，于是就很粗糙地加了个sudo，也就是<code>sudo npm install -g gulp</code></p>
<p>结果就出现了一个类似代理问题的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! code ENOTFOUND</span><br><span class="line">npm ERR! syscall getaddrinfo</span><br><span class="line">npm ERR! errno ENOTFOUND</span><br><span class="line">npm ERR! network request to https://registry.npm.taobao.org+/bower failed, reason: getaddrinfo ENOTFOUND registry.npm.taobao.org+</span><br><span class="line">npm ERR! network This is a problem related to network connectivity.</span><br><span class="line">npm ERR! network In most cases you are behind a proxy or have bad network settings.</span><br><span class="line">npm ERR! network </span><br><span class="line">npm ERR! network If you are behind a proxy, please make sure that the</span><br><span class="line">npm ERR! network &#x27;proxy&#x27; config is set properly.  See: &#x27;npm help config&#x27;</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2021-08-26T14_12_05_523Z-debug.log</span><br></pre></td></tr></table></figure>

<p>首先是解决这个问题，查找一番以为是npm设置了代理，但是代理并没有设置正确，就导致了无法正常下载。 那么先<code>npm config list</code>检查一下配置，发现是没有设置代理的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; &quot;user&quot; config from /home/scheng/.npmrc</span><br><span class="line"></span><br><span class="line">proxy = false </span><br><span class="line">registry = &quot;https://registry.npmjs.org/&quot; </span><br><span class="line"></span><br><span class="line">; node bin location = /usr/bin/node</span><br><span class="line">; cwd = /home/scheng/eaf-rss-reader</span><br><span class="line">; HOME = /home/scheng</span><br><span class="line">; Run `npm config ls -l` to show all defaults.</span><br></pre></td></tr></table></figure>

<p>然后就突发奇想，要不设置个代理?于是就<code>npm config set proxy http://x.xxx.xxx.xxx:xxx</code>，然后重新install，结果还是无法正常下载，就默默地把这一行配置有删掉了…</p>
<p>然后回头解决最初的那个问题，也就是权限的问题。 可以根据这个网页的内容来操作：<a href="https://stackoverflow.com/questions/48910876/error-eacces-permission-denied-access-usr-local-lib-node-modules">https://stackoverflow.com/questions/48910876/error-eacces-permission-denied-access-usr-local-lib-node-modules</a></p>
<p>先是 <code>ls -la /usr/local/lib/node_modules</code>查看一下node_modules的权限，但是终端给我报错说并没有<code>/usr/local/lib/node_modules</code>这个目录， 那么就<code>whereis node_modules</code>查看一下它在哪里，原来我的arch把它装在了<code>/usr/lib/node_modules</code>这个目录…那么后续就是<code>ls -la /usr/lib/node_modules</code> 查看权限，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x   8 root root   4096  7月 22 15:11 .</span><br><span class="line">drwxr-xr-x 251 root root 270336  8月 26 00:54 ..</span><br><span class="line">drwxr-xr-x   5 root root   4096  5月 28 21:23 cnpm</span><br><span class="line">drwxr-xr-x   9 root root   4096  7月 25 16:58 node-gyp</span><br><span class="line">drwxr-xr-x   5 root root   4096  7月 22 15:11 nopt</span><br><span class="line">drwxr-xr-x   6 root root   4096  8月  4 12:13 npm</span><br><span class="line">drwxr-xr-x   8 root root   4096  5月 27 10:26 semver</span><br><span class="line">drwxr-xr-x   7 root root   4096  5月 28 21:24 vue-cli</span><br></pre></td></tr></table></figure>

<p>这里普通用户是需要root权限的,链接里面提供了三种方法，这里不再赘述。我使用的是：<code>sudo chown -R ownerName: /usr/lib/node_modules</code></p>
<p>然后再去跑最初的那个安装命令，就能完美安装啦。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>关于opml，使用lxml解析opml文件小记</title>
    <url>/2021/11/10/2021/opml/</url>
    <content><![CDATA[<p>首先来介绍一下什么是opml文件。</p>
<p>了解到这种文件主要是因为eaf-rss-reader的一个issue。一般来说像feedly，Inoreader这种的rss-reader是提供了引入&#x2F;导出opml文件的功能的。opml文件将你的feed链接都收集到一个文件里，方便将所有的feed订阅转移到其他的阅读器上。</p>
<p>opml文件其实就是一个xml文件，使用能够解析xml文件的一些库就能将它解析了。但是比较怪的是，feedly网站上居然无法解析由Inoreader生成的xml文件…</p>
<p>对python来说，解析xml通常会用xml库或者lxml库，我觉得lxml操作起来更加方便，于是就用lxml了。值得注意的一个地方是，xml文件里面有默认的几个特殊字符 <strong>&lt; &gt; &amp; ‘ “</strong> ，如果需要被提取的地方出现了这几个字符，那么就会报一个出现特殊字符的错误：lxml.etree.XMLSyntaxError: xmlParseEntityRef: no name，这个问题是由Emacs China论坛的用户提出的。</p>
<h2 id="导入解析opml"><a href="#导入解析opml" class="headerlink" title="导入解析opml"></a>导入解析opml</h2><p>接下來介绍一下解析过程。</p>
<ol>
<li><p>首先需要一个文件输入，就是将opml文件的位置传入到程序里。</p>
</li>
<li><p>获取到文件，开始解析。将opml文件转换成一个feeds_list，里面记录feed链接。</p>
</li>
<li><p>逐个将链接解析，添加到本地rss库中。</p>
</li>
</ol>
<p>第1步没有什么好展开讲的，现在在mini-buffer里面直接输入地址还不能补全，也没有检查路径是否存在，所以说实现方案还不够友好，需要再改进一下。</p>
<p>解析过程最重要的步骤也就是第2步了，这里贴出我的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_import_opml</span>(<span class="params">self, opml_file</span>):</span></span><br><span class="line">        message_to_emacs(<span class="string">&quot;Importing...&quot;</span>)</span><br><span class="line">        parser = etree.XMLParser(encoding = <span class="string">&quot;utf-8&quot;</span>, recover = <span class="literal">True</span>)</span><br><span class="line">        tree = etree.parse(opml_file, parser = parser)</span><br><span class="line">        feeds = tree.xpath(<span class="string">&#x27;/opml/body/outline&#x27;</span>)</span><br><span class="line">        feeds_list = []</span><br><span class="line">        feeds_list = tree.xpath(<span class="string">&#x27;/opml/body/outline/@xmlUrl&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The above method may not be able to obtain xmlUrl.</span></span><br><span class="line">        <span class="keyword">for</span> feed <span class="keyword">in</span> feeds:</span><br><span class="line">            <span class="keyword">for</span> rss <span class="keyword">in</span> feed.iterchildren():</span><br><span class="line">                feeds_list.append(rss.get(<span class="string">&#x27;xmlUrl&#x27;</span>))</span><br><span class="line">        feeds_list = <span class="built_in">sorted</span>(<span class="built_in">set</span>(feeds_list), key = feeds_list.index)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># unique feed</span></span><br><span class="line">        <span class="keyword">for</span> index, feed <span class="keyword">in</span> <span class="built_in">enumerate</span>(feeds_list):</span><br><span class="line">            <span class="keyword">if</span> feed <span class="keyword">in</span> self.main_item.feedlink_list:</span><br><span class="line">                feeds_list.pop(index)</span><br><span class="line">                message_to_emacs(<span class="string">&quot;Feedlink &#x27;&#123;&#125;&#x27; exists.&quot;</span>.<span class="built_in">format</span>(feed))</span><br><span class="line"></span><br><span class="line">        self.import_opml_thread(feeds_list)</span><br></pre></td></tr></table></figure>

<p>第三行是定义了一个解析器，因为要解决上面提到的特殊字符的问题，所以引入了<code>recover=True</code>这个参数，作用是当碰到特殊字符时直接把他们覆盖掉（用空格）。因为这里并不取到特殊字符所在的那一部分内容，所以是可以直接覆盖掉的。</p>
<p>第四行使用上面定义的解析器解析xml文件。之后用xpath先读到outline所在位置，这里其实是一个temp。直接用xpath读到xmlUrl标签，记录在feeds_list中，但是有一些网站提供的opml又会读不到。就需要对上面生成的那个temp再操作一次，这个temp主要是为了解决多层outline包裹的问题（比如feedly如果定义了分类那么就会多层包裹）。</p>
<p>10～12是对多层包裹的处理，考虑到这里实际上是进行了两次解析，可能会生成重复的feeds，于是在13进行一个去重。16～18是与本地feeds进行对比，然后去重，先去重再抓取，提高效率。</p>
<p>第3步，我最初想的是单个调用原先写的多线程处理抓取的方法，但是这样实现起来会难以控制抓取结果，feed的index也会出现问题（标号index的操作比抓取线程快很多，就会导致index出错）。于是就重新为引入opml重新写了一个独立的线程，不过我觉得这样其实并不优雅。</p>
<h2 id="导出opml"><a href="#导出opml" class="headerlink" title="导出opml"></a>导出opml</h2><p>导出opml比引入opml实现起来要简单些。</p>
<p>因为直接使用python的xml库生成的xml文件是没有排版的，整个文件就一行，十分地丑，于是我就写了一个美化排版的递归函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beautify_opml</span>(<span class="params">self, element, indent, newline, level = <span class="number">0</span></span>):</span></span><br><span class="line">       <span class="keyword">if</span> element:</span><br><span class="line">           <span class="keyword">if</span> element.text == <span class="literal">None</span> <span class="keyword">or</span> element.text.isspace():</span><br><span class="line">               element.text = newline + indent * (level + <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               element.text = newline + indent * (level + <span class="number">1</span>) + element.text.strip() + newline + indent * (level + <span class="number">1</span>)     </span><br><span class="line">       temp = <span class="built_in">list</span>(element)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> subelement <span class="keyword">in</span> temp:</span><br><span class="line">           <span class="keyword">if</span> temp.index(subelement) &lt; (<span class="built_in">len</span>(temp) - <span class="number">1</span>):     </span><br><span class="line">               subelement.tail = newline + indent * (level + <span class="number">1</span>)    </span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               subelement.tail = newline + indent * level   </span><br><span class="line">           self.beautify_opml(subelement, indent, newline, level = level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>主要思路就是根据层级关系来判断是否需要加缩进以及换行，然后对子树节点再进行递归操作。</p>
<p>接下来是生成函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_opml</span>(<span class="params">self</span>):</span></span><br><span class="line">    message_to_emacs(<span class="string">&quot;Exporting...&quot;</span>)</span><br><span class="line">    root = Element(<span class="string">&#x27;opml&#x27;</span>)</span><br><span class="line">    root.<span class="built_in">set</span>(<span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line">    head = SubElement(root, <span class="string">&#x27;head&#x27;</span>)</span><br><span class="line">    title = SubElement(head, <span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    user_name = get_emacs_var(<span class="string">&quot;user-login-name&quot;</span>)</span><br><span class="line">    title.text = <span class="string">&quot;Feeds of &#123;&#125; from eaf-rss-reader&quot;</span>.<span class="built_in">format</span>(user_name)</span><br><span class="line">    body = SubElement(root, <span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> self.rss_list:</span><br><span class="line">        outline = SubElement(body, <span class="string">&#x27;outline&#x27;</span>)</span><br><span class="line">        outline.<span class="built_in">set</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;rss&#x27;</span>)</span><br><span class="line">        outline.<span class="built_in">set</span>(<span class="string">&#x27;text&#x27;</span>, item[<span class="string">&#x27;feed_title&#x27;</span>])</span><br><span class="line">        outline.<span class="built_in">set</span>(<span class="string">&#x27;title&#x27;</span>, item[<span class="string">&#x27;feed_title&#x27;</span>])</span><br><span class="line">        outline.<span class="built_in">set</span>(<span class="string">&#x27;xmlUrl&#x27;</span>, item[<span class="string">&#x27;feed_link&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;link&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">            link = item[<span class="string">&#x27;link&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                link = feedparser.parse(item[<span class="string">&#x27;feed_link&#x27;</span>]).feed.link</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                link = item[<span class="string">&#x27;feed_link&#x27;</span>]</span><br><span class="line">            message_to_emacs(<span class="string">&quot;Failed to export &#123;&#125; &#123;&#125;, please try again later.&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                item[<span class="string">&#x27;feed_title&#x27;</span>]</span><br><span class="line">                ,item[<span class="string">&#x27;feed_link&#x27;</span>]</span><br><span class="line">            ))</span><br><span class="line">        outline.<span class="built_in">set</span>(<span class="string">&#x27;htmlUrl&#x27;</span>, link)</span><br><span class="line"></span><br><span class="line">    tree = ElementTree(root)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    self.beautify_opml(root, <span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file_location = os.path.join(self.location,</span><br><span class="line">    <span class="string">&#x27;eaf-rss-reader-&#x27;</span> + time.strftime(<span class="string">&quot;%Y-%m-%d-%H%M%S&quot;</span>, time.localtime()) + <span class="string">&#x27;.opml&#x27;</span>)</span><br><span class="line">    tree.write(file_location, encoding = <span class="string">&#x27;utf-8&#x27;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line">    message_to_emacs(<span class="string">&quot;All feeds have been exported. Location is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(file_location))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成下一层子节点的方法是<code>SubElement()</code>，eaf-rss-reader的opml文件的层级结构大致是这样的：opml -&gt; head &#x2F; body -&gt; outline1&#x2F;outline2&#x2F;…，某个feed的信息储存在outline的标签参数里面。11～28生成outline，主要包括了feed的title，feed的链接，feed的原链接（网页链接）这三个参数，因为最开始抓取feed的解析疏忽了，没有保存原链接地址，现在已经补上了，对于仍然没有原链接的那部分feed，会进行一个重新抓取，获取到原链接。抓取不到那就只能报错了。</p>
<p>30～36就是美化排版函数的调用和生成文件了，为了文件不重名，所以采用了时间戳命名的方法。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>SICP回顾：cons函数、使用过程定义数据结构（上）</title>
    <url>/2021/11/20/2021/re_sicp1/</url>
    <content><![CDATA[<p>最近在使用python完成SICP2.2部分的一些经典例题，因为在我看来使用不同的语言来完成一件相同的事情能够加深印象和理解。用python实现例题的部分也会再写成一篇文章，但是这里遇到了一些问题，需要先记录一下。</p>
<p>首先是我对2.2节的感悟：构造一个复杂的东西，是需要许多模块进行组合的。这些模块也可以进行拆分，但是拆分到最底层的某些部分，这些部分的构造一定是简单又正确的。（看上去是一句废话，但是要把一个东西构造成简单但是又正确的，还是比较困难的一件事情）</p>
<p>2.2节的最简单又正确的构造就是三个基本的函数<code>cons</code>、<code>car</code>、<code>cdr</code>，他们是那么简单，但是我又无法使用python将他们用一种优雅的方式构造出来。</p>
<p>到底是用python的元组来构造scheme的list，还是用python的列表来构造scheme的list，我没有进行深究，我认为这两种数据结构的效果是类似的。</p>
<h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h2><p>我打算用python现成的数据结构来表达scheme的list，那么<code>cons</code>、<code>car</code>、<code>cdr</code>也是要基于这种数据结构来进行编写的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span>(<span class="params">tuple_parameter</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> tuple_parameter[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span> (TypeError, IndexError):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cdr</span>(<span class="params">tuple_parameter</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> tuple_parameter[<span class="number">1</span>::]</span><br><span class="line">    <span class="keyword">except</span>(TypeError, IndexError):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span>(<span class="params">tuple1, tuple2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(tuple1) != <span class="built_in">tuple</span>):</span><br><span class="line">        tuple1 = (tuple1,)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(tuple2) != <span class="built_in">tuple</span>):</span><br><span class="line">        tuple2 = (tuple2,)</span><br><span class="line">    <span class="keyword">return</span> tuple1 + tuple2</span><br></pre></td></tr></table></figure>

<p>这样的构造在不嵌套元组操作的时候看上去是对的，比如说<code>c = cons(1,2)</code>这样的操作会得到<code>c=(1,2)</code>；但是如果进行嵌套元组操作，就会出错，比如说<code>c=cons((1,2,3),(4,5,6))</code>，我们期望得到的是类似<code>c=((1,2,3),(4,5,6))</code>这样的结构，但是输出结果是<code>c=(1,2,3,4,5,6)</code>。这样的构造是不行的。</p>
<h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><p>我改变了<code>cons</code>的构造，然后整体呈现是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_null</span>(<span class="params">item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item == ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span>(<span class="params">tuple_parameter</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> tuple_parameter[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span> (TypeError, IndexError):</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cdr</span>(<span class="params">tuple_parameter</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> tuple_parameter[<span class="number">1</span>::]</span><br><span class="line">    <span class="keyword">except</span>(TypeError, IndexError):</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span>(<span class="params">tuple1, tuple2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (tuple1,tuple2)</span><br></pre></td></tr></table></figure>

<p>但是这样构造的输出比较丑，我得把元组写成<code>a = (1,(2,(3,(4,()))))</code>这种形式，等价于scheme里面<code>(define a (list 1 2 3 4))</code>，不过后续的部分操作都是对的。使用<code>accumulate</code>函数稍稍验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span>(<span class="params">op, init, seqs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_null(seqs):</span><br><span class="line">        <span class="keyword">return</span> init</span><br><span class="line">    <span class="keyword">return</span> op(car(seqs), accumulate(op, init, cdr(seqs)))</span><br><span class="line"></span><br><span class="line">accumulate(cons, (), a)</span><br><span class="line">accumulate(add, <span class="number">0</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">num1, num2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br></pre></td></tr></table></figure>

<p>如果硬要把元组写成<code>a=(1,2,3,4)</code>这种格式，会出一点问题….使用<code>accumulate(cons, (), a)</code>看一下就明白了，会变成<code>(1, (2, (3, (4, ()))))</code>这样的格式。显然的，<code>a=(1,2,3,4)</code>这种形式要比<code>(1, (2, (3, (4, ()))))</code>看上去美观多了。</p>
<p>但是在scheme却不会出现这种情况，比如说对一个list进行操作：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">accumulate(<span class="name"><span class="builtin-name">cons</span></span>, &#x27;(), a&#x27;)</span><br></pre></td></tr></table></figure>

<p>最终的输出仍然是<code>(1 2 3 4)</code>，所以我推测应该是list与cons的实现存在问题。cons的实现并不是如同我上面那样构造的，或者说当cons应用在list上时呈现效果会有变化。不过更加具体的分析我还没有想好。还有一件更加奇怪的事情。</p>
<p>当我们去嵌套地调用<code>cons</code>函数时，出现的效果是这样的：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> b (<span class="name"><span class="builtin-name">list</span></span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">cons</span></span> a b ) = ((<span class="name">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>) <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>我将它描述为“b嵌套了a”或者”a被b嵌套了”。</p>
<p>但是当我去使用一个函数，情况就发生了变化：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accumulate-n</span> op init seqs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> (<span class="name"><span class="builtin-name">car</span></span> seqs))</span><br><span class="line">      &#x27;()</span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">accumulate</span> op init (<span class="name">car-n</span> seqs))</span><br><span class="line">        (<span class="name">accumulate-n</span> op init (<span class="name">cdr-n</span> seqs)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">car-n</span> seqs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">map</span></span> car seqs))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cdr-n</span> seqs)</span><br><span class="line">  (<span class="name"><span class="builtin-name">map</span></span> cdr seqs))</span><br><span class="line">(<span class="name"><span class="builtin-name">load</span></span> <span class="string">&quot;accumulate.scm&quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> sequence (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">               (<span class="name"><span class="builtin-name">list</span></span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>)</span><br><span class="line">               (<span class="name"><span class="builtin-name">list</span></span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>)</span><br><span class="line">               (<span class="name"><span class="builtin-name">list</span></span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">accumulate-n</span> cons &#x27;() sequence&#x27;)</span><br></pre></td></tr></table></figure>

<p>最后一行的效果是向<code>list1</code>进行一个矩阵翻转。</p>
<p><code>car-n</code>的结果是生成一个list,然后通过accumulate-n将他们都链接起来，链接的方法是<code>cons</code>，但是最后输出的是<code>((1 4 7 10) (2 5 8 11) (3 6 9 12))</code>，并不是嵌套情况！前面举例的那个方法也是两个list通过<code>cons</code>方法链接起来，但是呈现结果是嵌套的。</p>
<p>我就开始猜想是不是因为scheme会根据数据结构的不同来选择不一样的链接方案？比如两个list链接就是类似链表的一种链接，而第二个例子因为已经指明了原本的数据结构是一个list,所以<code>cons</code>的链接方案仍然是list形式的。</p>
<p>我觉得在没有具体了解<code>cons</code>在scheme里面的实现，是无法得到正确的结论的。</p>
<p>所以对于python直接使用现成数据结构构造<code>cons</code>，我目前只能达到这个阶段了。更深层的内容需要更加了解函数式构造方法后再来补充。现在只能用这种丑陋的方法继续完成sicp例题了。</p>
<h2 id="第三次尝试，使用过程构造数据结构"><a href="#第三次尝试，使用过程构造数据结构" class="headerlink" title="第三次尝试，使用过程构造数据结构"></a>第三次尝试，使用过程构造数据结构</h2><p>既然都在构造cons了，不如回顾一下p61提到的使用过程构造cons。</p>
<p>在我之前的尝试里面，cons理所当然地应该是一种数据结构，但是sicp个给了一种方法使他能够被函数构造出来。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">cons</span></span> x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> m)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> m <span class="number">0</span>) x)</span><br><span class="line">      ((<span class="name"><span class="builtin-name">=</span></span> m <span class="number">1</span>) y)</span><br><span class="line">      (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">&quot;Argument not 0 or 1 -- CONS&quot;</span> m))))</span><br><span class="line">  dispatch)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">car</span></span> z) (<span class="name">z</span> <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> z) (<span class="name">z</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>以及python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">elif</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Argument not 0 or 1 -- CONSS&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> z(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cdr</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> z(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这里定义的cons car cdr等都是过程，cons本质上是一个数据结构。</p>
<p>当使用cons对两个数据进行组合的时候，返回的是一个函数：</p>
<p><code>cons(1,2)</code></p>
<p><code>&lt;function cons.&lt;locals&gt;.dispatch at 0x7feab94bb550&gt;</code></p>
<p><code>cons((1,2,3),(4,5,6))</code></p>
<p><code>&lt;function cons.&lt;locals&gt;.dispatch at 0x7feab94bb700&gt;</code></p>
<p>当对被构造出来的这种结构使用car、cdr时，会根据情况来返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = cons((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">b = cons((<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>),a)</span><br><span class="line">car(a)</span><br><span class="line">car(b)</span><br><span class="line">cdr(a)</span><br><span class="line">cdr(b)</span><br></pre></td></tr></table></figure>

<p>前面三种查询都是返回元组本身，也就是可以直接查看到值的结果，但是第四个返回的是<code>&lt;function cons.&lt;locals&gt;.dispatch at 0x7feab94bb700&gt;</code>，因为相当于直接查看a了，a的构造实际上是一个函数。</p>
<p>其实将被构造出来的这些数据带入car、cdr、cons函数并不难理解，这又让我想起来了经典的例题2.6，同样的2.6是使用过程“重新定义”了数字，这里是用过程重新定义cons的数据结构。</p>
<p>其实还有一些问题，不过我已经找到较为优雅的方法了，请看我的<a href="https://scheng52123.com/index.php/2021/11/22/re_sicp1/">下一篇文章</a>。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>scheme</category>
        <category>sicp</category>
      </categories>
  </entry>
  <entry>
    <title>SICP回顾：cons函数、使用过程定义数据结构（下）</title>
    <url>/2021/11/22/2021/re_sicp2/</url>
    <content><![CDATA[<p>接着写<a href="https://scheng52123.com/index.php/2021/11/20/re_sicp1/">上一篇</a>的内容，我打算实现三个基本函数<code>cons</code>、<code>car</code>、<code>cdr</code>，尝试了几种方法都没能很好的实现，并且前两种方法在后来的测试中发现都有问题（第二种方法在嵌套使用的时候仍然有bug）。我逛了一圈github，发现有一位老哥已经用python实现了SICP的大部分习题，<a href="https://github.com/Reo-LEI/SICP-Python">https://github.com/Reo-LEI/SICP-Python</a> 。其中他编写了一个<a href="https://github.com/Reo-LEI/SICP-Python/blob/master/orderedPair.py">ordered.py</a>，其中对cons的实现和对lister（在scheme里面是list）的实现是比较优雅的。</p>
<p>我将他的代码稍稍修改了一下，现在的构造是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_null</span>(<span class="params">item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cdr</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lister</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coner</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> y == []:</span><br><span class="line">            <span class="keyword">return</span> cons(x, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cons(x, coner(y[<span class="number">0</span>], y[<span class="number">1</span>:]))</span><br><span class="line">    L = <span class="built_in">list</span>(args)</span><br><span class="line">    first, other = L[<span class="number">0</span>], L[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> coner(first, other)</span><br></pre></td></tr></table></figure>

<p>其实就是在我的第二次尝试的代码里面使用cons重新写了一个lister数据结构，使cons能够正确处理嵌套结构。</p>
<p>一个lister接受多个参数（*args使函数能够接收若干个参数）。将args转换为list作为temp保存，<code>tuple()</code>无法接受多个参数。 first取第一个（类似car），other取剩余的（类似cdr），使用内部函数对first与other继续递归构造。而coner函数就是将这个list（或者说是other参数）展开，逐个地将元素用cons链接起来，到list被分解完毕了，就返回一个<code>None</code>作为递归的结束（这就类似scheme里的<code>&#39;()</code> 或者 <code>nil</code>了）。</p>
<p>这个数据结构能够很好的处理嵌套的lister和cons，是我上一次构造的时候没想到的，我认为是一个较为优雅的方法了，唯一不足的就是对一个lister的直接呈现效果仍然是这样<code>(1, (2, (3, None)))</code>，而不是<code>(1, 2, 3)</code>这样的。不过问题不大。</p>
<p>因为对重新构造了list的数据结构，那基于list的一些操作函数也会发生变化，python自带的<code>map</code>函数已经无法处理这里的lister了，所以就重新构造了一个<code>mapping</code>和<code>mapping_n</code>函数来作为新的<code>map</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_null</span>(<span class="params">item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapping</span>(<span class="params">func, item</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> is_null(item):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cons(func(car(item)), mapping(func, cdr(item)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapping_n</span>(<span class="params">func, *seqs</span>):</span></span><br><span class="line">    <span class="comment"># 将序列转化为元组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seq_trans</span>(<span class="params">seq</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">translator</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> is_null(cdr(s)):</span><br><span class="line">                <span class="keyword">return</span> [car(s)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [car(s)]+translator(cdr(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(translator(seq))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_map</span>(<span class="params">f, seq</span>):</span></span><br><span class="line">        <span class="keyword">if</span> is_null(car(seq)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cons(f(*seq_trans(car_n(seq))), _<span class="built_in">map</span>(f, cdr_n(seq)))  <span class="comment"># 用*解包元组调用f</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断seqs为树或者多个列表并解包</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(seqs) &gt; <span class="number">1</span>:</span><br><span class="line">        seqs = lister(*seqs)</span><br><span class="line">    <span class="comment"># 若为树直接解包</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        seqs = seqs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">map</span>(func, seqs)</span><br></pre></td></tr></table></figure>

<p><code>mapping(func, item)</code>，类似原map函数，mapping的第一个参数接受一个函数，第二个参数接受一种数据或者一种数据结构。</p>
<p>使用cons将item重新链接，并用car、cdr进行分解，对<code>car(item)</code>执行func操作，<code>cdr(item)</code>取剩下的数据部分，传入mapping进行递归。</p>
<p>而<code>mapping_n</code>是P70脚注78提到的map扩充函数，能够接受多个表作&#x2F;序列作为参数，依次取各个序列第k元素组成序列<code>seq(k)</code>作为<code>func</code>的参数，返回结果序列。</p>
<p><a href="https://github.com/ShaoChenHeng/learnSICP/blob/master/orderedPair.py">这是我修改后的文件</a>，我希望后续能将它变成一个python抽象scheme的标准函数库。</p>
]]></content>
      <categories>
        <category>emacs</category>
        <category>python</category>
        <category>scheme</category>
      </categories>
  </entry>
  <entry>
    <title>我的音乐播放器，Rubber2</title>
    <url>/2021/12/26/2021/rubber2/</url>
    <content><![CDATA[<p>这是本学期一门课程（移动互联）的课程作业，这门课安排的语言是kotlin，但是我用了两下感觉编程体验并不好。后来得知是可以使用任何语言的，于是就选择了较为趁手的Vue.js，再结合uni-app套件实现安卓打包，理论上也可以打包成为ipa，不过我目前还没测试过。</p>
<p>github地址为：<a href="https://github.com/ShaoChenHeng/Rubber2">https://github.com/ShaoChenHeng/Rubber2</a></p>
<p>更多的描述内容已经写在github页面了，可以自行查看，这里不再赘述。</p>
<h2 id="运行图片"><a href="#运行图片" class="headerlink" title="运行图片"></a>运行图片</h2><p><img src="/images/home.jpg" alt="home"> <img src="/images/play1.jpg" alt="play1"> <img src="/images/play2.jpg" alt="play2"> <img src="/images/mine.jpg" alt="mine">) <img src="/images/search2.jpg" alt="search">)</p>
<h2 id="weex-和-uni-app-以及-Hbuilderx"><a href="#weex-和-uni-app-以及-Hbuilderx" class="headerlink" title="weex 和 uni-app 以及 Hbuilderx"></a>weex 和 uni-app 以及 Hbuilderx</h2><p>（要不是这里是博客，我可能已经破口大骂了，哈哈哈。）</p>
<p>weex和uni-app还有许多兼容性问题，这也给我的css排版工作带来了很多问题。最终地播放界面是可以更加好看的（我的最初设想是提取图片主色和次色进行颜色渐变作为背景，无奈各种npm库无法直接使用，手写八叉树的话，uni-app画布建立又与传统js不同；css部分也不支持blur，不支持多方向多颜色的渐变。所以我十分痛苦也十分无奈。），以后我也会慢慢改进呈现出我想要的那个状态来。</p>
<p>uni-app只能在Hbuilderx上进行编译运行，而Hbuilderx只能运行在Windows上，这给我带来了一次 <strong>最不好</strong> 的编程体验。在写这个程序的十天里，我经历了两次莫名奇妙的文件自行被编辑器改动；只要出现引号内的长内容（比如说在进行数据渲染前我需要添加一些测试图片url），就会出现文字排版错误，光标不知道自己该在哪里。</p>
<p>在逐渐习惯了Emacs的全键盘操作后，频繁地进行键鼠切换是一件很痛苦地事情。</p>
<p>要不是迫不得已，我以后不会优先考虑将Hbuilderx作为我的编辑器。</p>
]]></content>
      <categories>
        <category>android</category>
        <category>javascript</category>
        <category>vue-js</category>
      </categories>
  </entry>
  <entry>
    <title>树的映射以及map函数</title>
    <url>/2021/11/07/2021/scale-tree/</url>
    <content><![CDATA[<p>这篇文章是sicp2.2节内容的笔记，主要记录一下里面提到的scale-tree这个函数。</p>
<p>```(scale-tree tree factor)```以一棵树和一个因子作为参数，将树上的所有节点的值都乘上因子。</p>
<p>首先提供了一个朴素版本的scale-tree，就是递归左右子树，检查当前节点是否属于叶子节点。如果是，那么就乘上因子；如果不是，那么就继续左右递归。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">scale-tree</span> tree factor)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? tree) &#x27;())</span><br><span class="line">    ((<span class="name">not</span> (<span class="name">pair</span>? tree)) (<span class="name">*</span> tree factor))</span><br><span class="line">    (<span class="name">else</span> (<span class="name">cons</span> (<span class="name">scale-tree</span> (<span class="name">car</span> tree) factor)</span><br><span class="line">            (<span class="name">scale-tree</span> (<span class="name">cdr</span> tree) factor)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> tree1 (<span class="name">list</span> <span class="number">1</span> (<span class="name">list</span> <span class="number">2</span> (<span class="name">list</span> <span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>) (<span class="name">list</span> <span class="number">5</span> <span class="number">7</span>)))</span><br><span class="line"></span><br><span class="line">（scale-tree  tree1 <span class="number">10</span>）</span><br></pre></td></tr></table></figure>

<p>会使原来的树(也就是tree1)的节点上的值都乘以10。</p>
<p>下面又提供了一个map加lambda匿名函数的版本，但是比较抽象，一下子难以理解。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">scale-tree1</span> tree factor)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">sub-tree</span>)</span><br><span class="line">     (<span class="name">if</span> (<span class="name">pair</span>? sub-tree)</span><br><span class="line">         (<span class="name">scale-tree</span> sub-tree factor)</span><br><span class="line">         (<span class="name">*</span> sub-tree factor)))</span><br><span class="line">       tree))</span><br></pre></td></tr></table></figure>

<p>我使用python重新写了一次，加深理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scale_tree</span>(<span class="params">tree, factor</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> sub_tree : scale_tree(sub_tree, factor) <span class="keyword">if</span> <span class="built_in">type</span>(sub_tree) == <span class="built_in">tuple</span> <span class="keyword">else</span> sub_tree * factor,tree))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scale_tree2</span>(<span class="params">tree, factor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter</span>(<span class="params">subtree</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(subtree) == <span class="built_in">tuple</span>:</span><br><span class="line">            <span class="keyword">return</span> scale_tree2(subtree, factor)</span><br><span class="line">        <span class="keyword">return</span> subtree * factor</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">iter</span>, tree))</span><br><span class="line"></span><br><span class="line">t = ((<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>这里定义的两个函数功能上是一样的，因为scale_tree同时用map、lambda可读性可能不是很高，于是就用高阶函数的方法重新构造了scale_tree2这个函数。</p>
<p>首先要讲的是map函数，通常使用的map函数的参数列表应该是这样的：</p>
<p><code>map(function, parameter)</code></p>
<p>第一个参数接受一个函数，第二个接受一个值或者某种数据结构（也可以传入更多个）。然后将对后面的这个参数使用<code>function</code>。比如说下面这个最简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])))</span><br></pre></td></tr></table></figure>

<p><code>map</code>会对列表中的每一个数都执行一次square,最后会返回一个<code>[1,4,9]</code>。不过这只是对于一层的列表来执行的。通过更高阶的函数配合可以进行更深层的操作，也就是<code>scale-tree</code>，对树的映射。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter</span>(<span class="params">subtree</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(subtree) == <span class="built_in">tuple</span>:</span><br><span class="line">            <span class="keyword">return</span> scale_tree2(subtree, factor)</span><br><span class="line">        <span class="keyword">return</span> subtree * factor</span><br></pre></td></tr></table></figure>

<p>这个<code>iter</code>函数接受的参数是一棵子树，我这里用python的元组来表示scheme中的list，如果当前位置的元素不是元组了，那么就说明是叶子节点，就需要乘以因子；如果不是那么就继续递归遍历子树，不过值得注意的是这里的递归并不是显示的，是通过map函数来进行的，因为它能将函数迭代地操作在每一层的结构上。</p>
<p>再去看上面的那个scheme版本，其实就是一样的写法，不过这种遍历树的方法实在是太妙了。</p>
<p>本来这篇文章应该在上周或者上上周就写好了，但是因为中途又重装了一次arch，又去更新eaf-rss-reader的opml功能，所以一直拖延到了今天才写。不过我总算是把这个这么美妙的方法记录下来了。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>scheme</category>
        <category>sicp</category>
        <category>book</category>
      </categories>
  </entry>
  <entry>
    <title>远程服务器复制操作小记</title>
    <url>/2021/09/01/2021/server-copy/</url>
    <content><![CDATA[<p>因为最近在写学校每日一报自动签到的东西，在远程服务器上写了一个autoSign.py的文件，同时我将这个文件传到了github上（这个操作是在我本地的linux系统上进行的），那么当我在远程服务器上更改了autoSign.py的文件的时候，我想要同步保存它，就需要在远程服务器上使用git了，但是我不想这样子做，于是搜索了一番打算将远程服务器上的文件复制到我本地的linux系统上，再通过本地的linux系统上传文件到github，操作如下（当然下面出现的ip是没用的）</p>
<p>假设远程服务器IP地址为 192.168.1.100</p>
<h2 id="从服务器复制文件到本地"><a href="#从服务器复制文件到本地" class="headerlink" title="从服务器复制文件到本地"></a>从服务器复制文件到本地</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp root@192.168.1.100:/data/test.txt /home/myfile/</span><br><span class="line">补充：</span><br><span class="line">1. 多文件拷贝</span><br><span class="line">　　scp root@192.168.1.100:/data/\&#123;test1.txt,test2.cpp,test3.bin,test.*\&#125; /home/myfile/</span><br><span class="line">2. scp默认连接的远端主机22端口，如果ssh不是使用标准的22端口（以233为例）则使用-P（P大写）指定：</span><br><span class="line">　　scp -P 233 root@192.168.1.100:/data/test.txt /home/myfile/</span><br></pre></td></tr></table></figure>

<p><a href="mailto:&#114;&#111;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#46;&#49;&#54;&#x38;&#46;&#49;&#x2e;&#x31;&#48;&#x30;">&#114;&#111;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#46;&#49;&#54;&#x38;&#46;&#49;&#x2e;&#x31;&#48;&#x30;</a> root是目标服务器的用户名(一般都是root吧？)，192.168.1.100是IP地址，后面紧跟的 “：” 不要忘记，&#x2F;data&#x2F;test.txt（多文件还有test1.txt，test2.cpp，test3.bin，test.a，test.c等） 是目标服务器中你要拷贝文件的地址，接一个空格，后面的 &#x2F;home&#x2F;myfile&#x2F; 是本地接收文件的地址。</p>
<h2 id="从服务器复制文件夹到本地"><a href="#从服务器复制文件夹到本地" class="headerlink" title="从服务器复制文件夹到本地"></a>从服务器复制文件夹到本地</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r root@192.168.1.100:/data/ /home/myfile/</span><br></pre></td></tr></table></figure>

<h2 id="从本地复制文件到服务器"><a href="#从本地复制文件到服务器" class="headerlink" title="从本地复制文件到服务器"></a>从本地复制文件到服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /home/myfile/test.txt root@192.168.1.100:/data/</span><br><span class="line">补充：多文件拷贝</span><br><span class="line">scp /home/myfile/test1.txt test2.cpp test3.bin test.* root@192.168.1.100:/data/</span><br></pre></td></tr></table></figure>

<h2 id="从本地复制文件夹到服务器"><a href="#从本地复制文件夹到服务器" class="headerlink" title="从本地复制文件夹到服务器"></a>从本地复制文件夹到服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /home/myfile/ root@192.168.1.100:/data/</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/clovershell/p/9870603.html">参考文章</a></p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>我的中国开源之夏2021</title>
    <url>/2021/10/16/2021/summer2021/</url>
    <content><![CDATA[<p>今年中科院软件研究所的summer2021活动我参与的是<a href="https://github.com/emacs-eaf/emacs-application-framework">EAF社区（Emacs Application Framework）</a>，具体内容可以查看这个链接：<a href="https://summer.iscas.ac.cn/#/org/prodetail/210510561">Emacs EAF：基于Vue.js实现RSS新闻阅读器</a>，主要的任务是基于EAF框架实现一个Emacs的RSS阅读器。</p>
<p>因为去年参加的<a href="https://github.com/OI-wiki/OI-wiki">OI Wiki社区</a>的撰写文章的活动是完全在我的舒适区内的任务，以后不再继续参与算法竞赛了，并且打算学习一些新东西于是选择了EAF的<a href="https://summer.iscas.ac.cn/#/org/prodetail/210510561">Emacs EAF：基于Vue.js实现RSS新闻阅读器</a>。</p>
<p>项目仓库，<a href="https://github.com/ShaoChenHeng/eaf-rss-reader">eaf-rss-reader</a>。</p>
<p><img src="/images/screenshot-1.png" alt="RSS-Reader1"></p>
<h2 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h2><p>去年的申请流程可以查看这篇文章， <a href="https://scheng52123.com/index.php/2020/09/29/summer-2020/">Summer 2020 从申请到结项</a>。</p>
<p>今年年初到3月份一直无所事事，寒假看了一些科普书，因为当时以为上半年不会有比赛了，所以没怎么写算法题，也没有去看开源项目相关的事情。到了三月末突发想到似乎快gsoc了，于是打开gsoc的页面看了一眼…发现再过两天就开始投proposal了…于是马上开始看gsoc的项目，同时也看了一下中科院这边的暑期活动，中科院这边还是社区申请的阶段（先社区向中科院申请slot，然后学生向中选社区申请），发现很早EAF就已经中选了，去年就关注这个社区了。因为大一的时候看过一点SICP，体验过Emacs编辑器，也简单配置过自己的.emacs文件，这个内容可以在我的文章 <a href="https://scheng52123.com/index.php/2021/01/31/learnemacs/">从零开始的Emacs配置学习</a>里面看见。但是感觉当时自己还是太弱了，lisp只会一点，所以就没有信心去参与EAF社区。gsoc这边花了几天时间从上千个项目中筛选出两个，一个是<a href="https://github.com/saketkc/gencode_regions">gencode_regions</a>，另一个是JavaScript的slang。当时中科院这边的任务还没发布出来，为了防止出现和gsoc一样的匆忙状况，期间给EAF的维护者，也就是我后来的导师MatthewZMD，发了一篇邮件，问了一下今年的任务情况。写完两篇proposal后发现自己被分配到打银川区域赛了…就开始学新的算法，没有再细看EAF的东西…gsoc这边最后两个都没中。</p>
<p>打完区域赛浪了一段时间，就到了五月中旬。5.19左右EAF的具体项目已经发布出来了，今年导师认领任务的情况有变，一个导师最多只能认领三个项目，然而EAF的导师最终只有一位，所以最后也只有三个项目，分别是重构代码（低），写EAF图片处理工具（中），写RSS阅读器（中）。因为去年有一个music-player的项目很感兴趣，但是因为今年已经做出基于vue-js的music-player了所以这个项目在今年就没有出现。然后我就开始仔细研究这三个项目，因为抓取rss文件的过程和爬虫差不多，最开始学习python的时候写的最多的也就是爬虫，于是就选择了编写RSS阅读器的任务（其实本来是想找个难度为高的项目的，无奈EAF这边没有，其他社区slot也已经有人了，我也没再去考虑）。</p>
<p>查询了一些资料，了解了一下RSS阅读器到底是什么东西，看了一些Github上的RSS阅读器的仓库，也体验了一下<a href="https://feedly.com/">Feedly</a>之类的阅读器，然后就开始写proposal了。在6.1完成了<a href="https://docs.google.com/document/d/1bSuUJaW1A6-22lL1aeyLdYsNzgsJqG5JhHkqaibHi4s/edit?usp=sharing">项目申请书</a>,mentor表示写的很好，做了一些小修改最后上交的也就是这一篇。</p>
<p>这次申请过程一路畅通无阻，到最后这个项目也只有我一个申请人（不像去年那个撰写的最后都有8人了…），不过今年的确人数增加了许多，有的项目还是挺卷的。期间帮助自己学校的几位同学申请，最后自己学校有两位同学也入选了今年的暑期活动。其中一位的项目就挺卷的，但是好在她很早就联系了mentor，这个项目的整个构想都是她提出的所以最后也是她入选了。</p>
<p>不过要提醒的是，项目申请书还是得好好写的，虽然有的项目候选人只有一位，但是不好好写申请书的话，还是会落选的。</p>
<p>在提交项目申请书到审核到入选的过程中，看了一下vue.js的官方文档，然后就去冲期末考试了。当时是完全没看懂vue.js编程的，因为之前没接触过这种编程。后面具体的参与过程可以看我的这篇<a href="https://docs.google.com/document/d/1xnKz7avptIV7mXvPSkYQT4SeyjUHhAlNiUNYbP3XYTE/edit">结项报告</a>。接下来我想要详细介绍一下RSS阅读器。</p>
<h2 id="RSS阅读器"><a href="#RSS阅读器" class="headerlink" title="RSS阅读器"></a>RSS阅读器</h2><p>说实话，在接触这个项目之前，我是完全不知道RSS阅读器是什么东西的。现在简单介绍一下。</p>
<p>首先我们可以将网页上的内容整理成一个rss链接，有提供这种rss链接的网站我们可以认为是支持rss服务的，最浅显的一个例子就是豆瓣的个人页面，我们可以在个人页面的右下角看到一个 RSS2.0 的链接，点进去就可以看见这位用户的内容整理了。因为是豆瓣，所以这个链接里面整理的就是这个用户最新的“想读的书”、“看过的电影”之类的内容。如果是某些新闻网站的话，整理出来的就是一些文章了，比如说开源中国提供的一个rss链接<a href="https://www.oschina.net/news/rss">https://www.oschina.net/news/rss</a> 。</p>
<p>但是这种链接点开来是类似一种类似html的超文本格式的，无法直接通过肉眼来看内容，那么就需要一个工具，将rss链接进行解析，得到链接里面的内容并且呈现出来，这个工具就是rss阅读器。并且我们可以在rss阅读器里面添加许多这种链接，这样也就相当于把自己感兴趣的所有东西都放在一个容器里了。</p>
<p>那么只要通过rss阅读器就可以查看内容进入到这个网站的首页查看内容了。也就意味着，我们可以在rss阅读器上专一地看自己感兴趣的内容。我一直有一个想法，其实根本没有必要存在这么多app，很多app提供的主体功能实际上通过浏览器和网页就能够实现了，手机的内存空间也可以得到释放。多年以前手机还没有像今天这样流行的时候其实就是这样的，当时使用平板电脑或者手机还可以在网页的淘宝上进行购物，也可以在网页的qq上进行聊天，但是现在这样的功能已经越来越少，各种服务的app也越来越臃肿、冗余。今天的发展离我的这个想法就是越走越远，不过rss阅读器还是很契合我的想法的，这也是我最后选择它作为我的暑期项目的理由之一。</p>
<p>然而并不是所有的网站都有提供RSS服务的，所以有的网页我们就无法订阅，这时候就需要一个Github上的开源项目：<a href="https://github.com/DIYgod/RSSHub">RSSHub</a>，通过这个项目可以将任何网页生成RSS链接，再使用RSS阅读器就可以订阅互联网上的所有页面了。但是目前我的eaf-rss-reader还无法使用RSSHub生成的链接，主要是代理上的问题，后续会给出解决方案。</p>
<h2 id="关于本项目"><a href="#关于本项目" class="headerlink" title="关于本项目"></a>关于本项目</h2><p><img src="/images/screenshot-2.png" alt="RSS-Reader2"></p>
<p>来讲一讲这次项目使用到的技术栈，vue.js以及其组件vuex，Python-PyQt5、emacs-lisp（主要用于EAF的.el文件编写）、javascript等，并且这里列举的都是在三个月内我学会并且实现的。其他部分python一直是会的，但是图形的PyQt部分一直没有接触过，对于js也只是今年上半年时候读了一部分的javascript编程艺术这本书（粉色封面）学会了一些dom操作。</p>
<p>通过上面提到的那些技术栈的组合，最终完成了一个能够实现feed订阅、feed删除、标记阅读状态、访问源页面（直接调用EAF的browser）、刷新以及自动刷新功能的RSS-Reader。并且其中的添加订阅、刷新功能是多线程的。这也是我第一次学习多线程操作，使用了QThread。</p>
<p>前期以及中期最困难的一个部分是无法使用vue.js调用python函数，不过后来参考了EAF的file-manager项目采取了QWebChannel的方法，十分优雅地解决了，并且这个方法将对我以后编写的程序起到很大的帮助。接下来我会用两篇文章详细介绍一下QThread方法和QWebChannel方法。</p>
<p>关于我的RSS-Reader还欠缺的一些地方，目前只能够直接使用我设计的配色，还没有将配色留出.el文件；preview页面中的文章排版还有问题，也无法显示图片；无法使用RSSHub的链接等。</p>
<h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>解决上面提到的问题。</p>
<p>继续配置Emacs，使它成为我的主力编辑器。</p>
<p>使用Emacs完成SICP。</p>
<p>2022年可能不会参与GSoc或者中科院开源之夏了，如果EAF2022年叫我去当mentor，那我是很乐意的（逃）。下一次参与这种活动可能就是2023年以后了，如果我在那个时间点以后还将继续读书的话。（（（</p>
]]></content>
      <categories>
        <category>summer</category>
      </categories>
  </entry>
  <entry>
    <title>指令设计的三个原则和加速大概率事件</title>
    <url>/2022/05/29/2022/instruction-design/</url>
    <content><![CDATA[<p>记录 <em>计算机组成与接口：硬件&#x2F;软件设计</em> 一书中指令部分频繁提到的三个原则和一个概念。</p>
<h2 id="硬件设计的三条原则"><a href="#硬件设计的三条原则" class="headerlink" title="硬件设计的三条原则"></a>硬件设计的三条原则</h2><ol>
<li><p><strong>简单源于规整</strong> 。规整性使MIPS指令集具有很多特点：所有指令长度统一、算术指令总是需要三个寄存器操作数和寄存器字段在每种指令格式的位置相同。</p>
</li>
<li><p><strong>越小越快</strong> 。对速度的要求导致MIPS只有32个寄存器而不是更多。</p>
</li>
<li><p><strong>优秀的设计需要好的折中</strong> 。一个MIPS例子是在指令中提供更大地址与常数，并且保持所有的指令具有相同的长度之间的折中。</p>
</li>
</ol>
<h2 id="加速大概率事件"><a href="#加速大概率事件" class="headerlink" title="加速大概率事件"></a>加速大概率事件</h2><p>加速大概率事件远比优化小概率事件更能提高性能。大概率事件h通常比小概率事件简单，从而易于提高。大概率事件规则意味着设计者需要知道什么事件是经常发生的，这只有通过仔细的实验与评估才能得出。可以把加速大概率事件想象成一辆赛车，由于通常情况下只有一两名乘客因此提高赛车的速度比提高小型货车的速度容易。</p>
]]></content>
  </entry>
  <entry>
    <title>解释器代码表示笔记</title>
    <url>/2022/02/13/2022/note-representing-code/</url>
    <content><![CDATA[<h3 id="乔姆斯基层次结构"><a href="#乔姆斯基层次结构" class="headerlink" title="乔姆斯基层次结构"></a>乔姆斯基层次结构</h3><p>乔姆斯基层次结构表示不同机器所接受的语言类别。乔姆斯基层次结构的语言类别如下：</p>
<ul>
<li>类型0称为无限制语法</li>
<li>类型1称为上下文相关语法</li>
<li>类型2称为上下文无关语法</li>
<li>类型3称为常规语法&#x2F;正则语法</li>
</ul>
<p>这是一个层次结构，类型3的语言也是类型2、1、0。类型2的语言也是类型1、0。以此类推。</p>
<h3 id="Context-Free-Grammars-上下文无关文法"><a href="#Context-Free-Grammars-上下文无关文法" class="headerlink" title="Context-Free Grammars (上下文无关文法)"></a>Context-Free Grammars (上下文无关文法)</h3><p>在上一章节<a href="http://craftinginterpreters.com/scanning.html">Scanning</a>中，将字符进行分组称为Token（词法标签&#x2F;词法单元）的规则被称为常规语法（regular language）。常规语法可以产生一系列 <strong>扁平</strong> 的Token序列，但是不能够处理深度嵌套的表达式，比如使用树形结构构造一个四则运算表达式的树，就是一种深度嵌套的表达式。</p>
<p>上下文无关文法能够处理这种深度嵌套的表达式。</p>
<h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>我们无法列举出这样一套语法，这套语法能够包含无限多有效字符串。我们可以创建一套有限的规则，你可以把它们想象成一场你可以朝两个方向“玩”的游戏。</p>
<p>如果从规则入手，你可以用它们生成语法规则内的字符串，通过这种形式创建的字符串被称为 <strong>推导式</strong> （派生式），因为每一个字符串都是由语法规则中推到出来的。<br>在游戏的每一步中，都要选择一条规则，然后按照它告诉你的去做。围绕形式化语法的大部分语言都倾向这种发誓。规则被称为生成式，因为他们生成了语法中的字符串。</p>
<p>这个生成过程和GEB里面提到的 <em>WU 谜题</em> 这一章节的内容有一些相同之处。</p>
<h4 id="WU-谜题"><a href="#WU-谜题" class="headerlink" title="WU 谜题"></a>WU 谜题</h4><p>这个谜题就是“你能产生 <strong>WU</strong> 吗？”，提供了一个字符串 <strong>WJ</strong> ，提供一些规则，使用这些规则把一个字符串变成另一个。重要的、几乎用不着说明的一点是，你决不能做任何违背规则的事情。我们可以把这个限制称做“形式化要求”。</p>
<p>关于我们的形式系统———— <strong>WJU系统</strong> ————要说的第一件事就是它只用了三个字母： <strong>W</strong> 、<strong>J</strong> 、 <strong>U</strong> 。也就是说，WJU系统中的所有字符串都是由这三个字母组成的。一些WJU系统的例子：</p>
<ul>
<li>WU</li>
<li>UJW</li>
<li>WUUWUU</li>
<li>UJJUWJUUJWUJJUWJUUJWUJJU</li>
</ul>
<p>提供的规则有：</p>
<ol>
<li>如果一个现有的字符串结尾是J,则可以在其后面再加上一个U。</li>
<li>如果一个现有的字符串是Wx,那么就可以得到Wxx。</li>
<li>如果JJJ出现在一个现有的字符串中，那么可以用U替代这个JJJ得到一个新的字符串。</li>
<li>如果UU出现在一个现有的字符串中，就可以把它这个UU去掉。</li>
</ol>
<p>规则2中的”x“可以表示任意的字符串。例子：</p>
<ul>
<li>WJU -&gt; WJUJU</li>
<li>WUW -&gt; WUWUW</li>
<li>WU  -&gt; WUU</li>
</ul>
<p>规则3的例子：</p>
<ul>
<li>UWJJJWU -&gt; UWUWU</li>
<li>WJJJJ -&gt; WJU &#x2F; WUJ</li>
<li>JJWJJ -&gt; 这个啥也得不到</li>
<li>WJJJ -&gt; WU</li>
</ul>
<p>规则4的例子：</p>
<ul>
<li>UUU -&gt; UU</li>
<li>WUUUJJJ -&gt; WUJJJ</li>
</ul>
<p>以上就是 WU谜题 的全部规则，现在可以试试找出 WU 了。</p>
<p>&amp;nbsp;<br>&amp;nbsp;</p>
<p>上下文无关文法中的每一个生成式都有一个 <strong>头部</strong> （其名称）和描述其生成内容的 <strong>主体</strong>。从纯粹的形式上来看，主体只是一系列的符号，符号有两种：</p>
<ul>
<li><strong>终止符</strong> 是语法字母表中的一个字母，它可以是任意一个字面值。在我们定义的语法中，终止符是独立的词素（lexemes）———来自扫描器的词法单元（Token），比如 <code>if</code> 或 <code>1234</code>。</li>
</ul>
<p>这些词素（lexemes）被称为“终止符”，表示“终点”，因为它们不会使游戏进行下一步动作了。只是简单地产生了一个符号。</p>
<ul>
<li><strong>非终止符</strong> 是对语法中另一条规则的命名引用，它的意思是“执行那条规则然后将它产生的内容插入到这里”。这样，语法就构成了。</li>
</ul>
<p>一个细节： 你可以有多个同名规则，当遇到一个该名字的非终止符时，可以为他选择同名规则中的任意一条。</p>
<p>我们试图提出一个简单的形式(这是一个巴科斯范式 <strong>BNF</strong> 的变形)。 每个规则都是一个名称，后跟一个箭头（<code>→</code>），后跟一系列符号，最后以分号（<code>;</code>）结尾。 终止符是带引号的字符串，非终止符是小写的单词。</p>
<p>比如这个早餐菜单语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">breakfast  → protein <span class="string">&quot;with&quot;</span> breakfast <span class="string">&quot;on the side&quot;</span> ;</span><br><span class="line">breakfast  → protein ;</span><br><span class="line">breakfast  → bread ;</span><br><span class="line"></span><br><span class="line">protein    → crispiness <span class="string">&quot;crispy&quot;</span> <span class="string">&quot;bacon&quot;</span> ;</span><br><span class="line">protein    → <span class="string">&quot;sausage&quot;</span> ;</span><br><span class="line">protein    → cooked <span class="string">&quot;eggs&quot;</span> ;</span><br><span class="line"></span><br><span class="line">crispiness → <span class="string">&quot;really&quot;</span> ;</span><br><span class="line">crispiness → <span class="string">&quot;really&quot;</span> crispiness ;</span><br><span class="line"></span><br><span class="line">cooked     → <span class="string">&quot;scrambled&quot;</span> ;</span><br><span class="line">cooked     → <span class="string">&quot;poached&quot;</span> ;</span><br><span class="line">cooked     → <span class="string">&quot;fried&quot;</span> ;</span><br><span class="line"></span><br><span class="line">bread      → <span class="string">&quot;toast&quot;</span> ;</span><br><span class="line">bread      → <span class="string">&quot;biscuits&quot;</span> ;</span><br><span class="line">bread      → <span class="string">&quot;English muffin&quot;</span> ;</span><br></pre></td></tr></table></figure>

<p>用这个规则来生成一份早餐，随机选第一个<code>breakfast</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">protein <span class="string">&quot;with&quot;</span> breakfast <span class="string">&quot;on the side&quot;</span></span><br></pre></td></tr></table></figure>

<p>展开第一个非终止符，<code>protein</code>,选一个对应的表达式，选第三个吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">protein    → cooked <span class="string">&quot;eggs&quot;</span> ;</span><br></pre></td></tr></table></figure>

<p>然后再展开 <code>cooked</code> 的生成式，选“poached”吧，这是一个终止符，我们加上它。目前整个早餐字符串是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;poached&quot;</span> <span class="string">&quot;eggs&quot;</span> <span class="string">&quot;with&quot;</span> breakfast <span class="string">&quot;on the side&quot;</span></span><br></pre></td></tr></table></figure>

<p>下一个非终止符还是 <code>breakfast</code> ,第一个 <code>breakfast</code>生成式递归地指向了<code>breakfast</code>规则。语法中的递归是一个很好的标志，表明这个语法是上下文无关的而不是正则的。特别地，递归的非终结符两边都有生成式的递归，意味着语言不是正则的。</p>
<p>利用这个递归的<code>breakfast</code>，反复递归第一条<code>breakfast</code>就可以生成各种早餐了。</p>
<p>每当我们遇到一个规则具有多个生成式时，我们只是随意选了一个。正是这种灵活性，允许少量的语法规则能够编码出组合性更强的字符串集。一个规则直接地或者间接地引用它自己，这就提高了这个规则的灵活性，让我们能够将无限多的字符串打包到一个有限的语法中。</p>
<p>&amp;nbsp;<br>&amp;nbsp;</p>
<p>先去实现一个Lox语言的子集，一旦可以对这个子集进行表示、解析和解释，那么后续的操作就是为它添加新的特性和新的语法。首先要考虑的是这些内容：</p>
<ul>
<li><p><strong>字面量</strong> 。数字、字符串、布尔值和<code>nil</code>。</p>
</li>
<li><p><strong>一元表达式</strong> 。前缀<code>！</code>执行逻辑非运算，<code>-</code>对数字求反。</p>
</li>
<li><p><strong>二元表达式</strong> ，其中包括中缀算数符号<code>+，-，*，/</code>以及逻辑运算符号<code>==，！=，&lt;，&lt;=，&gt;，&gt;=</code>。</p>
</li>
<li><p><strong>括号</strong> 。 <code>（</code> 和 <code>）</code> 。</p>
</li>
</ul>
<p>上面提到的这些运算已经能够完成简单四则运算了。</p>
<p>用一种BNF变形来表示这种语法结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expression     → literal</span><br><span class="line">               | unary</span><br><span class="line">               | binary</span><br><span class="line">               | grouping ;</span><br><span class="line"></span><br><span class="line">literal        → NUMBER | STRING | <span class="string">&quot;true&quot;</span> | <span class="string">&quot;false&quot;</span> | <span class="string">&quot;nil&quot;</span> ;</span><br><span class="line">grouping       → <span class="string">&quot;(&quot;</span> expression <span class="string">&quot;)&quot;</span> ;</span><br><span class="line">unary          → ( <span class="string">&quot;-&quot;</span> | <span class="string">&quot;!&quot;</span> ) expression ;</span><br><span class="line">binary         → expression operator expression ;</span><br><span class="line">operator       → <span class="string">&quot;==&quot;</span> | <span class="string">&quot;!=&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span></span><br><span class="line">               | <span class="string">&quot;+&quot;</span>  | <span class="string">&quot;-&quot;</span>  | <span class="string">&quot;*&quot;</span> | <span class="string">&quot;/&quot;</span> ;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>interpreter</tag>
      </tags>
  </entry>
</search>
