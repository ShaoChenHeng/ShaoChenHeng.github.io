<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
    
    
    
    


    <!-- meta -->


<title>进程描述与控制 Q&amp;A | SCHeng</title>





    <!-- OpenGraph -->
 
    <meta name="description" content="1. 什么是前趋图？为什么要引入前趋图？前驱图是一个有向无环图，用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，节点间的有向边则表示两个结点之间存在的偏序或前驱关系。 原因：为了更好地描述进程地顺序和并发执行情况。 3. 为什么程序并发执行会产生间断性特征？程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系">
<meta property="og:type" content="article">
<meta property="og:title" content="进程描述与控制 Q&amp;A">
<meta property="og:url" content="http://example.com/2022/08/06/OS2/index.html">
<meta property="og:site_name" content="SCHeng">
<meta property="og:description" content="1. 什么是前趋图？为什么要引入前趋图？前驱图是一个有向无环图，用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，节点间的有向边则表示两个结点之间存在的偏序或前驱关系。 原因：为了更好地描述进程地顺序和并发执行情况。 3. 为什么程序并发执行会产生间断性特征？程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-06T18:40:27.000Z">
<meta property="article:modified_time" content="2022-08-06T18:41:09.114Z">
<meta property="article:author" content="scheng">
<meta name="twitter:card" content="summary_large_image">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/monokai.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/dark.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="SCHeng" type="application/atom+xml">
</head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">SCHeng</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/atom.xml" class="navbar-menu button">Feed</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/atom.xml" class="dropdown-menu button">Feed</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        进程描述与控制 Q&amp;A
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2022/08/" class="post-meta__date button">2022-08-06</a>
        
 
        
    
    


 

 
    </div>
</div>



<article class="post content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h3 id="1-什么是前趋图？为什么要引入前趋图？"><a href="#1-什么是前趋图？为什么要引入前趋图？" class="headerlink" title="1. 什么是前趋图？为什么要引入前趋图？"></a>1. 什么是前趋图？为什么要引入前趋图？</h3><p>前驱图是一个有向无环图，用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，节点间的有向边则表示两个结点之间存在的偏序或前驱关系。</p>
<p>原因：为了更好地描述进程地顺序和并发执行情况。</p>
<h3 id="3-为什么程序并发执行会产生间断性特征？"><a href="#3-为什么程序并发执行会产生间断性特征？" class="headerlink" title="3. 为什么程序并发执行会产生间断性特征？"></a>3. 为什么程序并发执行会产生间断性特征？</h3><p>程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。</p>
<p>（不可再现性。程序在并发执行时由于不知道哪个程序会被优先执行导致处理结果可能出现不一致。）</p>
<h3 id="4-程序并发执行时为什么会失去封闭性和可再现性？"><a href="#4-程序并发执行时为什么会失去封闭性和可再现性？" class="headerlink" title="4. 程序并发执行时为什么会失去封闭性和可再现性？"></a>4. 程序并发执行时为什么会失去封闭性和可再现性？</h3><p>封闭性指的是程序一但开始执行，其计算结果就取决于程序本身，不受外界因素影响。可再现性是指当程序重复执行多次时，必将得到相同结果。</p>
<p>因为程序并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态是由多个程序来改变，致使程序的运行失去了封闭性。而程序一旦失去了封闭性也会导致其再失去可再现性。</p>
<h3 id="5-在操作系统中为什么要引入进程的概念？它会产生什么样的影响？"><a href="#5-在操作系统中为什么要引入进程的概念？它会产生什么样的影响？" class="headerlink" title="5. 在操作系统中为什么要引入进程的概念？它会产生什么样的影响？"></a>5. 在操作系统中为什么要引入进程的概念？它会产生什么样的影响？</h3><p>为了使程序可以并发执行，并且可以对并发执行的程序加以描述和控制。</p>
<p>失去封闭性，具有间断性，运行结果不可再现</p>
<h3 id="6-试从动态性、并发性和独立性上比较进程和程序。"><a href="#6-试从动态性、并发性和独立性上比较进程和程序。" class="headerlink" title="6. 试从动态性、并发性和独立性上比较进程和程序。"></a>6. 试从动态性、并发性和独立性上比较进程和程序。</h3><p>动态性是进程最基本的特性，可表现为由创建而产生、由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡，因此进程有一定的生命周期。而程序只是一组有序指令的集合，是静态实体。</p>
<p>并发性是进程的重要特征，同时也是OS的重要特征。引入进程的目的正是为了使程序能和已建立进程的程序并发执行。而程序本身是不能并发执行的。</p>
<p>独立性是指进程实体是一个独立运行的基本单位，同时也是系统中独立获取资源和独立调度的基本单位。而对于未建立任何进程的程序，都不能作为一个独立的单位来运行。</p>
<h3 id="7-试说明PCB的作用具体表现在哪几个方面，为什么说-PCB-是进程存在的唯一标志？"><a href="#7-试说明PCB的作用具体表现在哪几个方面，为什么说-PCB-是进程存在的唯一标志？" class="headerlink" title="7. 试说明PCB的作用具体表现在哪几个方面，为什么说 PCB 是进程存在的唯一标志？"></a>7. 试说明PCB的作用具体表现在哪几个方面，为什么说 PCB 是进程存在的唯一标志？</h3><p><strong>PCB（进程控制块）:</strong></p>
<p>系统中用来存放进程管理和控制信息的数据结构称为进程控制块（Process Control Block）。</p>
<p><strong>PCB的作用：</strong></p>
<p>进程控制块用来保存每个进程和资源的相关信息，包括进程标识、空间、运行状态、资源等相关信息。以便操作系统控制和管理进程和资源。因而它的作用是使一个在多道程序环境下不能独立运行的程序（含数据），称为一个能独立运行的基本单位，一个能和其他进程并发执行的进程。创建进程，实质上是创建进程的PCB；而撤销进程，实质上是撤销进程的PCB。</p>
<p>在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据；进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB;当进程由于某种原因而暂停执行时，又需将其断点的处理机环境保存在PCB中。可见，在进程的整个生命周期中，系统总是通过PCB对进程进行控制的，亦即系统是根据 进程的PCB感知该进程的存在的，所以，PCB是进程存在的唯一标志。</p>
<h3 id="8-PCB提供了进程管理和进程调度所需要的哪些信息？"><a href="#8-PCB提供了进程管理和进程调度所需要的哪些信息？" class="headerlink" title="8. PCB提供了进程管理和进程调度所需要的哪些信息？"></a>8. PCB提供了进程管理和进程调度所需要的哪些信息？</h3><p>进程管理：程序和数据的地址，进程同步和通信机制，资源清单，链接指针。</p>
<p>进程调度：进程状态，进程优先级，进程调度所需其他信息，事件。</p>
<h3 id="9-进程控制块的组织方式有哪几种？"><a href="#9-进程控制块的组织方式有哪几种？" class="headerlink" title="9. 进程控制块的组织方式有哪几种？"></a>9. 进程控制块的组织方式有哪几种？</h3><ol>
<li><p>线性：无论PCB什么状态都将其连续地存放在内存</p>
</li>
<li><p>链接：同一个状态下的PCB串起来链接成一个队列</p>
</li>
<li><p>索引：状态指针 -&gt; 状态索引表-&gt; （表中每一行单指向）一个PCB</p>
</li>
</ol>
<h3 id="10-何谓操作系统内核？内核的主要功能是什么？"><a href="#10-何谓操作系统内核？内核的主要功能是什么？" class="headerlink" title="10. 何谓操作系统内核？内核的主要功能是什么？"></a>10. 何谓操作系统内核？内核的主要功能是什么？</h3><p>通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧密程度较高的软件层次中，将他们常驻内存，即内核。</p>
<p>中断处理、时钟管理、原语操作。</p>
<h3 id="11-为什么要引入挂起状态？该状态有哪些性质？"><a href="#11-为什么要引入挂起状态？该状态有哪些性质？" class="headerlink" title="11. 为什么要引入挂起状态？该状态有哪些性质？"></a>11. 为什么要引入挂起状态？该状态有哪些性质？</h3><p>挂起的过程中，PCB被复制到指定内存区域考察进程运行情况（主要目的是为了检查与修改或是暂停程序）。在下一章中挂起的目的主要是在内存不足时，将内存中的进程调回外存中等待。<br>与阻塞不同，挂起是主动的，现行状态由活动改为静止。需要注意的是，若进程处于执行状态挂起时，会进入静止就绪，再次激活会进入活动就绪状态而不是回到执行态。</p>
<h3 id="12-试说明进程在三个基本状态之间转换的典型原因"><a href="#12-试说明进程在三个基本状态之间转换的典型原因" class="headerlink" title="12. 试说明进程在三个基本状态之间转换的典型原因"></a>12. 试说明进程在三个基本状态之间转换的典型原因</h3><ol>
<li><p>就绪状态 -&gt; 执行状态：进程分配到CPU资源（进程调度）</p>
</li>
<li><p>执行状态 -&gt; 就绪状态：时间片用完、有更高优先级进程抢占。</p>
</li>
<li><p>执行状态 -&gt; 阻塞状态：I&#x2F;O请求、等待某事件、申请某种资源。</p>
</li>
<li><p>阻塞状态 -&gt; 就绪状态：I&#x2F;O完成、某时间发生、申请到某种资源。</p>
</li>
</ol>
<h3 id="13-在进程切换时，所要保存的处理机状态信息有哪些。"><a href="#13-在进程切换时，所要保存的处理机状态信息有哪些。" class="headerlink" title="13. 在进程切换时，所要保存的处理机状态信息有哪些。"></a>13. 在进程切换时，所要保存的处理机状态信息有哪些。</h3><ol>
<li><p>进程当前暂存信息</p>
</li>
<li><p>下一指令地址信息</p>
</li>
<li><p>进程状态信息</p>
</li>
<li><p>过程和系统调用参数及调用地址信息</p>
</li>
</ol>
<h3 id="14-试说明引起进程创建的主要事件。"><a href="#14-试说明引起进程创建的主要事件。" class="headerlink" title="14. 试说明引起进程创建的主要事件。"></a>14. 试说明引起进程创建的主要事件。</h3><ol>
<li><p>用户登录：系统为用户创建一个进程，并插入就绪队列</p>
</li>
<li><p>作业调度</p>
</li>
<li><p>提供服务：系统为用户请求创建一个进程</p>
</li>
<li><p>应用请求：用户程序自己创建进程</p>
</li>
</ol>
<h3 id="15-试说明引起进程撤销的主要事件"><a href="#15-试说明引起进程撤销的主要事件" class="headerlink" title="15. 试说明引起进程撤销的主要事件"></a>15. 试说明引起进程撤销的主要事件</h3><ol>
<li><p>进程完成指派工作，正常终止。</p>
</li>
<li><p>由于出现错误，异常终止。</p>
</li>
<li><p>父（或者祖先）进程的要求被终止。</p>
</li>
</ol>
<h3 id="16-在创建一个进程时所要完成的主要工作是什么？"><a href="#16-在创建一个进程时所要完成的主要工作是什么？" class="headerlink" title="16. 在创建一个进程时所要完成的主要工作是什么？"></a>16. 在创建一个进程时所要完成的主要工作是什么？</h3><ol>
<li><p>申请空白PCB（进程控制块）</p>
</li>
<li><p>为新进程分派资源</p>
</li>
<li><p>初始化PCB</p>
</li>
<li><p>将新进程插入就绪队列</p>
</li>
</ol>
<h3 id="17-在撤消一个进程时所要完成的主要工作是什么？"><a href="#17-在撤消一个进程时所要完成的主要工作是什么？" class="headerlink" title="17. 在撤消一个进程时所要完成的主要工作是什么？"></a>17. 在撤消一个进程时所要完成的主要工作是什么？</h3><ol>
<li><p>根据被终止的进程标识符，从PCB集中检索出进程，读出该进程状态</p>
</li>
<li><p>若被终止进程处于执行状态，立即中止该进程的执行，置调度标志为真，指示该进程被终止后重新调度</p>
</li>
<li><p>若该进程还有子进程，应将所有子孙进程终止</p>
</li>
<li><p>将被中止进程的全部资源，归还给父进程&#x2F;系统</p>
</li>
<li><p>将被终止进程PCB,从所在队列或列表中移出</p>
</li>
</ol>
<h3 id="18-试说明引起进程阻塞或被唤醒的主要事件是什么？"><a href="#18-试说明引起进程阻塞或被唤醒的主要事件是什么？" class="headerlink" title="18. 试说明引起进程阻塞或被唤醒的主要事件是什么？"></a>18. 试说明引起进程阻塞或被唤醒的主要事件是什么？</h3><ol>
<li><p>向系统请求共享资源失败</p>
</li>
<li><p>等待某种操作的完成</p>
</li>
<li><p>新数据尚未到达</p>
</li>
<li><p>等待新任务的到达</p>
</li>
</ol>
<h3 id="19-为什么要在OS中引入线程？"><a href="#19-为什么要在OS中引入线程？" class="headerlink" title="19. 为什么要在OS中引入线程？"></a>19. 为什么要在OS中引入线程？</h3><p>由于进程是资源的拥有者，所以在创建、撤销、切换操作中需要较大的时空开销，限制了并发程度的进一步提高。为减少进程切换的开销，把进程作为资源分配单位和调度单位这两个属性分开处理，即进程还是作为资源分配的基本单位，但是不作为调度的基本单位（很少调度或切换），把调度执行与切换的责任交给“线程”。这样做的好处不但可以提高系统的并发度，还能适应新的对称多处理机（SMP）环境的运行，充分发挥其性能。</p>
<h3 id="20-试说明线程有哪些属性？"><a href="#20-试说明线程有哪些属性？" class="headerlink" title="20. 试说明线程有哪些属性？"></a>20. 试说明线程有哪些属性？</h3><p>1.轻型实体</p>
<p>线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源，比如，在每个线程中都应具有一个用于控制线程运行的线程控制块TCB，用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p>
<ol start="2">
<li>独立调度和分派的基本单位</li>
</ol>
<p>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小。</p>
<ol start="3">
<li>可并发执行</li>
</ol>
<p>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行。</p>
<ol start="4">
<li>共享进程资源</li>
</ol>
<p>在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。</p>
<h3 id="21-试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。"><a href="#21-试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。" class="headerlink" title="21. 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。"></a>21. 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。</h3><ol>
<li>调度性</li>
</ol>
<p>在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，在引入线程的OS中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位；</p>
<ol start="2">
<li>并发性</li>
</ol>
<p>在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使OS具有更好的并发性； </p>
<ol start="3">
<li>拥有资源</li>
</ol>
<p>无论是传统的操作系统，还是引入了线程的操作系统，进程始终是拥有资源的一个基本单位，而线程除了拥有一点在运行时必不可少的资源外，本身基本不拥有系统资源，但它可以访问其隶属进程的资源；<br>4. 开销</p>
<p>由于创建或撤销进程时，系统都要为之分配和回收资源，如内存空间等，进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，操作系统在创建、撤消和切换进程时所付出的开销将显著地大于线程。</p>
<h3 id="22-线程控制块-TCB-中包含了哪些内容？"><a href="#22-线程控制块-TCB-中包含了哪些内容？" class="headerlink" title="22. 线程控制块 TCB 中包含了哪些内容？"></a>22. 线程控制块 TCB 中包含了哪些内容？</h3><p><strong>第一种描述</strong></p>
<ol>
<li><p>进程状态：可以是new、ready、running、waiting或halted等</p>
</li>
<li><p>程序计数器：接着要运行的指令地址</p>
</li>
<li><p>CPU寄存器：如累加器、索引寄存器（IndexRegister）、堆栈指针以及一般用途寄存器、状况代码等，主要用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类因计算机架构有所差异</p>
</li>
<li><p>CPU排班法：优先级、排班队列等指针以及其他参数</p>
</li>
<li><p>存储器管理：如分页表（PageTable）等</p>
</li>
<li><p>会计信息：如CPU与实际时间之使用数量、时限、帐号、工作或进程号码</p>
</li>
<li><p>输入输出状态：配置进程使用I&#x2F;O设备，如磁带机</p>
</li>
</ol>
<p><strong>第二种描述</strong></p>
<ol>
<li><p>进程标识符（内部，外部）</p>
</li>
<li><p>处理机的信息：通用寄存器，指令计数器，PSW，用户的栈指针</p>
</li>
<li><p>进程调度信息：进程状态，进程的优先级，进程调度所需的其它信息，事件</p>
</li>
<li><p>进程控制信息：程序的数据的地址，资源清单，进程同步和通信机制，链接指针</p>
</li>
</ol>
<h3 id="23-何谓用户级线程和内核支持线程？"><a href="#23-何谓用户级线程和内核支持线程？" class="headerlink" title="23. 何谓用户级线程和内核支持线程？"></a>23. 何谓用户级线程和内核支持线程？</h3><ol>
<li>用户级线程</li>
</ol>
<p>仅存在于用户空间中的线程，无须内核支持。这种线程的创建、撤销、线程间的同步与通信等功能， 都无需利用系统调用实现。用户级线程的切换通常发生在一个应用进程的诸多线程之间，同样无需内核支持。</p>
<p>有关线程管理的所有工作都由应用程序完成，内核意识不到多线程的存在。用户级线程仅存在于用户空间中，此类线程的创建、撤销、线程之间的同步与通信功能，都无法利用系统调用来实现。应用程序需要通过使用线程库来控制线程。 通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生创建一个在相同进程中运行的新线程。由于线程在进程内切换的规则远比进程调度和切换的规则简单，不需要进行用户态&#x2F;核心态切换，所以切换速度快。</p>
<p>因为用户级线程驻留在用户空间，且管理和控制它们的线程也在用户空间，每个线程并不具有自身的线程上下文，所以它们对于操作系统是不可见的，这也就是它无法被调度到处理器内核的原因。</p>
<p>设置了用户级线程的OS，其调度仍是以进程为单位的</p>
<ol start="2">
<li>内核支持线程：</li>
</ol>
<p>在内核支持下运行的线程。无论是用户进程中的线程，还是系统线程中的线程，其创建、撤销和切换等都是依靠内核，在内核空间中实现的。在内核空间里还 为每个内核支持线程设置了线程控制块，内核根据该控制块感知某线程的存在并实施控制。</p>
<p>内核线程建立和销毁都是在内核的支持下运行，由操作系统负责管理，通过系统调用完成的。</p>
<p>线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</p>
<p>内核线程驻留在内核空间，它们是内核对象。操作系统调度器管理、调度并分派这些线程。运行时库为每个用户级线程请求一个内核级线程，将用户进程映射或绑定到上面。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射。</p>
<p>内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。</p>
<p>操作系统的内存管理和调度子系统必须要考虑到数量巨大的用户级线程。您必须了解每个进程允许的线程的最大数目是多少。操作系统为每个线程创建上下文。进程的每个线程在资源可用时都可以被指派到处理器内核，这些线程可以在全系统内进行资源的竞争。</p>
<h3 id="24-试说明用户级线程的实现方法。"><a href="#24-试说明用户级线程的实现方法。" class="headerlink" title="24. 试说明用户级线程的实现方法。"></a>24. 试说明用户级线程的实现方法。</h3><p>用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统是用于管理和控制线程的函数的集合。内核控制线程或轻型进程 LWP 可通过系统调用获得内核提供服务，利用 LWP 进程作为中间系统。</p>
<h3 id="25-试说明内核线程的实现方法。"><a href="#25-试说明内核线程的实现方法。" class="headerlink" title="25. 试说明内核线程的实现方法。"></a>25. 试说明内核线程的实现方法。</h3><p>系统在创建新进程时，分配一个任务数据区 PTDA ，其中包括若干个线程控制块TCB 空间。创建一个线程分配一个TCB ，有关信息写入TCB ，为之分配必要的资源。当 PTDA 中的TCB 用完，而进程又有新线程时，只要所创建的线程数目未超过系统允许值，系统可在为之分配新的TCB ；在撤销一个线程时，也应回收线程的所有资源和 TCB 。</p>
<h3 id="26-多线程模型有哪几种类型？多对一模型有何优缺点？"><a href="#26-多线程模型有哪几种类型？多对一模型有何优缺点？" class="headerlink" title="26. 多线程模型有哪几种类型？多对一模型有何优缺点？"></a>26. 多线程模型有哪几种类型？多对一模型有何优缺点？</h3><p>多对一模型、一对一模型和多对多模型。</p>
<p>多对一模型的主要缺点在于，如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；此外，在任一时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。</p>
<h3 id="27-进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。"><a href="#27-进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。" class="headerlink" title="27. 进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。"></a>27. 进程和程序之间可以形成一对一、一对多、多对一、多对多的关系，请分别举例说明在什么情况下会形成这样的关系。</h3><p><strong>进程的定义</strong></p>
<p>从不同的角度进程可以有不同的定义，比较典型的定义有：</p>
<ol>
<li><p>进程是程序的一次执行过程。</p>
</li>
<li><p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>
</li>
<li><p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
</li>
</ol>
<p>进程的定义说明了两点：</p>
<ol>
<li><p>进程与程序有关，进程包含程序。程序是进程的核心内容，没有程序就没有进程。</p>
</li>
<li><p>进程不仅仅是程序，还包含程序在执行过程中使用的全部资源。没有资源，程序就无法执行，因此进程是程序执行的载体。</p>
</li>
</ol>
<p>运行一个程序时，操作系统首先要创建一个进程，为进程分配内存等资源，然后加入进程队列中执行(先就绪再执行)。对单个进程的某个时刻而言，一个进程只能执行一个程序，但对整个系统中的进程集合及进程的生命周期而言，进程与程序之间可以形成一对一，多对一，一对多，多对多的关系。</p>
<ul>
<li><p>执行一条命令或运行一个应用程序时：一对一</p>
</li>
<li><p>进程在执行过程中可以加在执行不同的程序：一对多</p>
</li>
<li><p>以不同的参数或数据多次执行同一个程序：多对一</p>
</li>
<li><p>并发地执行不同的应用程序：多对多</p>
</li>
</ul>
<h3 id="28-父进程创建子进程和主程序调用子程序有何不同？"><a href="#28-父进程创建子进程和主程序调用子程序有何不同？" class="headerlink" title="28. 父进程创建子进程和主程序调用子程序有何不同？"></a>28. 父进程创建子进程和主程序调用子程序有何不同？</h3><p>父进程创建子进程后，父进程与子进程同时执行(并发)</p>
<p>主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序开始执行。</p>
<p>我们可以这么理解：父进程运行的程序，创建了子进程，此时父进程和进程并发执行，是两个进程；主程序调用子程序后，主程序暂停，子程序开始执行，它们还是一个进程。</p>
<h3 id="29-为什么进程之间的通信必须借助操作系统内核功能？"><a href="#29-为什么进程之间的通信必须借助操作系统内核功能？" class="headerlink" title="29. 为什么进程之间的通信必须借助操作系统内核功能？"></a>29. 为什么进程之间的通信必须借助操作系统内核功能？</h3><p>每个进程有自己独立地地址空间。在操作系统和硬件的地址保护机制下，进程无法访问其他进程的地址空间，所以必须借助于操作系统的系统调用函数实现进程之间的通信。</p>
<p><strong>进程通信的主要方式</strong></p>
<ol>
<li><p>共享内存区。通过系统调用创建共享内存区。多个进程可以（通过系统调用）连接同一个共享内存区，通过访问共享内存区实现进程之间的数据交换。使用共享内存区时需要利用信息量解决同步互斥问题。</p>
</li>
<li><p>消息传递。通过发送&#x2F;接收消息（两个系统调用）来实现进程之间的通信。当进程发送时，系统将消息从用户缓冲区复制到内核中的消息缓冲区，然后将消息缓冲区挂入消息队列。进程发送的消息保持在消息队列中，直到被另一进程接收。当进程接收消息时，系统从消息队列中解挂消息缓冲区，将消息从内核的消息缓冲区中恢复到用户缓冲区，然后释放消息缓冲区。</p>
</li>
<li><p>管道系统。管道是先进先出的信息流，允许多个进程向管道写入数据，允许多个进程从管道读出数据。在读&#x2F;写过程中，操作系统保证数据的写入顺序和顺序是一致的。（即发送数据和受到的数据在组织上是一致的，如：发送asd，收到asd，不会收到乱序的das等）进程通过读&#x2F;写管道文件或者管道设备实现彼此的通信。</p>
</li>
<li><p>共享文件。利用操作系统提供的文件共享功能实现进程之间的通信。这个时候，也需要信号量来解决文件共享操作中的同步和互斥问题。</p>
</li>
</ol>
<h3 id="30-多任务处理和多线程的区别"><a href="#30-多任务处理和多线程的区别" class="headerlink" title="30. 多任务处理和多线程的区别"></a>30. 多任务处理和多线程的区别</h3><p><strong>多任务处理</strong></p>
<p>早在发明计算机时，用户一次只能提交工作或任务。 但后来随着高速处理器的出现，一个人可以提交多个任务。因此操作系统能够接受更多每个用户的一项任务的能力被称为多任务处理。CPU 通过在它们之间切换来同时执行多个作业。可以从同一用户或不同用户接受各种工作。 有两种类型的多任务系统：</p>
<ul>
<li><p>单用户多任务</p>
</li>
<li><p>多用户多任务处理</p>
</li>
</ul>
<p><strong>多线程</strong></p>
<p>多线程是一种概念编程范式，其中一个进程被划分为多个称为线程的子进程。每个线程都是独立的，并且具有自己的执行路径，并启用了线程间通信。</p>
<p>线程是执行程序时遵循的路径。每个线程都有自己的程序计数器、堆栈和寄存器。线程是一个轻量级进程。</p>
<p>（多线程的解释还是看上文吧）</p>
<h3 id="31-若系统中没有运行进程，是否一定没有就绪进程？"><a href="#31-若系统中没有运行进程，是否一定没有就绪进程？" class="headerlink" title="31. 若系统中没有运行进程，是否一定没有就绪进程？"></a>31. 若系统中没有运行进程，是否一定没有就绪进程？</h3><p>是。因为若系统中没有运行进程，那么系统很快会选择一个就绪进程运行。只有就绪队列中无进程时，CPU 才可以处于空闲状态。</p>
<h3 id="32-若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？"><a href="#32-若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？" class="headerlink" title="32. 若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？"></a>32. 若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？</h3><p>不一定。因为系统中的所有进程可能都处于等待态，可能处于死锁状态，也有可能因为等待的事件未发生而进入循环等待态。（来自王道答案，我觉得这个回答很烂）</p>
<p>调整一下描述：</p>
<p>因为系统中的所有进程可能都处于等待态，可能处于死锁，也有可能因为等待的事件未发生而进入循环等待。</p>
<h3 id="34-采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程"><a href="#34-采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程" class="headerlink" title="34. 采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程?"></a>34. 采用优先级进程调度时，运行进程是否一定是系统中优先级最高的进程?</h3><p>不一定。因为高优先级的进程有可能正处于等待队列中，进程调度会从就绪队列中选择一个进程占用cpu，这个被选中的进程可能优先级较低。</p>
<h3 id="35-为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。"><a href="#35-为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。" class="headerlink" title="35. 为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。"></a>35. 为支持多进程的并发执行，系统必须建立哪些关于进程的数据结构。</h3><p>PCB</p>
<h3 id="36-为支持进程的状态变迁，系统至少应该供哪些进程控制原语？"><a href="#36-为支持进程的状态变迁，系统至少应该供哪些进程控制原语？" class="headerlink" title="36. 为支持进程的状态变迁，系统至少应该供哪些进程控制原语？"></a>36. 为支持进程的状态变迁，系统至少应该供哪些进程控制原语？</h3><p>创建进程原语，阻塞进程原语，换行进程原语，终止进程原语。</p>
<h3 id="37-执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。"><a href="#37-执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。" class="headerlink" title="37. 执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。"></a>37. 执行每个进程控制原语时，系统状态发生什么变化，相应数据结构发生什么变化。</h3><ol>
<li>进程创建原语</li>
</ol>
<p>从PCB集合中申请一个空白的PCB，将调用者参数（如进程外部标识符，初始CPU状态，进程优先数，初始内存及申请资源清单）添入该PCB，设置记账数据。置新进程为“就绪”态。</p>
<ol start="2">
<li>终止进程原语</li>
</ol>
<p>用于终止完成的进程，回收其所占资源。包括消去其资源描述块，消去进程的PCB。</p>
<ol start="3">
<li>阻塞原语</li>
</ol>
<p>将进程从运行态变为阻塞态。进程被插入等待事件的队列，同时修改PCB中相应的表项，如进程状态和等待队列指针。</p>
<ol start="4">
<li>唤醒原语</li>
</ol>
<p>将进程从阻塞态变为就绪态。进程从阻塞队列移出，插入就绪队列，等待调度，同时修改PCB中相应的表项，如进程状态。</p>

    </div>
     
    <div class="post-footer__meta"><p>updated at 2022-08-06</p></div> 
    <div class="post-entry__tags"></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
        </div>
        <div class="nav__next">
            
                <a href="/2022/07/07/OS1/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            操作系统引论 Q&amp;A
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2022 <a href="/">SCHeng</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 



 



 


    
 

 

 

 

 

 




    </body>
</html>
